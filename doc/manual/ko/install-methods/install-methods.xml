<!-- Start of file install-methods/install-methods.xml -->

<chapter id="install-methods">
 <title
>시스템 설치 미디어 얻기</title>


<!-- Start of file install-methods/official-cdrom.xml -->

 <sect1 id="official-cdrom">
 <title
>공식 &debian; CD-ROM 세트</title>
<para
>여러 가지 방법 중에서 &debian; 설치에 가장 쉬운 방법은 공식 데비안 CD-ROM 세트로 설치하는 것입니다. CD 세트는 판매하는 회사에서 (<ulink url="&url-debian-cd-vendors;"
>CD 판매 회사 페이지</ulink
> 참고) 구입할 수 있습니다. 네트워크 연결이 빠르고, CD 라이터가 있으면, 데비안 미러 사이트에서 CD-ROM 이미지를 내려 받아서 직접 CD 세트를 만들 수도 있습니다. (CD 만드는 방법은 <ulink url="&url-debian-cd;"
>데비안 CD 페이지</ulink
> 참고) 데비안 CD 세트가 있고 CD에서 부팅할 수 있으면, 바로 <xref linkend="boot-installer"/> 부분으로 넘어갈 수 있습니다. 이 부팅 CD에는 가능한 범위 내에서 대부분의 사람들에게 필요한 파일들이 들어 있습니다. 바이너리 꾸러미 모음은 전부 여러 장의 CD가 필요하지만, 아마도 3번째 이후의 CD에서 꾸러미가 필요한 일은 없을 겁니다. DVD 버전을 쓸 수도 있습니다. DVD 버전은 보관할 공간도 줄어들고, CD를 이것 저것 교환해야 하는 일도 없습니다. </para
><para
>CD 세트가 있지만 CD 부팅을 지원하지 않는 경우에는, <phrase condition="supports-floppy-boot"
>플로피 디스크,</phrase
> <phrase arch="s390"
>테이프, 테이프 에뮬레이션,</phrase
> <phrase condition="bootable-disk"
>하드 디스크,</phrase
> <phrase condition="bootable-usb"
>USB 스틱,</phrase
> <phrase condition="supports-tftp"
>네트워크 부팅,</phrase
> 아니면 수동으로 CD에서 커널을 읽어들여서 시스템 설치 프로그램을 맨 처음 부팅할 수 있습니다. 다른 방법으로 부팅할 때 필요한 파일은 CD 안에도 들어 있습니다. 데비안 네트워크 아카이브와 CD의 폴더 구조는 완전히 동일합니다. 그래서 아래에 부팅하는 데 필요한 어떤 파일의 경로가 있으면, CD의 같은 서브 디렉토리 안에서 그 파일을 찾아 보십시오. </para
><para
>설치 프로그램을 부팅하기만 하면, 필요한 다른 파일들은 모두 CD에서 이용할 수 있습니다. </para
><para
>CD 세트가 없으면, 설치 프로그램의 시스템 파일들을 내려 받아서 <phrase arch="s390"
>설치 테이프</phrase
> <phrase condition="supports-floppy-boot"
>플로피 디스크나</phrase
> <phrase condition="bootable-disk"
>하드 디스크나</phrase
> <phrase condition="bootable-usb"
>USB 스틱이나</phrase
> <phrase condition="supports-tftp"
>네트워크로 연결된 컴퓨터에</phrase
> 저장해 놓으십시오. 그러면 이 파일을 이용해 설치 프로그램을 부팅할 수 있습니다. </para>

 </sect1>
<!--   End of file install-methods/official-cdrom.xml -->

<!-- Start of file install-methods/downloading-files.xml -->

 <sect1 id="downloading-files">
 <title
>데비안 미러에서 파일 내려받기</title>

<para
>가장 가까이 있는 (그래서 가장 빠를 것 같은) 미러 사이트를 찾으려면, <ulink url="&url-debian-mirrors;"
>데비안 미러 목록</ulink
>을 참고하십시오. </para
><para
>데비안 미러에서 파일을 내려받을 때, 파일을 <emphasis
>바이너리 (binary)</emphasis
> 모드로 받도록 하십시오. 텍스트나 (text) 자동 (automatic) 모드로 받으면 안 됩니다. </para>

  <sect2 id="where-files">
  <title
>설치 이미지를 찾을 위치</title>

<para
>설치 이미지는 데비안 미러의 <ulink url="&url-debian-installer;/images"
>debian/dists/&releasename;/main/installer-&architecture;/current/images/</ulink
> 디렉토리 안에 있습니다. <ulink url="&url-debian-installer;/images/MANIFEST"
>MANIFEST</ulink
> 파일을 보면 각 이미지 이름과 그 용도가 쓰여 있습니다. </para>


<!-- Start of file install-methods/download/alpha.xml -->


   <sect3 arch="alpha"
><title
>Alpha 설치 파일</title>
<para
>ARC 콘솔 펌웨어에서 <command
>MILO</command
>를 이용해 부팅하려고 한다면, 디스크 이미지에 있는 <command
>MILO</command
>와 <command
>LINLOAD.EXE</command
> 파일이 들어 있는 디스크도 준비해야 합니다. Alpha 펍웨어와 부트 로더에 관한 더 많은 정보는 <xref linkend="alpha-firmware"/> 부분을 참고하십시오. 플로피 이미지는 <filename
>MILO</filename
> 디렉토리에 <filename
>milo_<replaceable
>서브아키텍처</replaceable
>.bin</filename
>이라는 파일로 들어 있습니다. </para
><para
>불행히도 이 <command
>MILO</command
> 이미지는 테스트를 할 수 없었고 동작하지 않는 서브 아키텍처가 있을 수도 있습니다. 이미지가 동작하지 않으면 해당 <command
>MILO</command
> 바이너리를 플로피에 복사해 보십시오. (<ulink url="&disturlftp;main/disks-alpha/current/MILO/"
></ulink
>) 단 이 <command
>MILO</command
>는 ext2의 <quote
>sparse superblocks</quote
>를 지원하지 않기 때문에, 새로 만든 ext2 파일 시스템에서는 커널을 읽어들일 수 없습니다. 이 문제를 피해가려면, 커널을 <command
>MILO</command
> 바로 다음에 있는 FAT 파티션에 넣으면 됩니다. </para
><para
><command
>MILO</command
> 바이너리는 플랫폼마다 다릅니다. 여러분의 Alpha 플랫폼에 맞는 <command
>MILO</command
> 이미지를 찾으려면 <xref linkend="alpha-cpus"/> 부분을 참고하십시오. </para>
   </sect3>
<!--   End of file install-methods/download/alpha.xml -->

<!-- Start of file install-methods/download/arm.xml -->


   <sect3 arch="arm" id="riscpc-install-files">
   <title
>RiscPC 설치 파일</title>
<para
>RiscPC 설치 프로그램은 처음에 RISC OS에서 부팅합니다. 필요한 파일은 모두 &rpc-install-kit; ZIP 파일 하나에 들어가 있습니다. 이 파일을 RISC OS 기계에 내려받아서, <filename
>linloader.!Boot</filename
> 컴포넌트를 적당한 위치에 복사하고 <filename
>!dInstall</filename
>을 실행하십시오. </para>
   </sect3>

   <sect3 arch="arm" id="netwinder-install-files">
   <title
>NetWinder 설치 파일</title>
<para
>NetWinder를 부팅하는 가장 쉬운 방법은, &netwinder-boot-img; TFTP 이미지를 이용해 네트워크에서 부팅하는 것입니다. </para>
   </sect3>

   <sect3 arch="arm" id="cats-install-files">
   <title
>CATS 설치 파일</title>
<para
>CATS에서 지원하는 유일한 부팅 방법은 &cats-boot-img; 겸용 이미지를 사용하는 것입니다. Cyclone 부트로더에 접근할 수 있는 어떤 장치에서든 읽어들일 수 있습니다. </para>
   </sect3>
<!--   End of file install-methods/download/arm.xml -->

<!-- Start of file install-methods/download/powerpc.xml -->

<!-- commented out as it seems out of date and the links are broken

   <sect3 arch="powerpc" id="newworld-install-files">
   <title
>NewWorld MacOS Installation Files </title>
<para>

For floppy-less installation on NewWorld Macs, it may be most
convenient to obtain all the necessary files packaged into one Stuffit
archive from
<ulink url="&url-powerpc-of;"
></ulink
> (separate instructions are
included in the archive). Otherwise, obtain the normal installation
files listed above. Retrieve the files to an HFS (not HFS+) partition
on your system.  You will also need the <filename
>yaboot</filename
> and
<filename
>yaboot.conf</filename
> files from the
<ulink url="&downloadable-file;new-powermac/"
>new-powermac</ulink
> or
<ulink url="&downloadable-file;powermac/"
>powermac</ulink
> archive folder.
However, the newest G4 PowerMacs, and those that work without MacOS 9,
need the newest version of <command
>yaboot</command
>; the one in the
archive will not work. Obtain the newest version from
<ulink url="http://penguinppc.org/projects/yaboot/"
></ulink
>.

</para>
   </sect3>

-->
<!--   End of file install-methods/download/powerpc.xml -->

<!-- Start of file install-methods/download/m68k.xml -->


   <sect3 arch="m68k" id="kernel-22">
   <title
>커널 고르기</title>

<para
>일부 m68k 서브 아키텍처에서는 설치할 커널을 선택할 수 있습니다. 일반적인 경우라면 가장 최근의 버전을 처음에 시도해 보시길 권합니다. 해당 서브 아키텍처나 기계에서 2.2.x 커널이 필요한 경우에는, 2.2.x 커널을 지원하는 이미지를 사용하도록 하십시오. (<ulink url="&disturl;/main/installer-&architecture;/current/images/MANIFEST"
>MANIFEST</ulink
>를 참고하십시오) </para>
<para
>모든 2.2.x 커널 m68k 이미지는 &ramdisksize; 커널 파라미터가 필요합니다. </para>
   </sect3>
<!--   End of file install-methods/download/m68k.xml -->

  </sect2>

 </sect1>
<!--   End of file install-methods/downloading-files.xml -->

<!-- Start of file install-methods/ipl-tape.xml -->

 <sect1 arch="s390" id="ipl-tape">
 <title
>IPL 테이프 만들기</title>

<para
>CD-ROM에서 부팅할 수 없고 (IPL) VM을 사용하는 게 아니라면 먼저 IPL 테이프를 만들어야 합니다. <ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg246264.pdf"
> Linux for IBM eServer zSeries and S/390: Distributions</ulink
> Redbook의 3.4.3에 설명되어 있습니다. 테이프에 쓸 때 필요한 파일은 (순서대로): <filename
>kernel.debian</filename
>, <filename
>parmfile.debian</filename
>, <filename
>initrd.debian</filename
>입니다. 이 파일은 <filename
>tape</filename
> 서브 디렉토리에서 내려 받을 수 있습니다. <xref linkend="where-files"/> 부분을 참고하십시오. </para>
 </sect1>

<!--   End of file install-methods/ipl-tape.xml -->

<!-- Start of file install-methods/create-floppy.xml -->

 <sect1 condition="supports-floppy-boot" id="create-floppy">
 <title
>디스크 이미지에서 플로피 만들기</title>
<para
>보통 CD나 다른 방법으로 부팅할 수 없는 하드웨어의 경우, 설치 프로그램을 부팅하는 마지막 방법으로 부팅 플로피 디스크를 사용합니다. </para
><para arch="powerpc"
>알려진 바에 따르면, 플로피 디스크 부팅은 Mac USB 플로피 드라이브에서 실패합니다. </para
><para arch="m68k"
>플로피 디스크 부팅은 Amiga 혹은 68k Mac에서 지원하지 않습니다. </para
><para
>디스크 이미지는 플로피 디스크의 모든 내용이 <emphasis
>로우</emphasis
> 형태로 들어 있는 파일입니다. <filename
>boot.img</filename
>같은 디스크 이미지는 플로피 드라이브에 그냥 복사할 수 없습니다. 이미지 파일을 플로피 디스크에 <emphasis
>로우</emphasis
> 모드로 쓰려면 특별한 프로그램을 사용합니다. 이미지 파일은 디스크 전체의 내용을 그대로 나타내는 파일이기 때문입니다. 파일의 데이터를 플로피에 <emphasis
>섹터 복사</emphasis
>해야 합니다. </para
><para
>디스크 이미지에서 플로피를 만드는 방법은 플랫폼에 따라 세 가지가 있습니다. 여기서는 여러 가지 플랫폼에서 디스크 이미지로 플로피를 만드는 방법을 설명합니다. </para
><para
>플로피를 만들 때 어떤 방법을 사용하든 간에, 플로피를 쓴 다음에 쓰기 방지 탭을 걸어 놓아서 플로피 내용이 손상되지 않도록 하십시오. </para>

  <sect2
><title
>리눅스나 UNIX 시스템에서 디스크 이미지 쓰기</title>
<para
>플로피 디스크 이미지 파일을 플로피 디스크에 쓰려면, 보통은 시스템의 루트 권한이 있어야 합니다. 비어 있는 플로피를 플로피 드라이브에 넣으십시오. 그리고 다음 명령을 사용하십시오: <informalexample
><screen>
$ dd if=<replaceable
>파일이름</replaceable
> of=/dev/fd0 bs=1024 conv=sync ; sync
</screen
></informalexample
> 여기서 <replaceable
>파일이름</replaceable
>은 플로피 디스크 이미지 파일의 이름입니다. (<replaceable
>파일이름</replaceable
>을 뭐라고 해야 할 지는 <xref linkend="downloading-files"/> 부분을 참고하십시오) 플로피 디스크 장치 이름으로는 <filename
>/dev/fd0</filename
>을 가장 많이 씁니다. 워크스테이션에서는 다를 수도 있습니다. <phrase arch="sparc"
>(Solaris에서는 <filename
>/dev/fd/0</filename
>입니다.)</phrase
> 플로피 디스크에 데이터를 다 쓰기도 전에 명령어가 끝나서 프롬프트가 나올 수도 있기 때문에, 플로피 디스크가 사용중이라는 불이 깜박이는 지 잘 살펴 보시고 깜박이지 않을 때 플로피를 드라이브에서 빼야 합니다. 어떤 시스템에서는 플로피를 빼려면 플로피를 꺼내는 별도의 명령을 실행해야 합니다. <phrase arch="sparc"
>(Solaris에서는 <command
>eject</command
> 명령을 사용하십시오. 매뉴얼 페이지를 참고하십시오.)</phrase
> </para
><para
>어떤 시스템에서는 드라이브에 플로피 디스크를 넣으면 자동으로 마운트합니다. <emphasis
>로우 모드</emphasis
>로 플로피를 쓰려면 그 전에 이 기능을 꺼야 합니다. 불행히도, 이 기능을 끄는 방법은 운영 체제마다 다 다릅니다. <phrase arch="sparc"
>Solaris에서 플로피 디스크에 로우 모드로 접근하려면 볼륨 관리 기능을 피해가면 됩니다. 먼저 플로피가 자동 마운트되도록 하십시오. (<command
>volcheck</command
>나 파일 관리자의 해당 명령 사용) 그리고 <command
>dd</command
> 명령을 위에서 쓴 방법대로 쓰시고, 거기에서 <filename
>/dev/fd0</filename
>을 <filename
>/vol/rdsk/<replaceable
>플로피이름</replaceable
></filename
>이라고 바꾸십시오. (<replaceable
>플로피이름</replaceable
>은 포맷할 때 만든 플로피 이름입니다. 이름 없는 플로피는 기본값이 <filename
>unnamed_floppy</filename
>) 그 외의 시스템에서는 시스템 관리자에게 문의하십시오. </phrase
> </para
><para arch="powerpc"
>powerpc 리눅스에서 플로피를 쓰는 경우, 플로피를 꺼내는 명령을 사용해야 합니다. <command
>eject</command
> 프로그램을 사용합니다. 이 프로그램을 따로 설치해야 할 수도 있습니다. </para>

  </sect2>


<!-- Start of file install-methods/floppy/i386.xml -->


<!--  This is not set off for i386 only, because many people will have -->
<!--  access to a PC in order to make a floppy for other arches. -->

  <sect2
><title
>DOS, Windows, OS/2에서 디스크 이미지 쓰기</title>

<para
>i386 기계의 경우는, 다음 명령 중의 하나를 이용해 이미지를 플로피로 복사하십시오. </para
><para
>MS-DOS에서는 <command
>rawrite1</command
> 및 <command
>rawrite2</command
> 프로그램을 사용할 수 있습니다. Windows에서는 DOS 창에서 사용하십시오. Windows 탐색기에서 이 프로그램을 두번 클릭해 봤자 동작하지 <emphasis
>않습니다</emphasis
>. </para
><para
><command
>rwwrtwin</command
> 프로그램은 Windows 95, NT, 98, 2000, ME, XP에서 (그리고 아마도 그 이후 버전에서도) 동작합니다. 사용하려면 같은 디렉토리에서 diskio.dll 파일을 풀어야 합니다. </para
><para
>이 도구는 공식 데비안 CD-ROM의 <filename
>/tools</filename
> 디렉토리 아래에 있습니다. </para>
  </sect2>
<!--   End of file install-methods/floppy/i386.xml -->

<!-- Start of file install-methods/floppy/m68k.xml -->


  <sect2 arch="m68k"
><title
>Atari 시스템에서 디스크 이미지 쓰기</title>
<para
>&rawwrite.ttp; 프로그램이 플로피 디스크 이미지와 같은 디렉토리에 들어 있습니다. 프로그램 아이콘에 두번 클릭해서 실행하고, TOS 프로그램의 명령행 대화 상자에서 플로피에 사용하려는 플로피 이미지 파일의 이름을 입력하십시오. </para>

  </sect2>

  <sect2 arch="m68k"
><title
>Macintosh 시스템에서 디스크 이미지 쓰기</title>
<para
>플로피 디스크에 이미지를 쓸 수 있는 MacOS 프로그램은 없습니다. (그래서 Macintosh에서 설치 시스템을 부팅하거나 커널이나 모듈 설치할 때 플로피 디스크를 사용할 방법이 없습니다) 하지만 이 파일들은 나중 단계에서 운영체제와 모듈을 설치할 때 필요합니다. </para>

  </sect2>
<!--   End of file install-methods/floppy/m68k.xml -->

<!-- Start of file install-methods/floppy/powerpc.xml -->


  <sect2 arch="powerpc"
><title
>MacOS에서 디스크 이미지 쓰기</title>
<para
>디스크 이미지 파일에서 플로피를 만드는 용도로 <application
>Make Debian Floppy</application
>라는 AppleScript가 있습니다. <ulink url="ftp://ftp2.sourceforge.net/pub/sourceforge/d/de/debian-imac/MakeDebianFloppy.sit"
></ulink
>에서 내려 받을 수 있습니다. 이 스크립트를 사용하려면, 데스크탑에 놓은 다음 플로피 이미지를 끌어다 놓으십시오. 확장 관리자에서 Applescript를 설치하고 사용해야 합니다. Disk Copy에서 현재 플로피를 지우고 해당 파일 이미지를 쓸 지 여부를 확인합니다. </para
><para
>MacOS의 <command
>Disk Copy</command
> 유틸리티를 직접 사용할 수도 있고, 프리웨어인 <command
>suntar</command
> 유틸리티를 사용할 수도 있습니다. 플로피 이미지로 예를 들면 <filename
>root.bin</filename
>이 있습니다. 이 유틸리티로 플로피 이미지를 만드려면 다음 방법 중의 하나를 사용하십시오. </para>

   <sect3>
   <title
><command
>Disk Copy</command
>로 디스크 이미지 쓰기</title>
<para
>공식 &debian; CD에 있는 파일에서 플로피 이미지를 만들면, Type과 Creator가 이미 지정되어 있습니다. 다음의 <command
>Creator-Changer</command
> 단계는 데비안 미러에서 이미지 파일을 내려 받을 경우에만 상관 있습니다. </para>
<orderedlist>
<listitem
><para
><ulink url="&url-powerpc-creator-changer;"
>Creator-Changer</ulink
>를 받아서 그걸 이용해 <filename
>root.bin</filename
> 파일을 여십시오. </para
></listitem>
<listitem
><para
>Creator를 <userinput
>ddsk</userinput
>로 (Disk Copy) 바꾸고, Type을 <userinput
>DDim</userinput
>로 (binary floppy image) 바꿉니다. 대소문자를 구별합니다. </para
></listitem>
<listitem
><para
><emphasis
>중요:</emphasis
> Finder에서, <userinput
>Get Info</userinput
>를 사용해 플로피 이미지에 대한 Finder 정보를 표시하십시오. 그리고 <userinput
>File Locked</userinput
>에 <quote
>X</quote
> 표시하십시오. 그래야 MacOS에서 이미지를 마운트하더라도 부트 블록을 망가뜨리지 않습니다. </para
></listitem>
    <listitem
><para
><command
>Disk Copy</command
>를 구하십시오. MacOS 시스템이나 CD가 있으면 거기에 이미 <command
>Disk Copy</command
>가 들어 있을 겁니다. 없으면 <ulink url="&url-powerpc-diskcopy;"
></ulink
>에서 받으십시오. </para
></listitem>
<listitem
><para
><command
>Disk Copy</command
>를 실행하고, <menuchoice
><guimenu
>Utilities</guimenu
> 메뉴에서 <guimenuitem
>Make a Floppy</guimenuitem
>를 선택하십시오.</menuchoice
> 그리고 나타나는 대화 상자에서 <emphasis
>잠긴 (locked)</emphasis
> 이미지 파일을 선택하십시오. 플로피를 넣으라고 물어보고, 정말로 플로피를 지울 지 물어봅니다. 다 마치면 플로피가 튀어 나옵니다. </para
></listitem>
</orderedlist>

   </sect3>

   <sect3>
   <title
><command
>suntar</command
>로 디스크 이미지 쓰기</title>
<para>

<orderedlist>
<listitem
><para
><ulink url="&url-powerpc-suntar;"
></ulink
>에서 <command
>suntar</command
>를 내려받으십시오. <command
>suntar</command
> 프로그램을 실행하고 <userinput
>Special</userinput
> 메뉴에서 <quote
>Overwrite Select...</quote
>를 선택하십시오. </para
></listitem>
<listitem
><para
>플로피를 넣고, &enterkey;를 누르십시오. (섹터 0에서 시작) </para
></listitem>
<listitem
><para
>파일 열기 창에서 <filename
>root.bin</filename
> 파일을 선택하십시오. </para
></listitem>
<listitem
><para
>플로피를 성공적으로 만들었으면, <menuchoice
><guimenu
>File</guimenu
> <guimenuitem
>Eject</guimenuitem
></menuchoice
>를 선택하십시오. 플로피를 쓸 때 오류가 발생하면 그 플로피를 꺼내고 다른 플로피로 시도해 보십시오. </para
></listitem>
</orderedlist>
새로 만든 플로피를 사용하기 전에, <emphasis
>쓰기 방지 탭을 거십시오</emphasis
>! 그렇게 하지 않고 실수로 MacOS에서 마운트하게 되면, MacOS가 데이터를 망가뜨립니다. </para>
   </sect3>
  </sect2>
<!--   End of file install-methods/floppy/powerpc.xml -->

 </sect1>

<!--   End of file install-methods/create-floppy.xml -->

<!-- Start of file install-methods/boot-usb-files.xml -->

 <sect1 condition="bootable-usb" id="boot-usb-files">
 <title
>USB 메모리 스틱 부팅에 필요한 파일 준비하기</title>

<para
>USB 스틱을 준비하려면 GNU/Linux가 동작하고 USB를 지원하는 시스템이 필요합니다. usb-storage 커널 모듈을 읽어들이고 (<userinput
>modprobe usb-storage</userinput
>) 어떤 SCSI 장치로 USB 스틱이 매핑되었는 지 (이 예에서는 <filename
>/dev/sda</filename
>를 사용) 알아야 합니다. USB 메모리 스틱에 쓰려면, 쓰기 방지 스위치를 풀어 놓아야 할 수도 있습니다. </para
><para
>단 USB 스틱은 크기가 최소 128MB는 되어야 합니다. (<xref linkend="usb-copy-flexible"/>에 쓰여 있는 대로 하면 더 작아도 가능합니다) </para>

  <sect2 id="usb-copy-easy">
  <title
>파일 복사하기 &mdash; 쉬운 방법</title>
<para arch="i386"
><filename
>hd-media/boot.img.gz</filename
> 파일에는 <command
>SYSLINUX</command
>와 그 설정 파일들은 물론, 모든 설치 프로그램 파일들이 (커널 포함) 다 들어 있습니다. 이 파일을 풀어서 USB 스틱에 저장해 놓기만 하면 됩니다: <informalexample
><screen
># zcat boot.img.gz &gt; /dev/<replaceable
>sda</replaceable
>
</screen
></informalexample>

</para
><para arch="powerpc"
><filename
>hd-media/boot.img.gz</filename
> 파일에는 <command
>yaboot</command
>와 그 설정 파일들은 물론, 모든 설치 프로그램 파일들이 (커널 포함) 다 들어 있습니다. <command
>mac-fdisk</command
>의 <userinput
>C</userinput
> 명령으로 "Apple_Bootstrap" 타입의 파티션을 USB 스틱에 만들고 이미지를 다음 명령으로 풀어 놓으십시오: <informalexample
><screen
># zcat boot.img.gz &gt; /dev/<replaceable
>sda2</replaceable
>
</screen
></informalexample>

</para>
<warning
><para
>이렇게 하면 해당 장치에 들어 있는 내용이 모두 지워집니다. USB 스틱의 장치 이름을 올바르게 사용하도록 주의하십시오. </para
></warning>
<para
>그 다음 USB 메모리 스틱을 마운트하십시오. (<userinput
>mount <replaceable arch="i386"
>/dev/sda</replaceable
> <replaceable arch="powerpc"
>/dev/sda2</replaceable
> /mnt</userinput
>) 이 USB 메모리 스틱에는 <phrase arch="i386"
>a FAT filesystem</phrase
><phrase arch="powerpc"
>an HFS filesystem</phrase
>이 들어 있고, 그 안에 데비안 네트워크 설치 ISO 이미지 혹은 비지니스 카드 ISO 이미지가 들어 있습니다. 파일 이름이 <filename
>.iso</filename
>로 끝나야 한다는 것에 주의하십시오. 다 끝나면 마운트 해제하십시오. (<userinput
>umount /mnt</userinput
>) </para>
  </sect2>

  <sect2 id="usb-copy-flexible">
  <title
>파일 복사하기 &mdash; 유연한 방법</title>
<para
>좀 더 유연한 방법이 좋다면, 아니면 무슨 일이 일어나고 있는지 보고 싶기라도 하다면, 다음 방법으로 파일을 USB 스틱에 집어 넣으십시오. </para>


<!-- Start of file install-methods/usb-setup/i386.xml -->

   <sect3 arch="i386">
   <title
>&arch-title;에서 USB 스틱 파티션하기</title>
<para
>다음은 메모리 스틱에서 전체 장치를 사용하지 않고, 첫 번째 파티션을 사용하는 방법입니다. </para
><note
><para
>대부분의 USB 장치는 한 개의 FAT16 파티션으로 미리 포맷되어 있기 때문에, 다시 파티션 하거나 다시 포맷할 필요가 없습니다. 해야 한다면, <command
>cfdisk</command
>나 다른 파티션 도구를 이용해 FAT16 파티션을 만들고 다음 명령으로 파일 시스템을 만드십시오: <informalexample
><screen>
# mkdosfs /dev/<replaceable
>sda1</replaceable>
</screen
></informalexample
> USB 스틱의 장치명을 올바르게 사용해야 합니다. <command
>mkdosfs</command
> 명령은 <classname
>dosfstools</classname
> 데비안 꾸러미에 들어 있습니다. </para
></note
><para
>USB 스틱에서 부팅한 다음 커널을 시작하려면 부트 로더를 USB 스틱에 넣어야 합니다. 그 어떤 부트 로더라도 (예를 들어 <command
>LILO</command
>) 동작하지만, <command
>SYSLINUX</command
>를 사용하는 게 편리합니다. <command
>SYSLINUX</command
>는 FAT16 파티션을 사용하고 텍스트 파일을 편집하는 것만으로 설정을 바꿀 수 있기 때문입니다. FAT 파일 시스템을 지원하는 어떤 운영 체제라도 부트 로더를 설정할 때 이용할 수 있습니다. </para
><para
><command
>SYSLINUX</command
>를 USB 스틱의 FAT16 파티션에 넣으려면, <classname
>syslinux</classname
>와 <classname
>mtools</classname
> 꾸러미를 설치하고, 다음 명령을 실행합니다: <informalexample
><screen>
# syslinux /dev/<replaceable
>sda1</replaceable>
</screen
></informalexample
> 다시 말하지만, 신경 써서 장치 이름을 올바르게 쓰십시오. <command
>SYSLINUX</command
>를 실행할 때 그 파티션을 마운트하면 안 됩니다. 이 명령은 파티션에 부트 섹터를 쓰고, 부트로더 코드가 들어 있는 <filename
>ldlinux.sys</filename
> 파일을 만듭니다. </para
><para
>파티션을 마운트하고 (<userinput
>mount /dev/sda1 /mnt</userinput
>) 데비안 아카이브에서 다음 파일을 스틱으로 복사하십시오: <itemizedlist
> <listitem
><para
> <filename
>vmlinuz</filename
> (커널 바이너리) </para
></listitem
> <listitem
><para
> <filename
>initrd.gz</filename
> (최초 램디스크 이미지) </para
></listitem
> <listitem
><para
> <filename
>syslinux.cfg</filename
> (SYSLINUX 설정 파일 </para
></listitem
> <listitem
><para
> 추가 커널 모듈 </para
></listitem
> </itemizedlist
> 파일 이름을 바꾸려면, <command
>SYSLINUX</command
>에서는 DOS 파일이름만 (8.3 방식) 사용할 수 있다는 점을 주의하십시오. </para
><para
><filename
>syslinux.cfg</filename
> 설정 파일에는 다음 두 줄이 들어 있습니다: <informalexample
><screen>
default vmlinuz
append initrd=initrd.gz ramdisk_size=12000 root=/dev/ram rw
</screen
></informalexample
> 부팅하는 이미지에 따라서는 <userinput
>ramdisk_size</userinput
> 파라미터 값을 늘려야 할 수도 있습니다. <phrase condition="sarge"
>부팅이 실패하면, <userinput
>devfs=mount,dall</userinput
> 파라미터를 <quote
>뒤에</quote
> 붙여 보십시오.</phrase
> </para>
   </sect3>
<!--   End of file install-methods/usb-setup/i386.xml -->

<!-- Start of file install-methods/usb-setup/powerpc.xml -->

   <sect3 arch="powerpc">
   <title
>&arch-title;에서 USB 스틱 파티션하기</title>
<para
>USB 스틱 대부분은 Open Firmware가 부팅할 수 없는 방식으로 되어 있어서, USB 스틱을 다시 파티션해야 합니다. Mac 시스템에서는 <userinput
>mac-fdisk /dev/sda</userinput
>라고 실행하고, <userinput
>i</userinput
> 명령으로 새 파티션 맵을 초기화한 다음, <userinput
>C</userinput
> 명령으로 새로운 Apple_Bootstrap 파티션을 만듭니다. (맨 앞의 "파티션"은 항상 파티션 맵 자신입니다) 그리고 다음 명령을 실행하십시오: <informalexample
><screen>
$ hformat /dev/<replaceable
>sda2</replaceable>
</screen
></informalexample
> 주의해서 USB 스틱에 올바른 장치 이름을 사용하십시오. <command
>hformat</command
> 명령은 <classname
>hfsutils</classname
> 데비안 꾸러미에 들어 있습니다. </para
><para
>USB 스틱에서 부팅한 다음 커널을 시작하려면, 부트 로더를 USB 스틱에 넣어야 합니다. <command
>yaboot</command
> 부트 로더를 HFS 파일 시스템에 설치해서 텍스트 파일 편집만으로 설정할 수 있습니다. HFS 파일 시스템을 지원하는 어떤 운영 체제라도 부트로더 설정을 바꾸는 데 이용할 수 있습니다. </para
><para
>보통 <command
>yaboot</command
>에 같이 들어 있는 <command
>ybin</command
>은 아직 USB 저장 장치를 인식하지 못합니다. 그래서 <classname
>hfsutils</classname
>을 이용해 <command
>yaboot</command
>를 수동으로 설치해야 합니다. 다음 명령을 실행하십시오: <informalexample
><screen>
$ hmount /dev/sda2
$ hcopy -r /usr/lib/yaboot/yaboot :
$ hattrib -c UNIX -t tbxi :yaboot
$ hattrib -b :
$ humount
</screen
></informalexample
> 다시 말하지만, 주의해서 올바른 장치 이름을 사용하십시오. 그렇지 않으면 위 명령 도중에 파티션을 마운트하지 못합니다. 위의 과정은 부트 로더를 파티션에 쓰고, HFS 유틸리티를 사용해 Open Firmware가 부팅할 수 있도록 표시합니다. 다 끝나면, 일반적인 유닉스 유틸리티를 사용해 USB 스틱의 나머지를 준비할 수 있습니다. </para
><para
>파티션을 마운트하고 (<userinput
>mount /dev/sda2 /mnt</userinput
>) 데비안 아카이브에서 다음 파일을 USB 스틱으로 복사하십시오: <itemizedlist>
<listitem
><para
><filename
>vmlinux</filename
> (커널 바이너리) </para
></listitem>
<listitem
><para
><filename
>initrd.gz</filename
> (최초 램디스크 이미지) </para
></listitem>
<listitem
><para
><filename
>yaboot.conf</filename
> (yaboot 설정 파일) </para
></listitem>
<listitem
><para
><filename
>boot.msg</filename
> (추가 부팅 메세지) </para
></listitem>
<listitem
><para
>추가 커널 모듈 </para
></listitem>
</itemizedlist>

</para
><para
><filename
>yaboot.conf</filename
> 설정 파일에는 다음 줄이 들어 있습니다: <informalexample
><screen>
default=install
root=/dev/ram

message=/boot.msg

image=/vmlinux
        label=install
        initrd=/initrd.gz
        initrd-size=10000<phrase condition="sarge">
        append="devfs=mount,dall --"</phrase>
        read-only
</screen
></informalexample
> <userinput
>initrd-size</userinput
> 파라미터는 부팅하려는 이미지에 따라 크기를 늘려야 할 수도 있습니다. </para>
   </sect3>
<!--   End of file install-methods/usb-setup/powerpc.xml -->

   <sect3>
   <title
>ISO 이미지 추가하기</title>
<para
>데비안 ISO 이미지를 (비지니스 카드, 네트워크 설치 아니면 완전한 버전이라도) USB 스틱에 (들어간다면) 넣습니다. 이미지의 파일 이름은 <filename
>.iso</filename
>로 끝나야 합니다. </para
><para
>ISO 이미지 없이 네트워크로 설치하려면, 앞의 단계를 건너 뛰십시오. 또 최초 램디스크로 <filename
>hd-media</filename
> 디렉토리에 있는 파일 말고, <filename
>netboot</filename
> 디렉토리에 있는 파일을 사용해야 합니다. <filename
>hd-media/initrd.gz</filename
> 이미지는 네트워크를 지원하지 않습니다. </para
><para
>다 끝나면, USB 메모리 스틱의 마운트를 해제하고 (<userinput
>umount /mnt</userinput
>) 쓰기 방지 스위치를 거십시오? </para>
   </sect3>

   <!-- TODO: doesn't this section belong later? -->
   <sect3 arch="i386">
   <title
>USB 스틱 부팅하기</title>
<warning
><para
>메모리 스틱에서 부팅하지 못한다면, USB 스틱의 master boot record가 (MBR) 잘못되었을 수 있습니다. 바로잡으려면 <classname
>mbr</classname
> 꾸러미에서 <command
>install-mbr</command
> 명령을 사용하십시오: <informalexample
><screen
># install-mbr /dev/<replaceable
>sda</replaceable
>
</screen
></informalexample>

</para
></warning>
   </sect3>
  </sect2>
 </sect1>
<!--   End of file install-methods/boot-usb-files.xml -->

<!-- Start of file install-methods/boot-drive-files.xml -->

 <sect1 condition="bootable-disk" id="boot-drive-files">
 <title
>하드 디스크 부팅에 필요한 파일 준비하기</title>
<para
>설치 프로그램은 기존 하드 드라이브 파티션에 들어 있는 부팅 파일을 이용해서 부팅할 수 있습니다. 다른 운영체제를 통해서 실행할 수도 있고, 아니면 BIOS에서 직접 부트 로더를 실행할 수도 있습니다. </para
><para
><quote
>네트워크만</quote
> 사용해 완전히 설치하려면 이 방법을 사용하면 됩니다. 네트워크 설치를 사용하면 CD 이미지를 찾아서 구울 필요도 없고, 여러 장의 불안한 플로피와 씨름할 필요도 없습니다. </para
><para arch="i386"
>설치 프로그램은 NTFS 파일시스템의 파일에서는 부팅할 수 없습니다. </para
><para arch="powerpc"
>설치 프로그램은 HFS+ 파일 시스템에서는 부팅할 수 없습니다. MacOS 시스템 8.1과 그 후의 버전은 HFS+ 파일 시스템을 사용할 수도 있습니다. NewWorld PowerMac은 전부 HFS+를 사용합니다. 기존 파일 시스템이 HFS+인지 아닌지 알아보려면, 해당 볼륨에서 <userinput
>Get Info</userinput
>를 선택하십시오. HFS 파일 시스템은 <userinput
>Mac OS Standard</userinput
>라고 나오고, HFS+ 파일 시스템은 <userinput
>Mac OS Extended</userinput
>라고 나옵니다. MacOS와 리눅스 사이에 파일을 교환하려면 HFS 파티션을 만들어야 합니다. 특히 설치에 쓸 파일들을 내려 받을 때 이 파티션이 필요합니다. </para
><para arch="powerpc"
>시스템이 <quote
>NewWorld</quote
> 모델인지 <quote
>OldWorld</quote
> 모델인지에 따라, 하드 디스크로 설치 시스템을 부팅할 때 여러 가지 프로그램을 사용합니다. </para>

  <sect2 arch="i386" id="files-lilo">
  <title
><command
>LILO</command
> 혹은 <command
>GRUB</command
>을 이용한 하드 디스크 설치 프로그램 부팅</title>
<para
>여기서는 <command
>LILO</command
> 혹은 <command
>GRUB</command
>을 이용해 기존에 설치한 리눅스에 새로 추가하거나 아니면 기존 리눅스를 덮어 쓰는 방법을 설명합니다. </para
><para
>부팅할 때 부트 로더 두 가지 모두 커널은 물론이고, 디스크 이미지도 메모리에 올리는 기능을 지원합니다. 이 로우 디스크는 커널의 루트 파일 시스템으로 사용할 수 있습니다. </para
><para
>데비안 아카이브의 다음 파일을 하드 드라이브의 편리한 위치로 복사하십시오. 예를 들어 <filename
>/boot/newinstall/</filename
>같은 위치로 복사하십시오. <itemizedlist>
<listitem
><para
><filename
>vmlinuz</filename
> (커널 바이너리) </para
></listitem>
<listitem
><para
><filename
>initrd.gz</filename
> (램디스크 이미지) </para
></listitem>
</itemizedlist>

</para
><para
>마지막으로 부트 로더를 설정하려면 <xref linkend="boot-initrd"/> 부분으로 진행하십시오. </para>
  </sect2>


  <sect2 arch="powerpc" id="files-oldworld">
  <title
>OldWorld Mac에서 하드 디스크 설치 프로그램 부팅</title>
<para
><filename
>boot-floppy-hfs</filename
> 플로피는 <application
>miBoot</application
>를 사용해 리눅스 설치를 시작합니다. 하지만 <application
>miBoot</application
>는 하드 디스크 부팅에는 쉽사리 사용할 수 없습니다. MacOS에서 시작하는 <application
>BootX</application
>는 하드 디스크에 들어 있는 파일에서 부팅하는 기능을 지원합니다. <application
>BootX</application
>는 데비안 설치를 한 다음에도 MacOS와 리눅스 사이에 선택 부팅하는 데 쓸 수도 있습니다. Performa 6360의 경우, <command
>quik</command
>로는 하드 디스크를 부팅 가능하게 만들 수 없습니다. 그래서 이 모델에서는 <application
>BootX</application
>가 필요합니다. </para
><para
><application
>BootX</application
>를 내려 받아서 압축을 푸십시오. <ulink url="&url-powerpc-bootx;"
></ulink
>, 혹은 데비안 http/ftp 미러나 공식 데비안 CD의 <filename
>dists/woody/main/disks-powerpc/current/powermac</filename
> 디렉토리에 들어 있습니다. 압축 파일을 풀려면 <application
>Stuffit Expander</application
>를 사용하십시오. 꾸러미 안을 보면, <filename
>Linux Kernels</filename
>라는 빈 폴더가 있습니다. <filename
>disks-powerpc/current/powermac</filename
> 폴더에서 <filename
>linux.bin</filename
> 및 <filename
>ramdisk.image.gz</filename
> 파일을 받아서, <filename
>Linux Kernels</filename
> 폴더에 넣으십시오. 그리고 <filename
>Linux Kernels</filename
> 폴더를 활성 시스템 폴더에 넣으십시오. </para>
  </sect2>

  <sect2 arch="powerpc" id="files-newworld">
  <title
>NewWorld Mac에서 하드 디스크 설치 프로그램 부팅</title>
<para
>NewWorld PowerMac은 하드 디스크에서 직접 ELF 바이너리를 읽어들이는 것 외에, 네트워크나 ISO9660 CD-ROM을 이용한 부팅을 지원합니다. 이러한 기계에서는 <command
>yaboot</command
>로 직접 리눅스를 부팅합니다. <command
>yaboot</command
>는 MacOS와의 선택 부팅도 지원하고 ext2 파티션에서 직접 커널과 램디스크를 읽어들이는 기능을 지원합니다. 설치 프로그램의 하드 디스크 부팅은 특히 플로피 드라이브가 없는 최신 기계에서 좋습니다. <command
>BootX</command
>는 지원하지 않고 NewWorld PowerMac에서는 사용해서는 안 됩니다. </para
><para
>앞에서 데비안 아카이브에서 내려받은, 다음 4개 파일을 하드 디스크의 맨 위 디렉토리로 <emphasis
>복사</emphasis
>(옮기는 게 아님)하십시오. (각 파일을 <keycap
>option</keycap
> 키를 누르고 하드 드라이브 아이콘으로 끌어오면 됩니다.) <itemizedlist>
<listitem
><para>

<filename
>vmlinux</filename>

</para
></listitem>
<listitem
><para>

<filename
>initrd.gz</filename>

</para
></listitem>
<listitem
><para>

<filename
>yaboot</filename>

</para
></listitem>
<listitem
><para>

<filename
>yaboot.conf</filename>

</para
></listitem>
</itemizedlist>

</para
><para
>이 파일은 넣어 둔 MacOS 파티션의 파티션 번호를 적어 놓으십시오. MacOS의 <command
>pdisk</command
> 프로그램이 있으면, L 명령으로 파티션 번호를 알아낼 수 있습니다. 이 파티션 번호는 나중에 Open Firmware 프롬프트에서 설치 프로그램을 부팅하는 명령에서 사용합니다. </para
><para
>설치 프로그램을 부팅하려면, <xref linkend="boot-newworld"/> 부분으로 계속 진행하십시오. </para>
  </sect2>
 </sect1>
<!--   End of file install-methods/boot-drive-files.xml -->

<!-- Start of file install-methods/install-tftp.xml -->

 <sect1 condition="supports-tftp" id="install-tftp">
 <title
>TFTP 네트워크 부팅에 필요한 파일 준비하기</title>
<para
>LAN에 연결되어 있다면, 네트워크를 통해 TFTP를 사용해서 다른 기계에서 부팅할 수도 있습니다. 다른 기계에서 설치 시스템을 부팅하려고 한다면, 부팅 파일을 특정 위치에 복사해 놓고, 해당 기계의 부팅을 지원하도록 설정해 놓아야 합니다. </para
><para
>TFTP 서버를 설정해야 합니다. 그리고 많은 기계에서 BOOTP 서버<phrase condition="supports-rarp"
> 아니면 RARP 서버</phrase
><phrase condition="supports-dhcp"
>, 아니면 DHCP 서버</phrase
>를 설정해야 합니다. </para
><para
><phrase condition="supports-rarp"
>Reverse Address Resolution Protocol은 (RARP) 어떤 클라이언트에게 어떤 IP 주소를 사용해야 하는 지 알려주는 한 방법입니다. 또 다른 방법은 BOOP 프로토콜을 사용하는 것입니다. </phrase
> <phrase condition="supports-bootp"
>BOOTP는 컴퓨터에게 그 IP 주소 및 네트워크의 어디에서 부팅 이미지를 가져와야 하는 지 알려주는 IP 프로토콜입니다. </phrase
> <phrase arch="m68k"
> VMEbus 시스템에서는 또 다른 방법이 있습니다. 부팅 ROM에 IP 주소를 수동으로 설정할 수 있습니다. </phrase
> <phrase condition="supports-dhcp"
>DHCP는 (Dynamic Host Configuration Protocol) 더 유연하며, BOOTP와 호환되는 확장 기능입니다. 일부 시스템은 DHCP를 이용해야만 설정할 수 있습니다. </phrase
> </para
><para arch="powerpc"
>PowerPC의 경우, NewWorld Power Macintosh 기계를 가지고 있다면, BOOTP 대신에 DHCP를 사용하는 게 좋습니다. 최근의 일부 기계들은 BOOTP로는 부팅할 수 없습니다. </para
><para arch="alpha"
>Sparc과 PowerPC 기계에 들어 있는 Open Firmware와는 다르게, SRM 콘솔은 IP 주소를 가져올 때 RARP를 쓰지 <emphasis
>않습니다</emphasis
>. 그래서 Alpha를 네트워크 부팅할 때는 BOOTP를 사용해야 합니다. <footnote
> <para
> Alpha 시스템은 DECNet MOP(Maintenance Operations Protocol)을 사용하여 네크워크로부팅할 수 있습니다. 그러나 이 방법은 여기서 다루지 않습니다. 당신의 OpenVMS관리자는 당신이 Alpha에서 리눅스를 부팅하기 위하여 MOP를 사용하는 것에 대한 도움을 줄 것입니다</para
> </footnote
>SRM 콘솔에서 네트워크를 위한 IP 설정을 직접 입력할 수도 있습니다. </para
><para arch="hppa"
>일부 오래된 HPPA 기계의 경우 (예를 들어 715/75) BOOTP를 쓰지 마시고 RBOOTD를 사용하십시오. 데비안에는 <classname
>rbootd</classname
> 꾸러미가 들어 있습니다. </para
><para
>Trivial File Transfer Protocol은 (TFTP) 부팅 이미지를 클라이언트에게 넘겨줄 때 사용합니다. 이론상 이 프로토콜을 사용한다면 어떤 플랫폼의 어떤 서버라도 사용할 수 있습니다. 여기서는 SunOS 4.x, SunOS 5.x (Solaris), 그리고 GNU/Linux에서 사용하는 명령을 예로 듭니다. <note arch="i386"
><para
>TFTP 부팅에서 Pre-boot Execution Environment (PXE) 방식을 사용하려면, <userinput
>tsize</userinput
>를 지원하는 TFTP 서버가 있어야 합니다. &debian; 서버에서는, <classname
>atftpd</classname
> 및 <classname
>tftpd-hpa</classname
> 꾸러미가 이 기능을 지원합니다. <classname
>tftpd-hpa</classname
>를 권장합니다. </para
></note>

</para>


<!-- Start of file install-methods/tftp/rarp.xml -->


  <sect2 condition="supports-rarp" id="tftp-rarp">
   <title
>RARP 서버 준비하기</title>
<para
>RARP를 설정하려면, 설치하려는 클라언트 컴퓨터의 이더넷 주소를 (다른 말로 MAC 주소) 알아야 합니다. 이 정보를 모른다면, <phrase arch="sparc"
> OpenPROM 부팅 메세지에서 보고 알아낼 수도 있고, OpenBoot <userinput
>.enet-addr</userinput
> 명령을 사용할 수도 있고, 아니면 </phrase
> <quote
>응급 복구</quote
> 모드로 부팅해서 (예를 들어 응급 복구 플로피로) <userinput
>/sbin/ifconfig eth0</userinput
> 명령을 이용할 수 있습니다. </para
><para
>리눅스 2.2.x 커널을 사용하는 RARP 서버 시스템에서는, 커널의 RARP 테이블을 조정해야 합니다. 그렇게 하려면 다음 명령을 실행하십시오: <informalexample
><screen>
# <userinput
>/sbin/rarp -s 
<replaceable
>client-hostname</replaceable>
<replaceable
>client-enet-addr</replaceable
></userinput>

# <userinput
>/usr/sbin/arp -s 
<replaceable
>client-ip</replaceable>
<replaceable
>client-enet-addr</replaceable
></userinput>
</screen
></informalexample
> 만약 다음과 같은 에러가 발생하면: <informalexample
><screen>
SIOCSRARP: Invalid argument
</screen
></informalexample
> 그러면 RARP 커널 모듈을 읽어들이거나 RARP를 지원하도록 커널을 다시 컴파일해야 할 겁니다. <userinput
>modprobe rarp</userinput
> 명령을 실행하고 <command
>rarp</command
> 명령을 실행해 보십시오. </para
><para
>리눅스 2.4.x 커널을 사용하는 RARP 서버 시스템에서는, RARP 모듈이 없는 대신 <command
>rarpd</command
> 프로그램을 사용해야 합니다. 그 다음 과정은 SunOS에서 사용하는 방법과 비슷합니다. </para
><para
>SunOS에서는, 클라이언트의 이더넷 하드웨어 주소가 <quote
>ethers</quote
> 데이터베이스 (<filename
>/etc/ethers</filename
> 파일이나 NIS/NIS+를 통해) 및 <quote
>hosts</quote
> 데이터베이스에 들어 있어야 합니다. 그 다음에 RARP 데몬을 시작합니다. SunOS 4에서는, 다음 명령을 (루트로) 실행하십시오: <userinput
>/usr/etc/rarpd -a</userinput
>. SunOS 5에서는 <userinput
>/usr/sbin/rarpd -a</userinput
> 명령을 사용하십시오. </para>
  </sect2>
<!--   End of file install-methods/tftp/rarp.xml -->

<!-- Start of file install-methods/tftp/bootp.xml -->


  <sect2 condition="supports-bootp" id="tftp-bootp">
  <title
>BOOTP 서버 준비하기</title>
<para
>GNU/Linux용 BOOTP 서버는 두 가지가 있습니다. CMU <command
>bootpd</command
>가 있고, 그 외의 프로그램은 실제로 DHCP서버인, ISC <command
>dhcpd</command
>가 있습니다. ISC <command
>dhcpd</command
>는 &debian;의 <classname
>bootp</classname
>와 <classname
>dhcp</classname
> 꾸러미에 들어 있습니다. </para
><para
>CMU <command
>bootpd</command
>를 사용하려면, <filename
>/etc/inetd.conf</filename
>에서 관련된 줄의 코멘트를 없애거나 한 줄을 추가해야 합니다. &debian;에선  <userinput
>update-inetd --enable bootps</userinput
>를 실행한 다음 적용하려면 <userinput
>/etc/init.d/inetd reload</userinput
> 명령을 실행합니다. 그 줄은 다음과 같은 모양입니다: <informalexample
><screen>
bootps  dgram  udp  wait  root  /usr/sbin/bootpd  bootpd -i -t 120
</screen
></informalexample
> 이제 <filename
>/etc/bootptab</filename
> 파일을 만들어야 합니다. 이 파일은 과거의 BSD <filename
>printcap</filename
>, <filename
>termcap</filename
>, <filename
>disktab</filename
> 파일과 같이 익숙하면서도 의미를 알기 어려운 형식으로 되어 있습니다. 더 자세한 정보는 <filename
>bootptab</filename
> 매뉴얼 페이지를 참고하십시오. CMU <command
>bootpd</command
>에서는, 클라이언트의 하드웨어 (MAC) 주소를 알아야 합니다. 다음은 <filename
>/etc/bootptab</filename
>의 예입니다: <informalexample
><screen>
클라이언트:\
  hd=/tftpboot:\
  bf=tftpboot.img:\
  ip=192.168.1.90:\
  sm=255.255.255.0:\
  sa=192.168.1.1:\
  ha=0123456789AB:
</screen
></informalexample
> 위에서 최소한 <quote
>ha</quote
> 옵션은 바꿔야 합니다. 이 옵션은 클라이언트의 하드웨어 주소를 나타냅니다. <quote
>bf</quote
> 옵션은 TFTP로 클라이언트가 받게 될 파일을 지정합니다. 자세한 정보는 <xref linkend="tftp-images"/> 부분을 참고하십시오. <phrase arch="mips"
> SGI Indy에서는 커맨드 모니터로 들어가서 <userinput
>printenv</userinput
>라고 입력하면 됩니다. <userinput
>eaddr</userinput
> 변수의 값이 MAC 주소입니다. </phrase
> </para
><para
>반대로, ISC <command
>dhcpd</command
> 설정은 정말 쉽습니다. BOOTP 클라이언트를 DHCP 클라이언트의 일종의 특별한 케이스로 취급하기 때문입니다. 일부 아키텍쳐에서는 BOOTP로 부팅하게 하려면 복잡한 설정이 필요합니다. 그러한 아키텍처의 경우는 <xref linkend="dhcpd"/> 부분을 참고하십시오. 그게 아니라면 <userinput
>allow bootp</userinput
>를 클라이언트가 들어 있는 서브넷의 설정 부분에 집어 넣고, <userinput
>/etc/init.d/dhcpd restart</userinput
> 명령으로 <command
>dhcpd</command
>를 다시 시작하면 됩니다. </para>
  </sect2>
<!--   End of file install-methods/tftp/bootp.xml -->

<!-- Start of file install-methods//tftp/dhcp.xml -->

  <sect2 condition="supports-dhcp" id="dhcpd">
   <title
>DHCP 서버 설정하기</title>
<para
>자유 소프트웨어 DHCP 서버로 ISC <command
>dhcpd</command
>가 있습니다. &debian;에서 ISC <command
>dhcpd</command
>는 <classname
>dhcp</classname
> 꾸러미 안에 들어 있습니다. 다음은 간단한 설정 파일 예제입니다 (<filename
>/etc/dhcpd.conf</filename
>): <informalexample
><screen>
option domain-name "example.com";
option domain-name-servers ns1.example.com;
option subnet-mask 255.255.255.0;
default-lease-time 600;
max-lease-time 7200;
server-name "servername";

subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.200 192.168.1.253;
  option routers 192.168.1.1;
}

host clientname {
  filename "/tftpboot/tftpboot.img";
  server-name "servername";
  next-server servername;
  hardware ethernet 01:23:45:67:89:AB;
  fixed-address 192.168.1.90;
}
</screen
></informalexample
> 주의: 최근의 (권장) <classname
>dhcp3</classname
> 꾸러미는 <filename
>/etc/dhcp3/dhcpd.conf</filename
> 파일을 사용합니다. </para
><para
>이 예제에서는, DHCP 서버, TFTP 서버, 네트워크 게이트웨이 역할을 모두 하는 <replaceable
>servername</replaceable
>이라는 서버가 있다고 가정합니다. domain-name 옵션도 바꾸고, 서버 이름과 클라이언트 하드웨어 주소도 바꿔야 합니다. <replaceable
>filename</replaceable
> 옵션은 TFTP로 가져오려는 파일의 이름입니다. </para
><para
><command
>dhcpd</command
> 설정 파일을 편집한 다음에, <userinput
>/etc/init.d/dhcpd restart</userinput
> 명령으로 <command
>dhcpd</command
>를 다시 시작하십시오. </para>

   <sect3 arch="i386">
   <title
>DHCP 설정에서 PXE 부팅하게 만들기</title>
<para
>다음은 TFTP의 Pre-boot Execution Environment (PXE) 방식을 이용한 <filename
>dhcp.conf</filename
>의 예입니다. <informalexample
><screen>
option domain-name "example.com";

default-lease-time 600;
max-lease-time 7200;

allow booting;
allow bootp;

# 다음 부분은 여러분 경우에 맞춰 바꿔야 합니다
subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.200 192.168.1.253;
  option broadcast-address 192.168.1.255;
# 게이트웨이 주소입니다.
# (예를 들어 인터넷에 접근하는 방법에 따라 다를 수도 있습니다)
  option routers 192.168.1.1;
# 사용하려는 DNS
  option domain-name-servers 192.168.1.3;
}

group {
 next-server 192.168.1.3;
 host tftpclient {
# TFTP 클라이언트 하드웨어 주소
  hardware ethernet  00:10:DC:27:6C:15;
  filename "/tftpboot/pxelinux.0";
 }
}
</screen
></informalexample
> PXE 부팅의 경우, 커널 이미지가 아니라 클라이언트 파일 이름 <filename
>pxelinux.0</filename
>이 부트 로더입니다. (아래의 <xref linkend="tftp-images"/> 부분 참고) </para>
   </sect3>
  </sect2>
<!--   End of file install-methods//tftp/dhcp.xml -->

  <sect2 id="tftpd">
  <title
>TFTP Server 사용하기</title>
<para
>TFTP 서버를 준비하려면, 먼저 <command
>tftpd</command
> 서버를 사용도록 해야 합니다. 보통 다음과 같은 줄을 <filename
>/etc/inetd.conf</filename
>에 넣으면 됩니다: <informalexample
><screen>
tftp dgram udp wait nobody /usr/sbin/tcpd in.tftpd /tftpboot
</screen
></informalexample
> 데비안 꾸러미의 경우에는 설치만 하면 기본적으로 이런 설정이 들어갑니다. </para
><para
>이 파일을 보고 <command
>in.tftpd</command
>의 인자로 사용하는 디렉토리를 기억해 두십시오. 아래에서 이 디렉토리 이름이 필요합니다. <command
>in.tftpd</command
> 일부 버전에서는, <userinput
>-l</userinput
> 옵션을 쓰면 모든 요청을 시스템 로그에 기록합니다. 이 옵션은 부팅 오류의 원인을 파악하는 데 유용합니다. <filename
>/etc/inetd.conf</filename
> 파일을 고쳤다면, 고쳤다는 사실을 <command
>inetd</command
> 프로세스에 알려야 합니다. 데비안 기계에서는 <userinput
>/etc/init.d/inetd reload</userinput
> 명령을 실행하고, 다른 곳에서는 <command
>inetd</command
>의 프로세스 ID를 찾아서 <userinput
>kill -HUP <replaceable
>inetd-pid</replaceable
></userinput
> 명령을 실행합니다. </para
><para arch="mips"
>데비안을 SGI 기계에 설치하려 하고, TFTP 서버가 리눅스 2.4로 동작하는 GNU/Linux인 경우, 서버에서 다음을 설정해야 합니다: <informalexample
><screen>
# echo 1 &gt; /proc/sys/net/ipv4/ip_no_pmtu_disc
</screen
></informalexample
> 이 명령은 Path MTU discovery 기능을 끕니다. 이 기능을 끄지 하지 않으면 Indy의 PROM이 커널을 내려받지 못합니다. 또 32767보다 높지 않은 포트에서 TFTP 패킷을 보내도록 만드십시오. 그렇지 않으면 첫 번째 패킷을 받은 다음에 멈춰버립니다. 이 문제는 PROM의 버그를 리눅스 2.4.x에서 들춰내는 것입니다. 다음 명령으로 이런 현상을 피할 수 있습니다: <informalexample
><screen>
# echo "2048 32767" &gt; /proc/sys/net/ipv4/ip_local_port_range
</screen
></informalexample
> 이 명령은 리눅스 TFTP 서버에서 사용할 포트의 범위를 조정합니다. </para>
  </sect2>

  <sect2 id="tftp-images">
  <title
>TFTP 이미지를 적당한 위치에 옮기기</title>
<para
>그 다음에, 필요한 TFTP 부팅 이미지를 <xref linkend="where-files"/>에 쓰여 있는 것처럼 <command
>tftpd</command
> 부팅 이미지 디렉토리에 복사해 놓으십시오. 보통 이 디렉토리는 <filename
>/tftpboot</filename
>입니다. 이 파일에서, <command
>tftpd</command
>가 특정 클라이언트를 부팅할 때 사용하는 특정 파일로 링크를 만들어야 할 것입니다. 불행히도 그 파일의 이름은 TFTP 클라이언트가 결정하고, 어떤 표준도 없습니다. </para
><para arch="powerpc"
>NewWorld Power Macintosh 기계에서는, TFTP 부팅 이미지로 <command
>yaboot</command
>를 설정해야 합니다. <command
>yaboot</command
>는 커널과 램디스크를 TFTP를 통해 가져옵니다. 네트워크 부팅의 경우, <filename
>yaboot-netboot.conf</filename
>를 사용하십시오. 이 파일을 TFTP 디렉토리의 <filename
>yaboot.conf</filename
>로 이름을 바꾸십시오. </para
><para arch="i386"
>PXE 부팅의 경우, 필요한 모든 것이 <filename
>netboot/netboot.tar.gz</filename
> 압축 안에 준비되어 있습니다. 이 압축을 <command
>tftpd</command
> 부팅 이미지 디렉토리에서 풀기만 하십시오. <command
>tftpd</command
>에 부팅할 파일 이름으로 <filename
>/pxelinux.0</filename
>을 넘기도록 DHCP 서버에 설정하십시오. </para
><para arch="ia64"
>PXE 부팅의 경우, 필요한 모든 것이 <filename
>netboot/netboot.tar.gz</filename
> 압축 안에 준비되어 있습니다. 이 압축을 <command
>tftpd</command
> 부팅 이미지 디렉토리에서 풀기만 하십시오. <command
>tftpd</command
>에 부팅할 파일 이름으로 <filename
>/debian-installer/ia64/elilo.efi</filename
>을 넘기도록 DHCP 서버에 설정하십시오. </para>

   <sect3 arch="mipsel">
   <title
>DECstation TFTP 이미지</title>
<para
>DECstations에서는, 각 서브 아키텍처마다 TFTP 이미지 파일이 있습니다. 각 이미지 파일에는 커널과 설치 프로그램이 한 파일에 들어 있습니다. 그 이름은 <replaceable
>서브아키텍처</replaceable
>/netboot-boot.img 식으로 되어 있습니다. 위에서 설명한 BOOTP/DHCP 설정대로 하시려면, 사용하려는 TFTP 이미지 파일을 <userinput
>/tftpboot/tftpboot.img</userinput
> 파일로 복사하십시오. </para
><para
>DECstation 펌웨어는 TFTP에서 <userinput
>boot <replaceable
>#</replaceable
>/tftp</userinput
> 명령으로 부팅합니다. 여기서 <replaceable
>#</replaceable
>은 부팅하려는 TurboChannel 장치의 번호입니다. 대부분의 DECstation에서 이 번호는 <quote
>3</quote
>입니다. BOOTP/DHCP 서버에서 파일 이름이 넘겨주지 않거나 파라미터를 추가로 더 넘겨야 한다면, 파라미터를 다음 문법에 따라 추가할 수 있습니다: </para
><para>

<userinput
>boot #/tftp/filename 파라미터1=값1 파라미터2=값2 ...</userinput>

</para
><para
>DECstation 펌웨어의 몇몇 버전에서는 네트워크 부팅과 관련해 문제가 나타납니다. 전송이 시작하지만 어느 정도 시간이 지나면 <computeroutput
>a.out err</computeroutput
>라고 나오면서 멈춥니다. 이 현상은 여러가지 이유가 있습니다: <orderedlist
> <listitem
><para
> TFTP 전송중에 펌웨어가 ARP 요청에 응답하지 않습니다. 이렇게 되면 ARP 시간 초과가 발생해 전송이 끝납니다. 해결 방법은 TFTP 서버의 ARP 테이블에 DECstation에 달려 있는 이더넷 카드의 주소를 추가하는 것입니다. <userinput
>arp -s <replaceable
>IP주소</replaceable
> <replaceable
>MAC주소</replaceable
></userinput
> 명령을 TFTP 서버로 사용하는 기계에서 루트로 실행하십시오. DECstation의 MAC 주소는 DECstation의 펌웨어 프롬프트에서 <command
>cnfg</command
> 명령으로 알아 낼 수 있습니다. </para
></listitem
> <listitem
><para
> 펌웨어에 TFTP로 부팅할 수 있는 파일의 크기 제한이 있습니다. </para
></listitem
> </orderedlist
> 아예 TFTP로 부팅할 수 없는 펌웨어 버전도 있습니다. 여러 가지 펌웨어 버전에 대한 개요는 NetBSD 웹 페이지에 있습니다: <ulink url="http://www.netbsd.org/Ports/pmax/board-list.html#proms"
></ulink
> </para>
   </sect3>

   <sect3 arch="alpha">
   <title
>Alpha TFTP 부팅</title>
<para
>Alpha에서는, SRM의 <userinput
>boot</userinput
> 명령에 <userinput
>-file</userinput
> 인자를 사용하거나, <userinput
>BOOT_FILE</userinput
> 환경 변수를 지정해 파일 이름을 지정해야 합니다.  (부팅 이미지 디렉토리의 상대 경로) 아니면 다른 방법으로, BOOP를 통해 파일 이름을 넘겨줄 수 있습니다. (ISC <command
>dhcpd</command
>에서는 <userinput
>filename</userinput
>을 사용합니다) Open Firmware와는 달리, SRM에는 <emphasis
>기본 파일 이름이 없습니다</emphasis
>. 그래서 이러한 방법들 중의 하나를 이용해서 파일 이름을 <emphasis
>지정해야 합니다</emphasis
>. </para>
   </sect3>

   <sect3 arch="sparc">
   <title
>SPARC TFTP 부팅</title>
<para
>예를 들어 sparc 아키텍처에서는 서브 아키텍처 이름을 사용합니다. <quote
>SUN4M</quote
>, <quote
>SUN4C</quote
>과 같이 씁니다. 만약 아키텍처를 비워두면, 클라이언트에서 <filename
>16진수-클라이언트-IP</filename
>를 파일 이름으로 사용합니다. 시스템의 서브 아키텍처가 SUN4C이고 IP가 192.168.1.3이라면, 파일 이름은 <filename
>C0A80103.SUN4C</filename
>입니다. 이름을 알아내기 쉬운 방법은 쉘에서 다음 명령을 실행하는 것입니다: (기계의 IP가 10.0.0.4라고 가정) <informalexample
><screen>
$ printf '%.2x%.2x%.2x%.2x\n' 10 0 0 4
</screen
></informalexample
> 이렇게 하면 IP를 16진수로 표시합니다. 파일 이름은 모든 글자를 대문자로 바꿔야 하고 필요하다면 서브 아키텍처 이름을 뒤에 붙입니다. </para
><para
>일부 sparc 시스템은 OpenPROM 부팅 명령 뒤에 특정 파일이름을 붙여서 이 파일을 찾도록 만들 수 있습니다. 예를 들어 <userinput
>boot net my-sparc.image</userinput
>. 파일은 TFTP 서버가 찾는 디렉토리 안에 들어 있어야 합니다. </para>
   </sect3>

   <sect3 arch="m68k">
   <title
>BVM/Motorola TFTP 부팅</title>
<para
>BVM 및 Motorola VMEbus 시스템에서는 &bvme6000-tftp-files; 파일을 <filename
>/tftpboot/</filename
> 디렉토리에 복사하십시오. </para
><para
>그 다음에, 최초에 <filename
>tftplilo.bvme</filename
> 혹은 <filename
>tftplilo.mvme</filename
> 파일을 TFTP 서버에서 읽어들이도록 부팅 ROM과 BOOTP 서버를 설정하십시오. 해당 시스템 관련 설정에 관한 추가 정보는 해당 서브 아키텍처의 <filename
>tftplilo.txt</filename
> 파일을 참고하십시오. </para>
   </sect3>

   <sect3 arch="mips">
   <title
>SGI Indy TFTP 부팅</title>
<para
>SGI Indy에서는 <command
>bootpd</command
> 명령만을 이용해서 TFTP 파일 이름을 넙깁니다. 파일 이름은 <filename
>/etc/bootptab</filename
> 파일의 <userinput
>bf=</userinput
> 혹은 <filename
>/etc/dhcpd.conf</filename
> 파일의 <userinput
>filename=</userinput
> 옵션으로 지정합니다. </para>
   </sect3>

   <sect3 arch="mips">
   <title
>Broadcom BCM91250A TFTP 부팅</title>
<para
>CFE로 읽어들일 파일의 전체 경로를 넘기기 때문에 DHCP를 특별히 설정할 필요가 없습니다. </para>
   </sect3>

  </sect2>

<!-- FIXME: commented out since it seems too old to be usable and a current
            way is not known

  <sect2 id="tftp-low-memory">
  <title
>TFTP Installation for Low-Memory Systems</title>
<para>

On some systems, the standard installation RAMdisk, combined with the
memory requirements of the TFTP boot image, cannot fit in memory.  In
this case, you can still install using TFTP, you'll just have to go
through the additional step of NFS mounting your root directory over
the network as well.  This type of setup is also appropriate for
diskless or dataless clients.

</para
><para>

First, follow all the steps above in <xref linkend="install-tftp"/>.

<orderedlist>
<listitem
><para>

Copy the Linux kernel image on your TFTP server using the
<userinput
>a.out</userinput
> image for the architecture you are
booting.

</para
></listitem>
<listitem
><para>

Untar the root archive on your NFS server (can be the same system as
your TFTP server):

<informalexample
><screen
>
# cd /tftpboot
# tar xvzf root.tar.gz
</screen
></informalexample>

Be sure to use the GNU <command
>tar</command
> (other tar programs, like the
SunOS one, badly handle devices as plain files).

</para
></listitem>
<listitem
><para>

Export your <filename
>/tftpboot/debian-sparc-root</filename
> directory
with root access to your client.  E.g., add the following line to
<filename
>/etc/exports</filename
> (GNU/Linux syntax, should be similar
for SunOS):

<informalexample
><screen
>
/tftpboot/debian-sparc-root <replaceable>client</replaceable>(rw,no_root_squash)
</screen
></informalexample>

NOTE: <replaceable
>client</replaceable
> is the host name or IP address recognized
by the server for the system you are booting.

</para
></listitem>
<listitem
><para>

Create a symbolic link from your client IP address in dotted notation
to <filename
>debian-sparc-root</filename
> in the
<filename
>/tftpboot</filename
> directory.  For example, if the client
IP address is 192.168.1.3, do

<informalexample
><screen
>
# ln -s debian-sparc-root 192.168.1.3
</screen
></informalexample>

</para
></listitem>
</orderedlist>

</para>

  </sect2>

  <sect2 condition="supports-nfsroot">
  <title
>Installing with TFTP and NFS Root</title>
<para>

Installing with TFTP and NFS Root is similar to
<xref linkend="tftp-low-memory"/> because you don't want to
load the RAMdisk anymore but boot from the newly created NFS-root file
system.  You then need to replace the symlink to the tftpboot image by
a symlink to the kernel image (for example,
<filename
>linux-a.out</filename
>).

</para
><para>

RARP/TFTP requires all daemons to be running on the same server (the
workstation is sending a TFTP request back to the server that replied
to its previous RARP request).

</para>


  </sect2>
END FIXME -->
 </sect1>
<!--   End of file install-methods/install-tftp.xml -->

<!-- Start of file install-methods/automatic-install.xml -->

 <sect1 id="automatic-install">
 <title
>자동 설치</title>
<para
>여러 컴퓨터에 설치하려면 완전 자동 설치를 사용할 수도 있습니다. 이런 목적을 위한 데비안 꾸러미는 <classname
>fai</classname
> (설치 서버 사용), <classname
>replicator</classname
>, <classname
>systemimager</classname
>, <classname
>autoinstall</classname
>이 있고, 데비안 설치 프로그램 자체를 사용할 수도 있습니다. </para>

  <sect2 id="preseed">
  <title
>데비안 설치 프로그램을 이용한 자동 설치</title>
<para
>데비안 설치 프로그램은 미리 설정해 놓은 파일을 이용해 자동 설치를 지원합니다. 미리 설정해 놓은 파일은 네트워크 혹은 이동식 미디어로 읽어들일 수 있습니다. 이 파일 안에는 설치 과정에서 나오는 질문에 대한 대답들이 들어 있습니다. </para
><para condition="etch"
><xref linkend="appendix-preseed"/>에 보면 미리 설정에 대한 문서가 있고, 약간 고쳐서 사용할 수 있는 잘 동작하는 예제가 있습니다. </para
><para condition="sarge"
>&d-i;에서 사용하는 대화 상자는 대부분 이 방법을 이용해 미리 설정되어 있지만, 몇가지 중요한 예외가 있습니다. 전체 디스크 혹은 빈 공간을 (다시) 파티션할 수 있지만, 기존의 파티션을 이용할 수는 없습니다. 현재는 RAID나 LVM 설정을 미리 설정할 수 없습니다. 또 네트워크 드라이버 모듈을 제외하면 커널 모듈 파라미터는 미리 설정할 수 없습니다. </para
><para condition="sarge"
>미리 설정해 놓은 파일은 debconf-set-selections 명령에서 사용하는 형식으로 되어 있습니다. <xref linkend="example-preseed"/>에 보면 잘 설명되어 있고 동작하는 예제 파일이 있습니다. </para
><para condition="sarge"
>그게 아니면, 미리 설정할 수 있는 값들의 모든 목록이 들어 있는 파일을 만드는 한 가지 방법은, 수동으로 설치한 다음 <classname
>debconf-utils</classname
> 꾸러미에 들어 있는 <filename
>debconf-get-selections</filename
>를 사용하는 것입니다. 이 명령은 debconf 데이터베이스와 /var/log/debian-installer/cdebconf 안에 있는 cdebconf 데이터베이스를 한 개 파일로 만듭니다: <informalexample
><screen>
$ debconf-get-selections --installer &gt; <replaceable
>file</replaceable>
$ debconf-get-selections &gt;&gt; <replaceable
>file</replaceable>
</screen
></informalexample
> 하지만, 이렇게 만든 파일에는 미리 설정하면 안 되는 것도 들어 있습니다. <xref linkend="example-preseed"/>에 들어 있는 파일이 대부분의 사용자가 시작하기에 더 나은 방법입니다. </para
><para condition="sarge"
>미리 설정해 놓은 파일이 있으면, 이 파일을 필요에 따라 편집하고, 웹 서버에 넣던지, 설치 프로그램의 부팅 미디어에 복사해 놓을 수도 있습니다. 이 파일을 어디에 놓든 이 파일을 이용하라는 사실을 부팅할 때 파라미터로 넘겨야 합니다. </para
><para condition="sarge"
>설치 프로그램에서 미리 설정해 놓은 파일을 네트워크에서 내려받도록 하려면, preseed/url=http://url/to/preseed.cfg 파라미터를 커널 부팅 파리미터로 넘깁니다. 물론 이 파일은 설치 프로그램에서 네트워크를 설정하고 이 파일을 내려받을 때까지는 효과가 없습니다. 그래서 이런 방법은 설치 프로그램에서 DHCP를 통해 네트워크를 설정할 수 있을 경우에 가장 유용합니다. 설치 우선순위를 "중요"로 해서 네트워크를 설정할 때까지 아무 질문도 하지 않도록 할 수 있습니다. <xref linkend="installer-args"/> 부분을 참고하십시오. </para
><para condition="sarge"
>CD에 미리 설정해 놓은 파일을 넣으려면, 미리 설정해 놓은 파일을 포함하도록 ISO 이미지를 다시 만들어야 할 것입니다. 자세한 방법은 mkisofs 매뉴얼 페이지를 참고하십시오. 다른 방법으로는, 미리 설정해 놓은 파일을 플로피에 넣고, preseed/file=/floppy/preseed.cfg 파라미터를 사용하는 것입니다. </para
><para arch="i386" condition="sarge"
>USB 메모리 스틱에서 부팅한다면, 미리 설정해 놓은 파일을 메모리 스틱의 파일 시스템에 복사해 놓기만 하면 됩니다. 그 다음에 syslinux.cfg 파일을 편집해서 커널 부팅 파라미터에 preseed/file=/hd-media/preseed.cfg 파라미터를 넣으십시오. </para>
  </sect2>
 </sect1>
<!--   End of file install-methods/automatic-install.xml -->

</chapter>
<!--   End of file install-methods/install-methods.xml -->
