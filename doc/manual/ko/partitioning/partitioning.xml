<!-- Start of file partitioning/partitioning.xml -->

<appendix id="partitioning">
<title
>데비안의 하드디스크 파티션</title>


<!-- Start of file partitioning/sizing.xml -->


 <sect1 id="partition-sizing">
 <title
>파티션을 나눌 때 파티션의 크기 등 고려할 점</title>
<para
>GNU/Linux는 전용으로 쓸 수 있는 파티션을 최소한 하나 필요로 합니다. 각종 응용프로그램과 사용자 파일, 데비안 전체를 하나의 파티션에 둘 수 있습니다. 스왑 파티션도 반드시 필요하다고 하는 사람이 많지만, 꼭 그런 것만은 아닙니다. <quote
>스왑</quote
>이란 운영체제가 사용할 수 있는 일종의 낙서공간으로, 디스크를 <quote
>가상메모리</quote
>처럼 사용할 수 있게 해줍니다. 스왑을 별도의 파티션에 두면, 리눅스가 스왑을 더 효율적으로 사용할 수 있게 됩니다. 일반적인 파일을 스왑으로 사용하도록 강제할 수 있지만 별로 추천하는 방식은 아닙니다.  </para
><para
>하지만 대부분의 사람들은 GNU/Linux에게 여러 개의 파티션을 할당합니다. 파일시스템을 몇 개의 작은 파티션으로 나누는게 좋은 이유로 두가지를 들 수 있습니다. 첫번째는 안전문제입니다. 파일시스템이 망가지게 될 경우, 대부분 파티션 하나에만 문제가 생깁니다. 즉 그 동안 잘 백업해 둔 정보를 토대로 시스템의 일부만을 복구하면 됩니다. 이런 이유로 <quote
>root</quote
>파티션을 따로 두는 것이 좋습니다. 여기에 시스템의 가장 핵심적인 파일들이 있기 때문입니다. 그러면 다른 파티션들에 문제가 생기더라도 이 파티션에 오류가 없다면 부팅을 해서 문제점을 고칠 수 있습니다. 시스템을 처음부터 완전히 설치하는 것에 비해 수고를 덜 수 있습니다.  </para
><para
>두번째 이유는 기업환경에서 더 중요하다고 할 수 있습니다만, 각자의 상황에 따라 다르다고 보는 것이 맞을 듯 합니다. 예를 들어, 대량의 스팸메일을 받고 있는 메일서버는 금방 파티션 하나를 채울 수 있습니다. <filename
>/var/mail</filename
>을 별도의 파티션에 두었다면, 스팸메일로 하드디스크가 가득차서 시스템이 동작을 멈추는 현상을 어느 정도 예방할 수 있을 것입니다.  </para
><para
>여러개의 파티션을 사용할 때의 유일한 단점은 각 파티션의 적절한 크기를 사전에 알기 힘들다는 점에 있습니다. 파티션을 너무 작게 만들면 시스템을 새로 설치하거나 그 파티션에 있는 파일들을 자주 다른 파티션으로 옮겨줘야 하는 불편함이 있습니다. 반면에 파티션을 너무 크게 만들면 다른 곳에서 쓸 수 있는 공간을 낭비하는 셈이 됩니다. 디스크 공간이 많이 저렴해졌다 하지만 낭비할 수는 없지 않습니까?  </para>
 </sect1>
<!--   End of file partitioning/sizing.xml -->

<!-- Start of file partitioning/tree.xml -->


 <sect1 id="directory-tree">
 <title
>디렉토리 구조</title>
<para
>&debian; 은 디렉토리와 파일명을 정할 때 <ulink url="&url-fhs-home;"
>표준 파일 시스템 구조Filesystem Hierarchy Stan</ulink
>를 따르고 있습니다. 이 표준을 준수함으로써 사용자들과 유저 프로그램들은 처음 접하는 시스템이라도 원하는 파일과 디렉토리의 위치를 예측할 수 있게 됩니다. 루트 디렉토리는 슬래쉬<filename
>/</filename
>로 표시됩니다. 데비안은 루트 디렉토리 아래에 다음의 디렉토리들을 포함하고 있습니다:  <informaltable
> <tgroup cols="2">
<thead>
<row>
  <entry
>디렉토리</entry
><entry
>내용</entry>
</row>
</thead>

<tbody>
<row>
  <entry
><filename
>bin</filename
></entry>
  <entry
>필수적인 명령 바이너리들</entry>
</row
><row>
  <entry
><filename
>boot</filename
></entry>
  <entry
>부트 로더가 필요로 하는 정적 파일들</entry>
</row
><row>
  <entry
><filename
>dev</filename
></entry>
  <entry
>하드웨어의 다바이스 파일들</entry>
</row
><row>
  <entry
><filename
>etc</filename
></entry>
  <entry
>이 호스트 고유의 설정파일 등</entry>
</row
><row>
  <entry
><filename
>home</filename
></entry>
  <entry
>사용자의 홈디렉토리</entry>
</row
><row>
  <entry
><filename
>lib</filename
></entry>
  <entry
>시스템 운영에 필수적인 공유 라이브러리와 커널 모듈들</entry>
</row
><row>
  <entry
><filename
>media</filename
></entry>
  <entry
>플로피 디스켓 등의 탈부착 가능한 매체를 마운트 시키는 디렉토리</entry>
</row
><row>
  <entry
><filename
>mnt</filename
></entry>
  <entry
>파일 시스템을 임시로 마운트 시키는 디렉토리</entry>
</row
><row>
  <entry
><filename
>proc</filename
></entry>
  <entry
>커널 2.4와 2.6에서 시스템 정보를 저장하는 가상 디렉토리</entry>
</row
><row>
  <entry
><filename
>root</filename
></entry>
  <entry
>root 사용자의 홈디렉토리</entry>
</row
><row>
  <entry
><filename
>sbin</filename
></entry>
  <entry
>필수적인 시스템 관리 바이너리</entry>
</row
><row>
  <entry
><filename
>sys</filename
></entry>
  <entry
>2.6 커널이 시스템 정보를 저장하는 가상 디렉토리</entry>
</row
><row>
  <entry
><filename
>tmp</filename
></entry>
  <entry
>임시 파일들</entry>
</row
><row>
  <entry
><filename
>usr</filename
></entry>
  <entry
>2차적인 디렉토리 구조</entry>
</row
><row>
  <entry
><filename
>var</filename
></entry>
  <entry
>내용이 자주 변하는 파일들</entry>
</row
><row>
  <entry
><filename
>opt</filename
></entry>
  <entry
>별도로 추가하는 응용 소프트웨어</entry>
</row>
</tbody
></tgroup
></informaltable>
</para>

<para
>디렉토리와 하드디스크 파티션을 구성할 때 고려해야 할 점들을 아래에 정리했습니다. 실제 디스크 사용량은 각 시스템의 설정과 주 사용용도에 따라 달라질 수 있습니다. 아래의 내용은 참고만 하시고 실제 설정에는 각 시스템에 맞게 하실 것을 권합니다.  </para>
<itemizedlist>
<listitem
><para
><filename
>/etc</filename
>, <filename
>/bin</filename
>, <filename
>/sbin</filename
>, <filename
>/lib</filename
>, <filename
>/dev</filename
>는 반드시 루트 파티션(<filename
>/</filename
>)에 존재해야 합니다. 그렇지 않을 경우 부팅에 문제가 발생합니다. 일반적으로 150&ndash;250 MB정도가 필요합니다.  </para
></listitem>
<listitem
><para
><filename
>/usr</filename
>에는 유저 프로그램(<filename
>/usr/bin</filename
>)과 라이브러리(<filename
>/usr/lib</filename
>)와 시스템 문서(<filename
>/usr/share/doc</filename
>) 등이 저장됩니다. 많은 경우 이 부분이 가장 하드디스크 공간을 많이 차지할 것입니다. 최소한 500 MB를 할당하시고 시스템에 설치할 패키지의 구성과 수에 따라 적절히 조절하십시오. 워크스테이션이나 서버로 사용될 시스템은 넉넉잡아 4 - 6 GB 정도를 필요로 할 것입니다.  </para
></listitem>
<listitem
><para
><filename
>/var</filename
>에는 뉴스그룹글이나 이메일, 웹페이지, 데이터베이스나 패키지 관리 프로그램의 캐시 등 자주 변하는 정보가 주로 저장됩니다. 이 디렉토리의 크기는 시스템에 따라 크게 차이가 나지만, 일반적인 사용자들의 시스템에서는 패키지 관리 프로그램이 이 공간이 대부분을 사용할 것입니다. 데비안에 포함된 프로그램을 한번에 거의 다 설치하실 경우 <filename
>/var</filename
>에 2 ~ 3 GB정도를 할당하시면 됩니다. 한번에 설치하지 않고 서비스와 유틸리티 따로, 문서 작업용 프로그램 따로, X 윈도우 따로하는 식으로 나눠서 설치하실 경우 300에서 500 MB로도 가능합니다. 하드디스크 크기가 부족하고 시스템의 대대적인 업데이트 예정이 없을 경우 이 파티션을 30이나 40 MB정도로 작게 하실 수도 있습니다.  </para
></listitem>
<listitem
><para
>프로그램들이 사용하는 임시 데이터는 <filename
>/tmp</filename
>에 주로 저장됩니다. 대부분 40&ndash;100 MB 정도면 충분하지만, 압축 유틸리티나 CD/DVD 굽는 유틸리티나 각종 멀티미디어 프로그램들은 이미지 파일을 <filename
>/tmp</filename
>에 임시로 저장하는 경우도 있으므로 이 경우에는 <filename
>/tmp</filename
>의 크기를 적절히 조절하십시오.  </para
></listitem>
<listitem
><para
><filename
>/home</filename
>에는 사용자들의 홈디렉토리가 저장됩니다. 사용자들은 홈디렉토리에 개인 파일들을 저장할텐데, 이 시스템을 사용하는 사용자가 몇 명이며 각자가 자신의 홈디렉토리 어떤 종류의 파일을 저장할지에 따라 필요한 <filename
>/home</filename
>디렉토리의 크기가 달라지게 됩니다. 100 MB정도씩을 할당하면 되지만, 홈디렉토리 안에 MP3나 동영상 등 대용량 파일을 많이 저장할 예정이라면 공간을 충분히 늘려 잡으십시오.  </para
></listitem>
</itemizedlist>

 </sect1>
<!--   End of file partitioning/tree.xml -->

<!-- Start of file partitioning/schemes.xml -->


 <sect1>
 <title
>권장하는 파티션 구조</title>
<para
>초보자이시거나 개인이나 가정에서 사용할 시스템일 경우에는 <filename
>/</filename
>에 스왑 파티션만을 사용하는 것이 가장 쉽고 편한 방식일 것입니다. 하드디스크의 크기가 6 GB이상 될 경우엔 파일시스템을 ext3방식으로 포맷하십시오. Ext2 방식을 사용할 경우 주기적으로 파일시스템을 검사해야 하는데, 하드디스크의 크기가 너무 클 경우 부팅시간이 너무 오래걸리는 단점이 있습니다.  </para
><para
>멀티유저 시스템이거나 하드디스크의 용량이 큰 시스템에서는 <filename
>/usr</filename
>, <filename
>/var</filename
>, <filename
>/tmp</filename
>, <filename
>/home</filename
> 각각을 별도의 파티션에 두어 <filename
>/</filename
>파티션과 별도로 두는 것이 좋습니다.  </para
><para
>데비안에서 제공하지 않는 프로그램을 많이 설치할 경우 <filename
>/usr/local</filename
>를 별도의 파티션에 두는 것이 좋을 수도 있습니다. 메일서버일 경우에는 <filename
>/var/mail</filename
>를 별도의 파티션에 두는 것이 좋으며, <filename
>/tmp</filename
> 역시 20 내지 50 MB 정도되는 별도의 파티션에 두는 것이 좋습니다. 사용자가 많은 멀티유저 서버일 경우 <filename
>/home</filename
>의 크기를 충분히 잡아서 별도의 파티션에서 관리하는 것이 좋습니다. 이처럼 파일시스템 파티션의 구성은 시스템마다 달라지므로 각자의 필요에 따라 적절히 결정하시면 됩니다.  </para
><para
>매우 복잡한 시스템을 구성하신다면 <ulink url="&url-multidisk-howto;"
> 멀티디스크 HOWTO</ulink
>를 참고하십시오. 하드디스크 파티션하기에 관한 심도있는 내용을 다루고 있으므로 ISP나 서버관리자들에게 주로 도움이 될 것입니다.  </para
><para
>스왑의 크기는 사람마다 생각이 다릅니다. 일단 시스템의 메모리만큼 스왑공간을 잡는 것이 좋습니다. 또한 16 MB보다는 큰 것이 좋습니다. 256 MB 메모리를 갖고 있는 컴퓨터에서 동시에 10000개의 공식을 풀 생각이시라면 1기가 이상 필요로 할 수도 있으므로 각자의 필요에 따라 스왑공간의 크기를 조절하시면 됩니다.  </para
><para arch="m68k"
>참고로 Atari Falcon과 매킨토시는 가상메모리를 사용할 때마다 성능이 크게 저하되므로 이들 컴퓨터에서는 스왑공간을 크게하기보다 램을 더 구하는 것이 더 효과적입니다.  </para
><para
>i386, m68k, SPARC 32비트와 PowerPC등의 32비트 프로세서는 2GB가 스왑 파티션의 한계입니다. 대부분의 경우 이 정도로도 충분합니다. 하지만 스왑 공간이 정말 많이 필요하다면 스왑을 여러 하드디스크에 걸쳐서 잡으시고(이 방식을 <quote
>spindles</quote
>방식이라고 부릅니다), 가급적이면 서로 다른 SCSI, IDE 채널의 하드디스크에 잡으십시오. 커널이 알아서 여러 스왑 파티션에 적절히 작업을 분배하므로 시스템의 성능향상에 도움이 됩니다.  </para
><para
>예를 하나 들어보겠습니다. 좀 오래된 컴퓨터에 램이 32 MB 있고 <filename
>/dev/hda</filename
>에 1.7 GB짜리 IDE 하드디스크가 있습니다. 500MB짜리 <filename
>/dev/hda1</filename
>에 다른 운영체제가 설치되어 있으며, <filename
>/dev/hda3</filename
>는 32MB의 스왑공간으로 사용되고 있습니다. <filename
>/dev/hda2</filename
>에는 1.2GB이 할당되어 있어 리눅스가 사용할 예정입니다.  </para
><para
>필요할 하드디스크 용량이 얼마나 될지 감을 잡는데 도움이 되고자 <xref linkend="tasksel-size-list"/>에 작업별로 필요로 하는 하드디스크 공간이 정리되어 있습니다.  </para>

 </sect1>
<!--   End of file partitioning/schemes.xml -->

<!-- Start of file partitioning/device-names.xml -->


 <sect1 id="device-names">
 <title
>리눅스에서의 디바이스 이름</title>
<para
>리눅스에서 디스크와 파티션을 다른 시스템과 다른 이름으로 부르기도 합니다. 리눅스에서 파티션을 생성하고 마운트할 때 이 이름들을 알고 있어야 합니다. 기본적으로는 다음 규칙에 따라 이름이 정해집니다.  </para>
<itemizedlist arch="not-s390">
<listitem
><para
>첫번째 플로피 디스크 드라이브는 <filename
>/dev/fd0</filename
>라고 불립니다.  </para
></listitem>
<listitem
><para
>두번째 플로피 디스크 드라이브는 <filename
>/dev/fd1</filename
>라고 불립니다.  </para
></listitem>
<listitem
><para
>SCSI ID 주소에서 제일 먼저 오는 SCSI 디스크는 <filename
>/dev/sda</filename
>라고 불립니다.  </para
></listitem>
<listitem
><para
>두번째로 오는 디스크는 <filename
>/dev/sdb</filename
>라고 불리며, 각 디스크마다 이런 방식으로 이름이 붙습니다.  </para
></listitem>
<listitem
><para
>첫번째 SCSI CD-ROM은 <filename
>/dev/scd0</filename
>이라고 불리며, <filename
>/dev/sr0</filename
>라고도 불립니다.  </para
></listitem>
<listitem
><para
>IDE 주컨트롤러의 마스터는 <filename
>/dev/hda</filename
>라고 불립니다.  </para
></listitem>
<listitem
><para
>IDE 주컨트롤러의 슬레이브는 <filename
>/dev/hdb</filename
>라고 불립니다.  </para
></listitem>
<listitem
><para
>IDE 부컨트롤러의 마스터와 슬레이브는 각각 <filename
>/dev/hdc</filename
>, <filename
>/dev/hdd</filename
>라고 불릴 수 있습니다. 최근에 나온 IDE 컨트롤러는 2개의 통신채널을 갖고 있기 때문에 실질적으로는 2개의 컨트롤러 로 취급될 수 있습니다. <phrase arch="m68k"
> Pdisk라는 매킨토시 프로그램과는 이름이 달라질 수 있습니다. 예를 들면 pdisk 상에서 <filename
>/dev/hdc</filename
>인 하드디스크가 데비안에서는 <filename
>/dev/hda</filename
>으로 표시될 수 있습니다. </phrase
> </para
></listitem>

<listitem arch="i386"
><para
>첫번째 XT 디스크는 <filename
>/dev/xda</filename
>입니다.  </para
></listitem>
<listitem arch="i386"
><para
>두번째 XT 디스크는 <filename
>/dev/xdb</filename
>입니다. </para
></listitem>
<listitem arch="m68k"
><para
>첫번째 ACSI 디바이스의 이름은 <filename
>/dev/ada</filename
>이고, 두번째는 <filename
>/dev/bdb</filename
>입니다.  </para
></listitem>
</itemizedlist>

<itemizedlist arch="s390">
<listitem
><para
>첫번째 DASD 디바이스의 이름은 <filename
>/dev/dasda</filename
>입니다.  </para
></listitem>
<listitem
><para
>두번째 DASD디바이스는 <filename
>/dev/dasdb</filename
>이고 추가로 연결되는 DASD디바이스 역시 이런 규칙을 따르게 됩니다.  </para
></listitem>
</itemizedlist>

<para arch="not-s390"
>각 드라이브 상의 파티션은 디스크 이름 뒤에 숫자를 붙인 이름을 갖게 됩니다. <filename
>sda1</filename
>와 <filename
>sda2</filename
>는 각각 첫번째 SCSI 디스크의 첫번째와 두번째 파티션을 뜻합니다.  </para
><para arch="not-s390"
>예를 하나 들어보도록 하겠습니다. 컴퓨터에 2개의 SCSI 디스크가 있고, 각각 SCSI 주소 2와 4에 연결되어 있다고 합시다. 2번 주소에 연결된 디스크가 첫번째 SCSI로, <filename
>sda</filename
>라고 불리게 됩니다. 두번째 4번 주소의 SCSI 디스크는 <filename
>sdb</filename
>와 연결되게 됩니다. <filename
>sda</filename
>에 파티션이 3개가 있다면 각각 <filename
>sda1</filename
>, <filename
>sda2</filename
>, <filename
>sda3</filename
>라고 불리게 됩니다. <filename
>sdb</filename
>와 파티션들 역시 같은 규칙을 적용받게 됩니다. </para
><para arch="not-s390"
>참고로, SCSI 호스트 버스 어댑터(컨트롤러)가 있을 경우 어느 드라이브가 첫번째인지 확인하기 어려울 수 있습니다. 이 경우엔 부팅시 화면에 표시되는 드라이브 모델과 기능을 살펴보고 어느 드라이브가 <filename
>sda</filename
>에 연결되었는지 확인하는게 최선의 방법입니다.  </para
><para arch="i386"
>리눅스 파티션은 드라이브 이름 뒤에 숫자 1에서 4를 붙여서 주파티션을 구분합니다. 예를 들어, 첫번째 IDE드라이브의 첫번째 파티션은 <filename
>/dev/hda1</filename
>입니다. 논리파티션은 5번부터 시작하므로, 이 드라이브의 첫번째 논리파티션은 <filename
>/dev/hda5</filename
>입니다. 논리파티션이 들어있는 확장파티션은 독자적으로 쓸 수 없습니다. 이는 SCSI 디스크, IDE디스크 모두에 적용되는 사실입니다.  </para
><para arch="m68k"
>VMEbus 시스템에서 TEAC FC-1 SCSI 플로피 드라이브는 일반적인 SCSI 디스크로 인식될 것입니다. 설치 프로그램은 이 디스크 드라이브를 알아보기 쉽게 하기 위하여 적절한 디바이스와 연결되는 심볼릭 링크<filename
>/dev/sfd0</filename
>를 만들 것입니다.  </para
><para arch="sparc"
>Sun 디스크 파티션은 8개의 분리된 파티션(또는 슬라이스)를 지원합니다만 대부분 세번째 파티션에 <quote
>디스크 전부</quote
>를 할당합니다. 이 파티션은 디스크의 모든 섹터를 포괄하며, SILO나 Sun의 부트로더에서 사용됩니다.  </para
><para arch="s390"
>각 디스크의 파티션은 디스크 이름에 십진수 숫자를 붙여서 나타냅니다. 예를 들어 <filename
>dasda1</filename
> 와 <filename
>dasda2</filename
>는 각각 시스템에 설치된 첫번째와 두번째 DASD 디바이스를 가리킵니다.  </para>
 </sect1>
<!--   End of file partitioning/device-names.xml -->

<!-- Start of file partitioning/partition-programs.xml -->

 <sect1 id="partition-programs">
 <title
>데비안의 파티션용 프로그램</title>
<para
>여러가지 하드디스크와 시스템 종류에 맞게 데비안의 개발자들이 여러 종류의 파티션 프로그램을 개발했습니다. 아래에 시스템에 따른 파티션 프로그램의 목록을 열거하였습니다.  </para>

<variablelist>

<varlistentry>
<term
><command
>partman</command
></term>
<listitem
><para
>데비안에서 권장하는 파티션용 프로그램. 이 만능 프로그램으로 파티션의 크기를 조정하며, 파일시스템을 생성하고 <phrase arch="i386"
> (윈도우에서 말하는 <quote
>포맷</quote
>)</phrase
>, 마운트 위치도 설정할 수 있습니다.  </para
></listitem>
</varlistentry>

<varlistentry condition="fdisk.txt">
<term
><command
>fdisk</command
></term>
<listitem
><para
>전통적인 리눅스 파티션 프로그램으로, 전문가용. </para
><para
>FreeBSD용 파티션이 디스크에 있을 경우엔 신중하셔야 합니다. 설치용 커널은 이 형식의 파티션들을 지원합니다만, <command
>fdisk</command
> 프로그램이 이들 파티션을 화면에 나타내는 방식이 달라질 수 있습니다. <ulink url="&url-linux-freebsd;"
>리눅스+FreeBSD HOWTO</ulink
>를 참조하시면 보다 자세한 내용을 얻어실 수 있습니다.  </para
></listitem>
</varlistentry>

<varlistentry condition="cfdisk.txt">
<term
><command
>cfdisk</command
></term>
<listitem
><para
>대부분의 사람들을 위한 풀스크린 파티션 프로그램.  </para
><para
>참고로 <command
>cfdisk</command
>는 FreeBSD파티션을 전혀 인식하지 못하기 때문에 디바이스의 이름이 예상과 달라질 수 있습니다.  </para
></listitem>
</varlistentry>

<varlistentry condition="atari-fdisk.txt">
<term
><command
>atari-fdisk</command
></term>
<listitem
><para
>Atari용 <command
>fdisk</command
>입니다.  </para
></listitem>
</varlistentry>

<varlistentry condition="amiga-fdisk.txt">
<term
><command
>amiga-fdisk</command
></term>
<listitem
><para
>Amiga용 <command
>fdisk</command
>입니다.  </para
></listitem>
</varlistentry>

<varlistentry condition="mac-fdisk.txt">
<term
><command
>mac-fdisk</command
></term>
<listitem
><para
>매킨토시용 <command
>fdisk</command
>입니다.  </para
></listitem>
</varlistentry>

<varlistentry condition="pmac-fdisk.txt">
<term
><command
>pmac-fdisk</command
></term>
<listitem
><para
>PowerMac용 <command
>fdisk</command
>로, BVM과 모토롤라 VMEbus 시스템에서도 사용하실 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry condition="fdasd.txt">
<term
><command
>fdasd</command
></term>
<listitem
><para
><command
>Fdisk</command
>명령어의 &arch-title; 버전; 자세한 내용을 위해서는 fdasd 매뉴얼 페이지나 <ulink url="http://oss.software.ibm.com/developerworks/opensource/linux390/docu/l390dd08.pdf"
>디바이스 드라이버와 설치 명령어</ulink
>를 참조하십시오.  </para
></listitem>
</varlistentry>
</variablelist>

<para
><guimenuitem
>Partition a Hard Disk</guimenuitem
>를 선택할 때 이 프로그램들 중 하나가 실행되게 됩니다. 디폴트로 실행되는 프로그램을 바꾸고자 할 경우 파티션 프로그램을 끝낸 후 <keycap
>Alt</keycap
>와 <keycap
>F2</keycap
>를 동시에 눌러서 쉘 프롬프트(<userinput
>tty2</userinput
>)로 가십시오. 그 다음 원하시는 프로그램을 인자와 함께 수동으로 실행시키십시오. 파티션이 끝났으면 다시 <command
>debian-installer</command
>로 돌아가서 <guimenuitem
>Partition a Hard Disk</guimenuitem
> 부분을 생략하시면 됩니다.  </para
><para
>동시에 20개 이상의 IDE 파티션을 사용하실 경우 파티션 21 이상은 따로 디바이스를 생성해야 합니다. 그렇지 않을 경우 파티션을 초기화하는 작업이 실패하게 됩니다. 아래에 <userinput
>tty2</userinput
> 명령어나 쉘을 띄우기를 통해 21번째 파티션의 디바이스를 생성시키는 과정을 보여드립니다: <informalexample
><screen>
# cd /dev
# mknod hda21 b 3 21
# chgrp disk hda21
# chmod 660 hda21
</screen
></informalexample
> 적절한 디바이스가 생성되어 있지 않을 경우 새로 설치한 리눅스는 부팅이 되지 않을 것입니다. 커널과 모듈을 모두 설치하신 후 다음을 실행하십시오: <informalexample
><screen>
# cd /target/dev
# mknod hda21 b 3 21 
# chgrp disk hda21
# chmod 660 hda21
</screen
></informalexample
> <phrase arch="i386"
>부트 파티션을 <quote
>Bootable</quote
>로 설정하는 것을 잊지 마십시오.</phrase
> </para
><para condition="mac-fdisk.txt"
>매킨토시용 디스크를 파티션할 때 주의할 점은 스왑파티션이 <quote
>swap</quote
>이라는 이름으로 구별된다는 점입니다. 매킨토시용 리눅스 파티션은 모두 같은 Apple_UNIX_SRV2입니다. 자세한 내용은 매뉴얼을 참조하시고, MacOS와 디스크를 공유할 때 수행해야할 절차를 설명한 <ulink url="&url-mac-fdisk-tutorial;"
>mac-fdisk Tutorial</ulink
>도 읽을 것을 권해드립니다.  </para>


<!-- Start of file partitioning/partition/alpha.xml -->


  <sect2 arch="alpha"
><title
>&arch-title;에서 파티션하기</title>
<para
>SRM 콘솔에서 데비안을 부팅할 경우 (&releasename;에서 유일하게 지원하는 방식이기도 합니다) 부팅 디스크에 DOS 파티션 테이블이 아닌 BSD 디스크 라벨이 필요합니다. (SRM 부트 블록은 MS-DOS 파티션 테이블과 호환되지 않습니다. 자세한 내용은 <xref linkend="alpha-firmware"/>를 참조하십시오) 따라서 <command
>partman</command
> 명령어는 &architecture;상에서는 BSD 디스크 라벨을 생성해줍니다만, 디스크에 DOS 파티션 테이블이 이미 존재하는 경우엔 partman 명령어가 디스크 라벨을 생성하기 전에 기존의 파티션들을 지워야 합니다.  </para
><para
><command
>fdisk</command
> 명령어로 디스크를 파티션하고자 할 때, BSD 디스크 라벨이 아직 생성되지 않은 디스크를 파티션하고자 할 경우 <quote
>b</quote
> 명령어로 디스크 라벨 모드로 들어가서 라벨을 생성시켜야 합니다.  </para
><para
>Tru64 Unix나 FreeBSD, OpenBSD, NetBSD등 4.4BSD-Lite에 기반을 둔 운영체제와 디스크를 공유하고자 할 경우가 아니면 세번째 파티션에 디스크 전체를 넣지 않는 것을 권해드립니다. <command
>aboot</command
> 명령어는 이러한 설정을 필요도 하지 않을 뿐더러, <command
>aboot</command
>를 부트섹터에 설치하는 <command
>swriteboot</command
>에 혼란을 주어 파티션이 부트블록과 겹친다는 에러메시지를 출력시키게 합니다.  </para
><para
>그리고 <command
>aboot</command
>는 디스크의 가장 앞쪽의 150 섹터(70 kB)를 차지하고 있기 때문에, 디스크 앞쪽에 이를 위한 여유공간을 충분히 두셔야만 합니다. 이전에는 디스크 시작 부분에 포맷 안된 빈 공간을 일부 둘 것을 권해드렸었지만, 이제는 GNU/Linux에서만 사용되는 디스크의 경우 권하지 않습니다. 하지만 사용자 편의를 위하여 <command
>partman</command
>명령어는 여전히 이 빈공간을 둡니다.  </para
><para condition="FIXME"
>ARC에 설치하실 경우에는 디스크 맨 앞에 <command
>MILO</command
>와 <command
>linload.exe</command
> 명령어를 위한 5 MB 정도의 작은 FAT형 파티션을 만드는 것이 좋습니다. 자세한 내용은 xref linkend="non-debian-partitioning"/>을 참조하시면 됩니다. 아쉽게도 메뉴에서 FAT형 파티션을 만드는 기능은 지원되지 않기 때문에 쉘에서 직접 만드셔야 합니다. 쉘에서 <command
>mkdosfs</command
> 명령을 사용하여 직접 FAT형 파티션을 만드신 후에 부트로더를 설치하셔야 합니다.  </para>
  </sect2>
<!--   End of file partitioning/partition/alpha.xml -->

<!-- Start of file partitioning/partition/hppa.xml -->


  <sect2 arch="hppa"
><title
>&arch-title;에서 파티션하기</title>
<para
>HPPA용 부트로더인 PALO에는 앞 2 GB 영역 내에 <quote
>F0</quote
>형 파티션을 둬야 합니다. 이 부분에 부트로더와 커널, 그리고 램디스크가 저장되므로, 최소 4 MB(약 8 &ndash; 16 MB )정도로 할당해야 합니다. 펌웨어의 추가 요구사항으로 리눅스 커널도 이 2 GB 영역 내에 있을 것을 요구합니다. 루트 파티션인 ext2형 파티션이 이 영역 내에 완전히 들어가도록 디스크를 파티션하면 됩니다. 또 디스크 앞부분에 작은 ext2형 파티션을 만든 후 이 파티션이 <filename
>/boot</filename
>에 마운트 되도록 하는 방법도 있습니다. 리눅스 커널은 이 디렉토리에 저장되기 때문입니다. 리눅스 커널과 기타 커널이 들어가야할 공간이므로 약 8 &ndash; 16 MB 정도 할당해두시면 됩니다.  </para>
  </sect2>
<!--   End of file partitioning/partition/hppa.xml -->

<!-- Start of file partitioning/partition/i386.xml -->


  <sect2 arch="i386"
><title
>&arch-title;에서 파티션하기</title>
<para
>DOS나 윈도우 등 다른 운영체제와 데비안이 공존하기를 원하신다면 원 운영체제가 사용하는 파티션의 크기를 조정해야 할 수도 있습니다. 설치프로그램을 통하여 FAT와 NTFS형 파티션의 크기를 조정하실 수 있습니다. 설치 프로그램의 파티션하기 단계에서 수동 파티션을 선택한 다음 이미 존재하는 파티션의 크기를 조정하시면 됩니다.  </para
><para
>PC의 BIOS도 디스크를 파티션하는데 각종 제약을 둡니다. 일단 하나의 드라이브에 둘 수 있는 <quote
>주파티션</quote
>과 <quote
>논리파티션</quote
>의 개수에 한계가 있습니다. 또한 1994&dash;98년 이전의 BIOS에는 부팅이 가능한 파티션의 위치에도 제약이 있습니다. 자세한 내용은 <ulink url="&url-partition-howto;"
>리눅스 파티션하기 HOWTO</ulink
> 와 <ulink url="&url-phoenix-bios-faq-large-disk;"
>Phoenix BIOS FAQ</ulink
>를 참조하시면 됩니다만, 이 단원에서 기초적인 내용은 배우실 수 있습니다.  </para
><para
><quote
>주파티션</quote
>은 PC용 디스크에서 전통적으로 사용하던 파티션 방식입니다만, 이 방식으로는 파티션을 4개만 둘 수 있습니다. 이 한계를 벗어나기 위해 <quote
>확장파티션</quote
>과 <quote
>논리파티션</quote
>이라는 개념이 만들어졌습니다. <quote
>주파티션</quote
> 하나를 <quote
>확장파티션</quote
>으로 두면 그 파티션의 공간을 최대 60개의 논리파티션으로 나눌 수 있습니다. 하지만 하나의 디스크에는 <quote
>확장파티션</quote
>을 하나만 둘 수 있습니다.  </para
><para
>리눅스는 파티션의 개수를 SCSI 디스크는 파티션 15개(주파티션 3개, 논리파티션 12개), IDE 디스크에는 63개(주파티션 3개, 논리파티션 60개)로 제한하고 있습니다. 하지만 일반적인 &debian; 시스템은 기본으로 파티션용 디바이스를 20개만 제공하므로 20개보다 많은 파티션을 두고자 할 경우에는 직접 파티션용 디바이스를 추가하셔야 합니다.  </para
><para
>대용량 IDE 디스크를 사용하고, LBA 어드레싱이나 일부 하드디스크 제조사에서 제공하는 오버레이 드라이버를 사용하지 않을 경우 커널을 포함하고 있는 부트파티션의 위치에도 제약이 있습니다. 부트파티션은 맨앞 1024 실린더, BIOS의 주소변환 없이는 맨앞 524 MB에 둬야 합니다.  </para
><para
>이 제약은 제조사에 따라 1995&ndash;98년도 이후에 만들어진 BIOS에는 적용되지 않습니다. 이들 BIOS는 <quote
>향상된 디스크 드라이브 지원을 위한 스펙</quote
>에 맞추어서 제조되었습니다. 리눅스 로더인 LILO와 데비안 고유의 <command
>mbr</command
> 모두 디스크에서 램으로 커널을 읽어들일 때 BIOS의 지원을 필요로 합니다. BIOS가 대용량 디스크 접근용 확장 명령어인 int 0x13을 지원하지 않으면 구형의 디스크 접근 인터페이스가 사용될 것입니다. 이 접근 인터페이스는 1023번째 실린더 이후의 실린더에 접근하지 못합니다. 일단 리눅스가 부팅된다면 디스크 접근에 BIOS가 사용되지 않으므로 이런 제약이 없어집니다.  </para
><para
>시스템에 대용량 디스크가 있을 경우 실린더 변환 기술이 필요한 경우가 있습니다. 이 때는 BIOS 설정으로 들어가셔서 LBA (Logical Block Addressing)나 CHS 변환 모드(<quote
>대용량</quote
>)을 선택하시면 됩니다. 대용량 디스크를 사용할 때의 문제점에 대해서 자세히 알고 싶으시면 <ulink url="&url-large-disk-howto;"
>Large Disk HOWTO</ulink
>를 참조하십시오. 실린더 변환 기술을 사용하지만 BIOS에서 대용량 디스크 접근을 지원하지 않으면 부팅용 파티션이 <emphasis
>변환 후</emphasis
>의 앞 1024번째 실린더 내에 할당되어야 합니다.  </para
><para
>이 경우 디스크의 맨 앞에 5 &ndash; 10 MB의 작은 파티션을 둬서 부팅 파티션으로 사용하고 나머지 영역을 원하는 대로 파티션하시면 됩니다. 이 부팅 파티션은 리눅스 커널들이 저장될 <emphasis
>반드시</emphasis
> <filename
>/boot</filename
>에 마운트 되어야 합니다. 이 방법은 시스템이 LBA를 사용하든 대용량 디스크용 CHS 변환을 사용하든, BIOS에서 대용량 디스크 접근을 지원하든 안하든 상관없이 모든 경우에 적용될 수 있습니다.  </para>
  </sect2>
<!--   End of file partitioning/partition/i386.xml -->

<!-- Start of file partitioning/partition/ia64.xml -->


  <sect2 arch="ia64"
><title
>&arch-title;에서 파티션하기</title>

<para
><command
>Partman</command
>이라는 디스크 파티션 프로그램은 설치 프로그램이 기본으로 사용하는 파티션 프로그램입니다. 파티션과 마운트 위치를 자동으로 관리해줘서 디스크와 파일시스템들이 정상적으로 설정되어 있도록 해주고 성공적인 시스템 설치를 도와줍니다. 이 프로그램은 실제 파티션을 할 경우엔 <command
>parted</command
> 명령어를 사용합니다.  </para>

   <note>
   <title
>EFI에서 지원하는 포맷</title>
<para
>IA64의 EFI 펌웨어는 파티션 테이블 포맷, 또는 디스크 레이블 포맷으로 GPT와 MS-DOS를 모두 지원합니다. MS-DOS는 i386용 PC에서 사용하는 방식으로, IA64에서는 GPT를 권장합니다. 설치 프로그램은 하드디스크를 포맷할 때 <command
>cfdisk</command
> 명령도 지원하지만 IA64에서는 GPT와 MS-DOS를 모두 지원하는 <ulink url="parted.txt"
> <command
>parted</command
></ulink
>를 사용하십시오.  </para
></note>

<para
><command
>Partman</command
> 명령어가 자동으로 파티션 하도록 하면 EFI형 파티션이 디스크의 가장 앞쪽에 설치됩니다. GUI에서 파티션하기를 원하실 경우 <emphasis
>스왑파티션</emphasis
>을 설정할 때와 마찬가지로 <guimenuitem
>Guided partitioning</guimenuitem
> 메뉴를 선택해서 EFI형 파티션을 만드실 수 있습니다.  </para
><para
><command
>Partman</command
> 파티션 프로그램에서 대부분의 디스크 구성을 지원합니다만, 간혹가다 직접 디스크 구성을 해야 하는 경우가 있습니다. 이런 경우에는 앞에서 설명한 바와 같이 쉘로 나간 후에 <command
>parted</command
>프로그램을 직접 실행시키시면 됩니다. 디스크를 전부 지운 후 GPT형 파티션 테이블과 파티션 몇 개를 만드시면 아래 순서를 따라가시면 됩니다. <informalexample
><screen>
      mklabel gpt
      mkpartfs primary fat 0 50
      mkpartfs primary linux-swap 51 1000
      mkpartfs primary ext2 1001 3000
      set 1 boot on
      print
      quit
</screen
></informalexample
> 위의 과정을 밟으시면 새 파티션 테이블이 생성되고, EFI형 부팅 파티션 3개, 스왑 파티션과 루트 파일시스템이 생성됩니다. 그리고 EFI 파티션에 부트 플래그를 1로 설정한 후 끝냅니다. 파티션의 크기는 메가바이트(MB) 단위로 표시되며, 시작은 디스크의 맨 앞을 기준으로 합니다. 앞 예제를 살펴보면 1999MB 짜리 ext2 파일시스템을 디스크 앞에서 1001MB 위치에 설치됩니다. 참고로 <command
>parted</command
>으로 스왑파티션을 포맷하면 이 프로그램이 배드블럭을 검사하는데 몇분정도 걸릴 수 있습니다.  </para>
  </sect2>

  <sect2 arch="ia64"
><title
>부트로더 파티션의 제약</title>

<para
>IA64용 부트로더인 ELILO는 부트 플래그가 1인 FAT형 파티션을 필요로 합니다. 이 파티션에 부트로더와 커널, 램디스크가 저장되므로 충분히 커야 합니다. 최소 20 MB입니다만, 커널을 여러개 두고자 하실 경우엔 128 MB정도는 필요할 것입니다.  </para
><para
>EFI 부트매니져와 EFI 쉘 모두 GPT 파티션 테이블을 지원하므로 부트파티션을 굳이 디스크의 맨 앞에 두거나 같은 디스크에 둬야 하지 않습니다. 이 말은 부트파티션을 깜빡하고 안한 상태에서 다른 파티션을 포맷했을 경우에도 문제가 없다는 뜻입니다. <command
>Partman</command
> 프로그램은 EFI 파티션이 있는지 확인하는 동시에 <emphasis
>루트파티션</emphasis
>이 제대로 설정되어 있는지를 확인해주어 패키지를 설치하기 전에 디스크의 구성을 고칠 수 있도록 해줍니다. 이 실수를 고치려면 디스크의 마지막 파티션의 크기를 조정하여 EFI형 파티션을 이 위치에 설정하면 됩니다.  </para
><para
>EFI 부트 파티션과 <emphasis
>루트파티션</emphasis
>을 꼭 같은 디스크에 할당할 것을 권장합니다.  </para>

  </sect2>

  <sect2 arch="ia64"
><title
>EFI 검사용 파티션</title>

<para
>EFI의 펌웨어는 대부분의 x86 BIOS보다 훨씬 복잡합니다. 어떤 시스템 제조사는 EFI가 파일에 접근하고 하드디스크의 프로그램을 실행시킬 수 있는 기능을 이용하여 디스크에 각종 검사기록과 EFI기반의 시스템 관리 프로그램들을 저장하기도 합니다. 이들은 시스템 디스크와 다른 별도의 FAT형 파티션에 저장됩니다. 자세한 내용은 시스템과 같이 제공되는 문서와 기타 부속품을 확인하십시오. 시스템 검사용 파티션은 EFI 부트 파티션을 설정할 때 같이 설정하시면 편합니다.  </para>

   </sect2>
<!--   End of file partitioning/partition/ia64.xml -->

<!-- Start of file partitioning/partition/mips.xml -->


  <sect2 arch="mips"
><title
>&arch-title;에서 파티션하기</title>
<para
>SGI의 Indys에서 하드디스크로 부팅을 하고자 할 경우 SGI 디스크 레이블을 필요로 합니다. 이는 fdisk의 전문가용 메뉴에서 만들 수 있습니다. 이 때 만들어지는 9번 파티션인 볼륨 헤더는 최소한 3MB어이야 합니다. 볼륨헤더를 너무 작게 만들었다면 9번 파티션을 삭제하고 더 크게 새로 만드시면 됩니다. 이 때 볼륨헤더는 0번 섹터에 만들어야 합니다.  </para>
  </sect2>
<!--   End of file partitioning/partition/mips.xml -->

<!-- Start of file partitioning/partition/powerpc.xml -->


  <sect2 arch="powerpc"
><title
>현대 PowerMac에서 파티션하기</title>
<para
>NewWorld PowerMac에 데비안을 설치하실 경우 부트로더를 저장할 특별한 부트스트랩 파티션을 만드셔야 합니다. 이 파티션은 최소한 800 KB이어야 하며 <emphasis
>Apple_Bootstrap</emphasis
>형 파티션이어야 합니다. <emphasis
>Apple_Bootstrap</emphasis
>형 파티션이 아닐 경우 하드디스크로 부팅이 안 됩니다. 이 형식의 파티션은 <command
>partman</command
>프로그램으로 새 파티션을 만드신 후 <quote
>NewWorld boot partition</quote
>으로 설정하거나, <command
>mac-fdisk</command
>프로그램에서 <userinput
>b</userinput
> 명령을 사용해서 만드시면 됩니다.  </para
><para
>Apple_Bootstrap이라는 파티션 형식은 MacOS가 부트스트랩 파티션을 마운트해서 그 내용을 손상시키는 것을 방지하기 위해 필요합니다. OpenFirmware에서 자동으로 부팅하도록 특별히 수정된 파티션이기 때문입니다.  </para
><para
>부트스트랩 파티션에는 <command
>yaboot</command
>바이너리, 설정파일인 <filename
>yaboot.conf</filename
>, OpenFirmware의 일단계 로더인 <command
>ofboot.b</command
> 3개만 저장됩니다. 파일시스템에 마운트될 필요도 없으며 마운트 되서도 안 되고, 커널이나 기타 다른 내용이 이 파티션에 저장되어서도 안 됩니다. 이 파티션은 <command
>ybin</command
>프로그램과 <command
>mkofboot</command
> 프로그램을 통해서 관리하실 수 있습니다.  </para
><para
>OpenFirmware에서 &debian;이 성공적으로 부팅되기 위해서는 부트스트랩 파티션이 다른 부팅 파티션보다, 특히 MacOS용 부팅 파티션 앞에 와야 합니다. 부트스트랩 파티션을 가장 먼저 만드는 것이 좋습니다. 나중에 부트스트랩 파티션을 생성하는 경우에는 <command
>mac-fdisk</command
>의 <userinput
>r</userinput
> 명령을 사용하여 파티션의 배열을 재정렬하실 수 있습니다. 파티션 배열은 항상 1번 파티션이므로, 부트스트랩 파티션은 바로 다음에 와야 합니다. 물리적인 주소의 순서가 중요한 것이 아니라 논리적인 배열 순서가 중요합니다.  </para
><para
>애플컴퓨터용 디스크는 많은 경우 파티션이 작게 잡혀있습니다. MacOSX와 듀얼부팅하기를 원하신다면, 이 파티션들과 작은 HFS 파티션(800k가 최소입니다) 하나 정도를 그대로 두시기 바랍니다. 이는 MacOSX가 부팅될 때마다 활성화된 MacOS용 파티션과 드라이버 파티션이 없는 디스크를 초기화하고자 하기 때문입니다.  </para>
  </sect2>
<!--   End of file partitioning/partition/powerpc.xml -->

<!-- Start of file partitioning/partition/sparc.xml -->


  <sect2 arch="sparc"
><title
>&arch-title;에서 파티션하기</title>
<para
>부팅디스크에 <quote
>Sun disk label</quote
>를 꼭 만들어두시기 바랍니다. OpenBoot PROM이 유일하게 이해하는 파티션 방식이기 때문이고, 부팅 디스크가 이 방식으로 파티션이 되어있지 않을 경우에는 부팅을 할 수 없기 때문입니다. <quote
>Sun disk label</quote
>는 <command
>fdisk</command
> 실행시 <keycap
>s</keycap
>키를 이용하여 만드실 수 있습니다.  </para
><para
>&arch-title;용 디스크에서 파티션이 반드시 0번 실린더에서 시작하도록 하십시오. 첫번째 파티션에는 파티션 테이블과 부팅 블록 처음 2 섹터에 저장되므로 첫번째 파티션을 스왑으로 지정하시면 안됩니다. 스왑 형식의 파티션은 처음 몇 섹터도 보존하지 않기 때문입니다. 스왑 형식의 파티션 대신에 Ext2나 UFS 형식의 파티션으로 지정하면 이 섹터들을 보존할 수 있을 것입니다.  </para
><para
>세번째 파티션은 <quote
>Whole disk</quote
> (5번 형식)으로 둬서 디스크 전체를 포괄하도록 하는 것이 좋습니다. 이것은 <quote
>Sun disk label</quote
>에서 사용되는 규약으로, SILO가 정상적인 동작을 하는데 도움이 됩니다.  </para>
  </sect2>
<!--   End of file partitioning/partition/sparc.xml -->

 </sect1>
<!--   End of file partitioning/partition-programs.xml -->

</appendix>
<!--   End of file partitioning/partitioning.xml -->
