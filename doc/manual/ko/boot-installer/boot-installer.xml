<!-- Start of file boot-installer/boot-installer.xml -->

<chapter id="boot-installer"
><title
>설치 시스템 부팅하기</title>

<!-- Include only archs that are documented to avoid build-errors -->
<!-- The arch="..." condition can be deleted when al archs are present -->
 <sect1 arch="alpha;arm;i386;ia64;m68k;mips;s390;powerpc;sparc">
 <title
>&arch-title;에서 설치 프로그램 부팅하기</title>

<!-- This info is so architecture dependent, that I have turned the   -->
<!-- structure inside out for this chapter. Each arch has a document. -->
<!-- Note: archs hppa and mipsel are currently missing -->


<!-- Start of file boot-installer/alpha.xml -->

 <sect2 arch="alpha" id="alpha-firmware">
 <title
>Alpha 콘솔 펌웨어</title>
<para
>콘솔 펌웨어는 플래시 ROM에 들어 있고 Alpha 시스템의 전원을 켜거나 리셋할 때 시작합니다. Alpha 시스템에는 두 가지 콘솔 방식이 있어서, 두 종류의 콘솔 펌웨어를 사용할 수 있습니다: </para>

<itemizedlist>
<listitem
><para
><emphasis
>SRM 콘솔</emphasis
>은, Alpha Console Subsystem 명세서에 기반하며, OpenVMS, Tru64 UNIX 및 리눅스 운영체제를 위한 운영 환경이 있습니다. </para
></listitem>
<listitem
><para
><emphasis
>ARC, AlphaBIOS, 혹은 ARCSBIOS 콘솔</emphasis
>은, Advanced RISC Computing (ARC) 명세서에 기반하며, Windows NT를 위한 운영 환경이 있습니다. </para
></listitem>
</itemizedlist>

<para
>사용자 측면에서 SRM과 ARC의 가장 중요한 차이점은, 어떤 콘솔을 선택하느냐에 따라서 부팅하려는 하드 디스크에 사용할 수 있는 파티션 방식이 다르다는 점입니다. </para
><para
>ARC에서는 부팅 디스크에 MS-DOS 파티션 테이블을 사용해야 합니다 (<command
>cfdisk</command
> 명령으로 만듭니다). 즉 MS-DOS 파티션 테이블은 ARC에서 부팅할 때 <quote
>네이티브</quote
> 파티션 형식입니다. AlphaBIOS에 디스크 파티션 유틸리티가 들어 있기 때문에, 원한다면 리눅스를 설치하기 전에 펌웨어 메뉴에서 디스크를 파티션할 수도 있습니다. </para
><para
>그 반대로, SRM은 MS-DOS 파티션 테이블과 <emphasis
>호환되지 않습니다</emphasis
>. <footnote
><para
>특히, Console Subsystem Specification에서 필요한 부트섹터 형식이 DOS 파티션 테이블의 위치와 충돌합니다</para
></footnote
> Tru64 Unix는 BSD 디스크레이블 형식을 사용하기 때문에, 이 형식이 SRM 설치의 경우 <quote
>네이티브</quote
> 파티션 형식입니다. </para
><para
>Alpha에서 GNU/리눅스는 이 두 콘솔에서 모두 부팅할 수 있는 유일한 운영체제입니다. 하지만 &debian; &release; 릴리스는 SRM 기반 시스템에서만 부팅을 지원합니다. SRM이 없는 Alpha 시스템을 가지고 있다면, Windows NT와 같이 선택 부팅을 할 것이고, BIOS 초기화에 ARC 콘솔 기능이 필요하다면, &debian; &release; 설치 프로그램을 사용할 수 없을 것입니다. ARC 콘솔이 필요한 경우에도 다른 설치 미디어를 이용해서 &debian; &release; 릴리스를 실행할 수 있습니다. 예를 들어 MILO로 데비안 woody를 설치하고 업그레이드할 수 있습니다. </para
><para
>현재 제조되는 (2000년 2월 이후로) Alpha 시스템에서는 <command
>MILO</command
>를 사용할 수 없으므로, 그리고 옛날 Alpha 시스템에서 SRM 펌웨어를 쓰려고 OpenVMS나 Tru64 유닉스 라이선스를 구입할 필요는 없으므로, 가능하면 SRM을 사용하기를 권장합니다. </para
><para
>다음 표는 지원하는 시스템 종류/콘솔을 요약한 것입니다 (시스템 종류 이름에 관해서는 <xref linkend="alpha-cpus"/> 참고). 아래의 <quote
>ARC</quote
>라는 말은 ARC와 호환되는 모든 콘솔을 뜻합니다. </para
><para>

<informaltable
><tgroup cols="2">
<thead>
<row>
  <entry
>시스템 종류</entry>
  <entry
>지원하는 콘솔 종류</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>alcor</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>avanti</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>book1</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>cabriolet</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>dp264</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>eb164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>eb64p</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>eb66</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>eb66p</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>jensen</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>lx164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>miata</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>mikasa</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>mikasa-p</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>nautilus</entry>
  <entry
>ARC (마더보드 매뉴얼 참고) 혹은 SRM</entry>
</row
><row>
  <entry
>noname</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>noritake</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>noritake-p</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>pc164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>rawhide</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>ruffian</entry>
  <entry
>ARC 전용</entry>
</row
><row>
  <entry
>sable</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>sable-g</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>sx164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>takara</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>xl</entry>
  <entry
>ARC 전용</entry>
</row
><row>
  <entry
>xlt</entry>
  <entry
>ARC 전용</entry>
</row>

</tbody>
</tgroup>
</informaltable>

</para
><para
>이 콘솔 중에 어느 것도 직접 리눅스를 부팅할 수 없습니다. 그래서 중간 역할을 하는 부트 로더를 활용해야 합니다. SRM 콘솔의 경우 작은 플랫폼 독립 부트로더인, <command
>aboot</command
>를 사용합니다. <command
>aboot</command
>에 대한 더 자세한 정보는 <ulink url="&url-srm-howto;"
>SRM HOWTO</ulink
>를 참고하십시오. (아쉽지만 좀 오래 된 내용) </para
><para condition="FIXME"
>다음 문단은 woody 설치 매뉴얼에서 가져온 부분으로, 참고하십시오. 나중에 데비안이 MILO 기반 설치를 다시 지원할 때 유용할 것입니다. </para
><para condition="FIXME"
>이 콘솔 중에 어느 것도 리눅스를 직접 부팅할 수 없습니다. 그래서 중간 역할을 하는 부트 로더를 활용해야 합니다. 주로 쓰는 리눅스 로더 프로그램은 두 개인데, <command
>MILO</command
>와 <command
>aboot</command
>입니다. </para
><para condition="FIXME"
><command
>MILO</command
>는 그 자체가 콘솔이며, 메모리에서 ARC나 SRM을 덮어 씁니다. <command
>MILO</command
>는 ARC나 SRM에서 부팅할 수 있으며 ARC 콘솔에서는 리눅스를 부팅할 수 있는 유일한 방법입니다. <command
>MILO</command
>는 플랫폼에 따라 다르고 (각 시스템 종류에 따라 다른 <command
>MILO</command
>가 필요합니다) 위의 표에서 ARC를 지원하는 시스템에만 있습니다. <ulink url="&url-milo-howto;"
>MILO HOWTO</ulink
>도 참고하십시오 (아쉽지만 좀 오래된 내용). </para
><para condition="FIXME"
><command
>aboot</command
>는 작은 플랫폼 독립 부트로더로, SRM에서만 동작합니다. <command
>aboot</command
>에 대한 더 자세한 정보는 <ulink url="&url-srm-howto;"
>SRM HOWTO</ulink
>를 참고하십시오 (역시 아쉽지만 좀 오래된 내용). </para
><para condition="FIXME"
>즉, 시스템의 콘솔 펌웨어가 무엇인가와 <command
>MILO</command
>를 사용할 수 있는지 여부에 따라 세 가지 방법이 가능합니다: <informalexample
><screen>
SRM -&gt; aboot
SRM -&gt; MILO
ARC -&gt; MILO
</screen
></informalexample
> 현재 제조되는 (2000년 2월 이후로) Alpha 시스템에서는 <command
>MILO</command
>를 사용할 수 없으므로, 그리고 옛날 Alpha 시스템에서 SRM 펌웨어를 쓰려고 OpenVMS나 Tru64 유닉스 라이선스를 구입할 필요는 없으므로, 가능하면 SRM을 사용하기를 권장합니다. (Windows NT와 듀얼 부팅을 하는 경우가 아니라면.) </para
><para
>AlphaServer의 대다수와 현재의 모든 서버와 워크스테이션 제품들에는 펌웨어 안에 SRM과 AlphaBIOS가 모두 들어 있습니다. 여러가지 평가보드처럼 <quote
>반쪽-플래시</quote
>기계들의 경우에는, 펌웨어를 플래시에 다시 쓰는 방법을 통해 두 가지 사이를 전환할 수 있습니다. 또 SRM을 설치하면 플로피 디스크에서 ARC/AlphaBIOS를 실행할 수 있습니다 (<command
>arc</command
> 명령어 사용). 위에서 설명한 이유들때문에, 우리는 &debian;을 설치하기 전에 SRM으로 바꾸기를 권장합니다. </para
><para
>다른 아키텍처와 마찬가지로, &debian;을 설치하기 전에 항상 최신 버전의 펌웨어를 <footnote
><para
>Jensen의 경우는 예외입니다. Jensen에서는 1.7 뒤 버전의 펌웨어에서 리눅스를 사용할 수 없습니다. 자세한 정보는 <ulink url="&url-jensen-howto;"
></ulink
> 참고.</para
></footnote
> 설치해야 합니다. Alpha의 경우, 펌웨어 업데이트는 <ulink url="&url-alpha-firmware;"
>Alpha Firmware Updates</ulink
>에서 구할 수 있습니다. </para>
 </sect2>


  <sect2 arch="alpha"
><title
>TFTP로 부팅하기</title>
<para
>SRM에서 이더넷 인터페이스는 이름 앞에 <userinput
>ewa</userinput
>가 붙고, <userinput
>show dev</userinput
> 명령을 실행하면 다음과 같은 인터페이스 목록을 볼 수 있습니다: <informalexample
><screen>
&gt;&gt;&gt; show dev
ewa0.0.0.9.0               EWA0              08-00-2B-86-98-65
ewb0.0.0.11.0              EWB0              08-00-2B-86-98-54
ewc0.0.0.2002.0            EWC0              00-06-2B-01-32-B0
</screen
></informalexample
> 먼저 부팅 프로토콜을 설정해야 합니다: <informalexample
><screen>
&gt;&gt;&gt; set ewa0_protocol bootp
</screen
></informalexample
> 그 다음에 미디어 종류를 올바르게 맞추십시오: <informalexample
><screen>
&gt;&gt;&gt; set ewa0_mode <replaceable
>mode</replaceable>
</screen
></informalexample
>  <userinput
>&gt;&gt;&gt;set ewa0_mode</userinput
> 명령으로 가능한 모드 목록을 볼 수 있습니다. </para
><para
>그 다음, 첫 번째 이더넷 인터페이스로 부팅하려면 다음을 입력하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot ewa0 -flags ""
</screen
></informalexample
> 그러면 netboot 이미지에 들어 있는 대로 기본 커널 파라미터를 사용해 부팅하게 됩니다. </para
><para
>시리얼 콘솔을 사용하려면, <userinput
>console=</userinput
> 파라미터를 커널에 넘겨야 <emphasis
>합니다</emphasis
>. <userinput
>-flags</userinput
> 인수를 SRM <userinput
>boot</userinput
> 명령에 사용하면 됩니다. 시리얼 포트의 이름은 <userinput
>/dev</userinput
> 아래 있는 해당 장치 파일 이름과 같습니다. 또, 추가 커널 파라미터를 지정할 경우, &d-i; 이미지에서 필요한 기본 옵션들을 다시 집어 넣어야 합니다. 예를 들어, <userinput
>ewa0</userinput
>에서 부팅해서 첫 번째 시리얼 포트를 사용하려면, 다음과 같이 입력합니다: <informalexample
><screen
>&gt;&gt;&gt; boot ewa0 -flags &quot;root=/dev/ram ramdisk_size=16384 console=ttyS0&quot;
</screen
></informalexample>

</para>
  </sect2>

  <sect2 arch="alpha"
><title
>SRM 콘솔로 CD-ROM에서 부팅하기</title>
<para
>다음 명령을 입력하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot xxxx -flags 0
</screen
></informalexample
> 여기서 <replaceable
>xxxx</replaceable
>는 CD-ROM 드라이브의 SRM방식 표기입니다. </para>
  </sect2>

  <sect2 arch="alpha" condition="FIXME">
  <title
>ARC 혹은 AlphaBIOS 콘솔로 CD-ROM에서 부팅하기</title>
<para
>ARC 콘솔에서 CD-ROM을 부팅하려면, 서브 아키텍처 코드 이름을 찾아서 (<xref linkend="alpha-cpus"/> 참고), <filename
>\milo\linload.exe</filename
>를 부트 로더로 입력하고 <filename
>\milo\<replaceable
>subarch</replaceable
></filename
>를 (여기서 <replaceable
>subarch</replaceable
>는 해당 서브 아키텍처 이름) `OS Selection Setup' 메뉴의 OS Path로 입력하십시오. Ruffian의 경우는 예외로, 부트 로더로 <filename
>\milo\ldmilo.exe</filename
>를 입력하십시오. </para>
  </sect2>


  <sect2 arch="alpha" condition="supports-floppy-boot">
  <title
>SRM 콘솔로 플로피에서 부팅하기</title>
<para
>SRM 프롬프트에서 (<prompt
>&gt;&gt;&gt;</prompt
>), 다음 명령을 실행하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot dva0 -flags 0
</screen
></informalexample
> 여기서 <filename
>dva0</filename
>을 실제 장치 이름으로 바꿔야 할 수도 있습니다. 보통 <filename
>dva0</filename
>이 플로피입니다. 다음을 실행해 장치 목록을 보려면 (CD에서 부팅하려거나 할 때) 다음을 실행하십시오: <informalexample
><screen>
&gt;&gt;&gt; show dev
</screen
></informalexample
> MILO를 통해 부팅하는 경우, <command
>-flags</command
> 인수는 무시하기 때문에, <command
>boot dva0</command
>라고만 입력할 수도 있습니다. 모두 문제 없이 동작한다면, 마침내 리눅스 커널 부팅을 볼 수 있을 것입니다. </para
><para
><command
>aboot</command
>를 통해 부팅할 때 커널 파라미터를 지정하려면, 다음 명령을 사용하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot dva0 -file linux.bin.gz -flags "root=/dev/fd0 load_ramdisk=1 arguments"
</screen
></informalexample
> (한 줄에 입력하십시오) 필요한 경우 <filename
>dva0</filename
>을 실제 SRM 부팅 장치 이름으로, <filename
>fd0</filename
>을 리눅스 부팅 장치 이름으로, <filename
>arguments</filename
>를 사용하려는 커널 파라미터로 바꾸십시오. </para
><para
>MILO를 통해 부팅할 때 커널 파라미터를 지정하려면, 부팅할 때 MILO로 들어간 다음 일시정지해야 합니다. <xref linkend="booting-from-milo"/> 참고. </para>
  </sect2>


  <sect2 arch="alpha" condition="supports-floppy-boot">
  <title
>ARC 혹은 AlphaBIOS 콘솔로 플로피에서 부팅하기</title>

<para
>OS Selection 메뉴에서, <command
>linload.exe</command
>를 부트 로더로, <command
>milo</command
>를 OS Path로 설정하십시오. 새로 만든 항목을 이용해 부팅하십시오. </para>
  </sect2>

 <sect2 arch="alpha" condition="FIXME" id="booting-from-milo"
><title
>MILO로 부팅하기</title>
<para
>부팅 미디어에 들어 있는 MILO는 자동으로 리눅스로 들어가도록 되어 있습니다. 중간에 멈추려면 MILO 카운트다운동안에 스페이스 키를 누르면 됩니다. </para
><para
>모든 부분을 하나 하나 지정하려면 (예를 들어, 파라미터를 추가로 지정하려면), 다음과 같은 명령을 사용하십시오: <informalexample
><screen>
MILO
> boot fd0:linux.bin.gz root=/dev/fd0 load_ramdisk=1 <!-- arguments -->
</screen
></informalexample
> 플로피 외에 다른 장치에서 부팅하는 경우에는, 위의 예에서 <filename
>fd0</filename
>을 적당한 리눅스 장치 이름으로 바꾸십시오. <command
>help</command
> 명령을 실행하면 간단한 MILO 명령어 도움말을 볼 수 있습니다. </para>
 </sect2>
<!--   End of file boot-installer/alpha.xml -->

<!-- Start of file boot-installer/arm.xml -->

  <sect2 arch="arm" id="boot-tftp"
><title
>TFTP에서 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부트 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

  <sect3 arch="arm"
><title
>NetWinder에서 TFTP에서 부팅하기</title>

<para
>NetWinders에는 두 개의 네트워크 인터페이스가 있습니다: 10Mbps NE2000 호환 카드는 <filename
>eth0</filename
>이고 100Mbps Tulip 카드는 <filename
>eth1</filename
>입니다. </para
><note
><para
>설치 시스템을 부팅하려면 NeTTrom 2.2.1 혹은 그 이후의 버전을 사용해야 합니다. NeTTrom 2.3.3을 권장합니다: 다음 파일을 <ulink url="ftp://ftp.netwinder.org/pub/netwinder/firmware/"
></ulink
>에서 가져오십시오: <itemizedlist>
<listitem
><para>

<filename
>nettrom-2.3-3.armv4l.rpm</filename>

</para
></listitem>
<listitem
><para>

<filename
>nettrom-2.3.3.bin</filename>

</para
></listitem>
<listitem
><para>

<filename
>nettrom-2.3.3.bin.md5sum</filename>

</para
></listitem>
</itemizedlist>

</para
></note
><para
>다시 부팅해서 카운트다운할 때 부팅 과정을 일시 중단한 다음에, 네트워크를 고정 주소로 설정할 수 있습니다: <informalexample
><screen>
    NeTTrom command-&gt; setenv eth0_ip 192.168.0.10/24
</screen
></informalexample
> 여기서 24는 네트마스크의 비트 개수입니다. 아니면 동적 주소로 설정할 수도 있습니다: <informalexample
><screen>
    NeTTrom command-&gt; boot diskless
</screen
></informalexample
> TFTP 서버가 로컬 서브네트에 없다면 <userinput
>route1</userinput
>을 설정해야 할 수도 있습니다. 나머지 설정은 항상 똑같습니다 (save-all 단계는 하지 않을 수도 있음): <informalexample
><screen>
    NeTTrom command-&gt; setenv kerntftpserver 192.168.0.1
    NeTTrom command-&gt; setenv kerntftpfile boot.img
    NeTTrom command-&gt; save-all
    NeTTrom command-&gt; setenv netconfig_eth0 flash
    NeTTrom command-&gt; setenv kernconfig tftp
    NeTTrom command-&gt; setenv rootdev /dev/ram
    NeTTrom command-&gt; setenv cmdappend root=/dev/ram
</screen
></informalexample
> 마지막 4개의 경우에는 일반적인 디스크 부팅과 다르기 때문에, 그 바로 전에 <command
>save-all</command
> 명령을 실행하는 게 안전합니다. 이 명령은 네트워크에서 다시 부팅할 경우에 필요한 네트워크 설정을 저장합니다. NetWinder를 설치할 때 시리얼 콘솔을 사용하려면, 다음 설정도 필요합니다: <informalexample
><screen>
    NeTTrom command-&gt; setenv cmdappend root=/dev/ram console=ttyS0,115200
</screen
></informalexample
> 환경 설정을 다시 보려면 <command
>printenv</command
> 명령을 사용하십시오. 마지막으로 <envar
>cmdappend</envar
> NeTTrom 변수에 <option
>noinitrd</option
> 옵션이 있으면, 이 옵션을 먼저 없애야 다운로드한 커널을 램디스크로 부팅할 수 있습니다. </para>
  </sect3>

  <sect3 arch="arm"
><title
>CATS에서 TFTP에서 부팅하기</title>

<para
>CATS 기계에서는 Cyclone 프롬프트에서 <command
>boot de0:</command
>과 같은 명령을 사용하십시오. </para>
   </sect3>
  </sect2>



  <sect2 arch="arm"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->

<para
>대부분의 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 것입니다. CD 세트를 가지고 있고, 기계에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="i386"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고 이 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 꾸러미를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 꾸러미를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<para
>Cyclone 콘솔 프롬프트에서 CD-ROM 부팅을 하려면, <command
>boot cd0:cats.bin</command
> 명령을 사용하십시오. </para>
  </sect2>
<!--   End of file boot-installer/arm.xml -->
<!-- &boot-installer-hppa.xml; -->

<!-- Start of file boot-installer/i386.xml -->

  <sect2 arch="i386"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->

<para
>대부분의 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 것입니다. CD 세트를 가지고 있고, 기계에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="i386"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고 이 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 꾸러미를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 꾸러미를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<!-- We'll comment the following section until we know exact layout -->
<!--
CD #1 of official Debian CD-ROM sets for &arch-title; will present a
<prompt
>boot:</prompt
> prompt on most hardware. Press
<keycap
>F3</keycap
> to see the list of kernel options available
from which to boot. Just type your chosen flavor name (idepci,
vanilla, compact, bf24) at the <prompt
>boot:</prompt
> prompt
followed by &enterkey;.

</para
><para>

If your hardware doesn't support booting of multiple images, put one
of the other CDs in the drive. It appears that most SCSI CD-ROM drives
do not support <command
>isolinux</command
> multiple image booting, so users
with SCSI CD-ROMs should try either CD2 (vanilla) or CD3 (compact),
or CD5 (bf2.4).

</para
><para>

CD's 2 through 5 will each boot a
different ``flavor'' depending on which CD-ROM is
inserted. See <xref linkend="kernel-choice"/> for a discussion of the
different flavors.  Here's how the flavors are laid out on the
different CD-ROMs:

<variablelist>
<varlistentry>
<term
>CD 1</term
><listitem
><para>

Allows a selection of kernel images to boot from (the idepci flavor is
the default if no selection is made).

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 2</term
><listitem
><para>

Boots the <quote
>vanilla</quote
> flavor.

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 3</term
><listitem
><para>

Boots the <quote
>compact</quote
> flavor.

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 4</term
><listitem
><para>

Boots the <quote
>idepci</quote
> flavor.

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 5</term
><listitem
><para>

Boots the <quote
>bf2.4</quote
> flavor.

</para
></listitem
></varlistentry>

 </variablelist>

</para
><para>

-->

  </sect2>

<!-- FIXME the documented procedure does not exactly work, commented out
     until fixes

  <sect2 arch="i386" id="install-from-dos">
  <title
>Booting from a DOS partition</title>


<para>

Boot into DOS (not Windows) without any drivers being loaded.  To do
this, you have to press <keycap
>F8</keycap
> at exactly the right
moment (and optionally select the <quote
>safe mode command prompt only</quote>
option).  Enter the subdirectory for the flavor you chose, e.g.,

<informalexample
><screen
>
cd c:\install
</screen
></informalexample
>.

Next, execute <command
>install.bat</command
>.
The kernel will load and launch the installer system.

</para
><para>

Please note, there is currently a loadlin problem (#142421) which
precludes <filename
>install.bat</filename
> from being used with the
bf2.4 flavor. The symptom of the problem is an
<computeroutput
>invalid compressed format</computeroutput
> error.

</para>
  </sect2>

END FIXME -->

  <sect2 arch="i386" id="boot-initrd">
  <title
><command
>LILO</command
> 혹은 <command
>GRUB</command
>을 사용해 리눅스 부팅하기</title>

<para
>하드 디스크에서 설치 프로그램을 부팅하려면, 먼저 <xref linkend="boot-drive-files"/>에서 설명한 필요한 파일들을 내려 받아 하드에 저장해야 합니다. </para>

<para
>하드 드라이브를 부팅용으로만 사용하고 나머지는 모두 네트워크에서 받으려고 한다면, <filename
>netboot/debian-installer/i386/initrd.gz</filename
> 파일 및 해당 커널을 받아야 합니다. 설치 프로그램을 부팅한 다음에 하드 디스크를 다시 파티션할 수 있습니다. 단 주의를 기울여야 합니다. </para>

<para
>다른 방법으로, 하드 드라이브의 현재 파티션을 바꾸지 않고 유지하려면, <filename
>hd-media/initrd.gz</filename
> 파일과 그 커널을 받으시고, CD iso 파일도 드라이브에 복사해 놓으십시오 (파일 이름이 <literal
>.iso</literal
>로 끝나도록 하십시오). 그러면 설치 프로그램이 이 드라이브에서 부팅한 다음 네트워크 없이 그 CD 이미지에서 설치할 수 있습니다. </para>

<para
><command
>LILO</command
>의 경우, <filename
>/etc/lilo.conf</filename
>에 있는 두 가지 중요한 부분을 설정해야 합니다: <itemizedlist
> <listitem
><para
> 부팅할 때 <filename
>initrd.gz</filename
> 설치 프로그램을 읽어들여야 하고 </para
></listitem
> <listitem
><para
> <filename
>vmlinuz</filename
> 커널의 루트 파티션으로 램 디스크를 사용하도록 합니다. </para
></listitem
> </itemizedlist
> 여기 예제 <filename
>/etc/lilo.conf</filename
> 파일이 있습니다: </para
><para>

<informalexample
><screen
>image=/boot/newinstall/vmlinuz
       label=newinstall
       initrd=/boot/newinstall/initrd.gz
       root=/dev/ram0
       append="<phrase condition="sarge"
>devfs=mount,dall </phrase
>ramdisk_size=12000"
</screen
></informalexample
> 더 자세한 정보는, <citerefentry
><refentrytitle
>initrd</refentrytitle
> <manvolnum
>4</manvolnum
></citerefentry
> 및 <citerefentry
><refentrytitle
>lilo.conf</refentrytitle
> <manvolnum
>5</manvolnum
></citerefentry
> 맨페이지를 참고하십시오. 이제 <userinput
>lilo</userinput
>를 실행하고 다시 부팅하십시오. </para
><para
><command
>GRUB</command
> 사용법은 아주 비슷합니다. <filename
>menu.lst</filename
> 파일을 <filename
>/boot/grub/</filename
> 디렉토리에 (어떤 경우는 <filename
>/boot/boot/grub/</filename
>) 놓고, 다음 줄을 추가하십시오: <informalexample
><screen>
title  New Install
kernel (hd0,0)/boot/newinstall/vmlinuz root=/dev/ram0 ramdisk_size=12000
initrd (hd0,0)/boot/newinstall/initrd.gz
</screen
></informalexample
> 그리고 다시 부팅하십시오. 부팅이 실패하면 <quote
>kernel</quote
> 줄에 <userinput
>devfs=mount,dall</userinput
>을 추가해 보십시오. </para
><para
><userinput
>ramdisk_size</userinput
>의 값을 initrd 이미지 크기에 따라 조정해야 할 수도 있습니다. 이 이후부터는 <command
>GRUB</command
>와 <command
>LILO</command
> 사이에 차이점이 없습니다. </para>
  </sect2>

  <sect2 arch="i386" id="usb-boot">
  <title
>USB 메모리 스틱에서 부팅하기</title>
<para
><xref linkend="boot-dev-select"/> 및 <xref linkend="boot-usb-files"/>의 모든 것을 준비했다고 하면, USB 스틱을 빈 USB 커넥터에 꼽고 컴퓨터를 다시 부팅하십시오. 시스템이 부팅해서 <prompt
>boot:</prompt
> 프롬프트가 나와야 합니다. 거기에서 부팅 파라미터를 추가로 넣을 수도 있고, 그냥 &enterkey;를 누를 수도 있습니다. </para
><para
>컴퓨터가 USB 메모리 장치에서 부팅을 지원하지 않는 경우, 플로피로 부팅한 다음에 USB로 바꿀 수 있습니다. <xref linkend="floppy-boot"/>에 설명된 대로 부팅하십시오. 부트 플로피의 커널은 USB 스틱을 자동으로 찾아낼 것입니다. 루트 플로피가 필요한 시점에, &enterkey;를 누르십시오. 그러면 &d-i;가 시작할 것입니다. </para>
  </sect2>

  <sect2 arch="i386" id="floppy-boot">
  <title
>플로피에서 부팅하기</title>
<para
>필요한 플로피 이미지를 내려받아서 <xref linkend="create-floppy"/>에 설명한 대로 이미지에서 플로피를 만듭니다. </para
><para
>설치 프로그램의 부트 플로피에서 부팅하려면, 플로피를 첫 번째 플로피 드라이브에 넣고, 평소에 하던 방법대로 시스템을 끈 다음 다시 켜십시오. </para
><para
>플로피를 이용해 LS-120 드라이브에서 (ATAPI 버전) 설치하는 경우, 플로피 장치의 가상 위치를 지정해야 합니다. <emphasis
>root=</emphasis
> 부팅 파라미터를 사용해, ide-floppy 드라이버가 어느 장치로 매핑되는 지 장치를 지정합니다. 예를 들어, LS-120 드라이브가 두 번째 케이블의 첫 번째 (master) IDE 장치에 연결되어 있는 경우, 부팅 프롬프트에서 <userinput
>linux root=/dev/hdc</userinput
>라고 입력합니다. LS-120에서 설치하는 건 2.4 이후의 커널에서만 지원합니다. </para
><para
>몇몇 기계에서는 <keycombo
><keycap
>Control</keycap
> <keycap
>Alt</keycap
> <keycap
>Delete</keycap
></keycombo
> 키를 눌러도 컴퓨터를 리셋하지 않기 때문에, <quote
>하드</quote
> 리부팅을 권장합니다. 기존 운영 체제에서 설치하는 경우에는 (예를 들어 DOS에서) 다른 방법이 없습니다. 그 외의 경우에는 항상 부팅할 때 하드 리부팅을 하십시오. </para
><para
>플로피 디스크를 읽게 됩니다. 그 다음에 부트 플로피에 대해 소개하는 화면이 나오고 마지막에 <prompt
>boot:</prompt
> 프롬프트가 나옵니다. </para
><para
>&enterkey;를 누르면, <computeroutput
>Loading...</computeroutput
> 메세지 다음에, <computeroutput
>Uncompressing Linux...</computeroutput
>라고 나오고, 시스템의 하드웨어에 관한 여러가지 정보가 화면 가득히 나옵니다. 이 부팅 과정에 대한 더 자세한 정보는 아래의 <xref linkend="kernel-msgs"/>에 있습니다. </para
><para
>부트 플로피에서 부팅한 다음, 루트 플로피를 요청합니다. 루트 플로피를 넣고 &enterkey;를 누르십시오. 그러면 루트 플로피의 내용을 메모리에 읽어들입니다. 설치 프로그램 <command
>debian-installer</command
>를 자동으로 실행합니다. </para>
  </sect2>

  <sect2 arch="i386" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부트 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>i386에서 TFTP 부팅을 하는 여러 가지 방법이 있습니다. </para>

   <sect3
><title
>PXE를 지원하는 NIC 혹은 마더보드</title>
<para
>네트워크 인터페이스 카드나 마더보드에서 PXE 부팅 기능을 지원할 수도 있습니다. PXE는 <trademark class="trade"
>Intel</trademark
>에서 TFTP 부팅을 다시 만든 것입니다. PXE를 지원하는 경우 네트워크 부팅을 하도록 BIOS를 설정할 수 있을 것입니다. </para>
   </sect3>

   <sect3
><title
>네트워크 부트롬이 들어 있는 NIC</title>
<para
>네트워크 인터페이스 카드에서 TFTP 부팅 기능을 지원할 수도 있습니다. </para
><para condition="FIXME"
>어떻게 했는 지 알려 주십시오 (<email
>&email-debian-boot-list;</email
>). 이 문서를 언급해 주십시오. </para>
   </sect3>

   <sect3
><title
>Etherboot</title>
<para
><ulink url="http://www.etherboot.org"
>etherboot project</ulink
>에는 TFTPboot를 할 수 있는 부팅 디스켓과 부트롬이 있습니다. </para>
   </sect3>
  </sect2>

  <sect2 arch="i386"
><title
>부팅 프롬프트</title>
<para
>설치 프로그램이 부팅할 때, 데비안 로고와 다음 부팅 프롬프트가 표시되는 친근한 그래픽 화면이 나타납니다: <informalexample
><screen>
Press F1 for help, or ENTER to boot:
</screen
></informalexample
> 부팅 프롬프트에서 그냥 &enterkey; 키를 눌러 기본 옵션으로 설치 프로그램을 부팅할 수도 있고, 특정 부팅 방법이나 부팅 파라미터를 입력할 수도 있습니다. </para
><para
><keycap
>F2</keycap
>에서 <phrase condition="sarge"
><keycap
>F7</keycap
></phrase
><phrase condition="etch"
><keycap
>F8</keycap
></phrase
>까지 누르다 보면 유용한 부팅 방법과 부팅 파라미터에 대한 정보를 볼 수 있습니다. 부팅 명령행에 파라미터를 넣으려면, 부팅 방법을 입력하는 걸 잊지 마시고 (기본값은 <userinput
>linux</userinput
>), 첫 번째 파라미터 앞에 공백을 넣으십시오 (예를 들어, <userinput
>linux debconf/priority=medium</userinput
>). <note
><para
>VGA 콘솔 텍스트 인터페이스 기능이 들어 있는 원격 관리 장치를 이용해 시스템을 설치하는 경우에는, 설치 프로그램이 부팅할 때 나타나는 최초의 그래픽 스플래시 화면을 볼 수 없을 수도 있습니다. 부팅 프롬프트조차 볼 수 없을 수도 있습니다. 그러한 장치는 Compaq의 <quote
>integrated Lights Out</quote
> (iLO) 및 HP의 <quote
>integrated Remote Assistant</quote
>가 있습니다. 화면을 보지 못하더라도 F1<footnote
> <para
> 어떤 경우 이스케이프 시퀀스를 이용해야 이 키를 누를 수 있습니다. 예를 들어 IRA는 <keycombo
> <keycap
>Ctrl</keycap
> <keycap
>F</keycap
> </keycombo
>,&nbsp;<keycap
>1</keycap
>을 사용합니다. </para
> </footnote
>을 누르면 그래픽 화면을 넘어가고 도움말 텍스트를 볼 수 있습니다. 스플래시 스크린이 넘어가면 도움말 텍스트에서 키를 누르면 그 키가 프롬프트에 쓰여집니다. 설치할 때 프레임버퍼를 사용하지 않으려면 도움말 텍스트에 표시된 것처럼 <userinput
>debian-installer/framebuffer=false</userinput
> 옵션을 부팅 프롬프트에 넘깁니다. </para
></note>
</para>

  </sect2>
<!--   End of file boot-installer/i386.xml -->

<!-- Start of file boot-installer/ia64.xml -->

  <sect2 arch="ia64"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->

<para
>대부분의 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 것입니다. CD 세트를 가지고 있고, 기계에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="i386"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고 이 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 꾸러미를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 꾸러미를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

  <note>
  <title
>CD 내용</title>

<para
>세 가지 종류의 데비안 설치 CD가 있습니다. <emphasis
>Business Card</emphasis
> CD는 작은 CD 미디어에 맞도록 만든 최소한의 설치 미디어입니다. 베이스를 설치하고 쓸만한 시스템을 만들려면 네트워크 연결이 필요합니다. <emphasis
>Network Install</emphasis
> CD는 베이스 설치에 필요한 모든 꾸러미가 들어 있지만 완전한 시스템에 필요한 추가 꾸러미를 설치하려면 데비안 미러 사이트에 네트워크 연결이 필요합니다. 데비안 CD 세트는 네트워크 접근 없이 여러 가지 꾸러미들을 완전히 설치할 수 있습니다. </para>
  </note>

<para
>IA-64 아키텍처에는 인텔에서 나온 차세대 Extensible Firmware Interface가 (EFI) 들어 있습니다. 전통적인 x86 BIOS는 파티션 테이블과 Master Boot Record (MBR) 외에는 부팅 장치에 대해 거의 아무것도 모르지만, EFI는 FAT16 혹은 FAT32 포맷된 디스크 파티션에 파일을 읽고 쓸 수 있습니다. 이 기능때문에 아주 복잡한 방법으로 시스템을 시작하는 과정도 단순하게 할 수 있습니다. EFI를 지원하는 시스템 부트 로더 및 EFI 펌웨어는 기계를 부팅하는 데 필요한 파일들을 저장하는 완전한 파일 시스템이 따로 있습니다. 즉 IA-64 시스템의 시스템 디스크에는 전통적인 시스템에서 쓰는 단순한 MBR이나 부트 블록이 아닌 EFI만 사용하는 전용 디스크 파티션이 있습니다. </para
><para
>데비안 설치 CD에는 작은 EFI 파티션이 들어 있어서, 거기에 <command
>ELILO</command
> 부트로더, 그 설정 파일, 설치 프로그램 커널, 파일 시스템(initrd)이 들어 있습니다. 시스템에도 부팅하는 데 필요한 파일들이 들어 있는 EFI 파티션이 들어 있습니다. 이 파일은 아래에 설명한 방법으로 EFI Shell에서 읽을 수 있습니다. </para
><para
><command
>ELILO</command
>에서 실제로 어떻게 시스템을 읽어들여서 시작하는 지에 대한 것들은 시스템 설치 프로그램과는 관련이 없습니다. 하지만 설치 프로그램에서는 베이스 시스템을 설치하기 전에 EFI 파티션을 설정해야 합니다. 그렇지 않으면 <command
>ELILO</command
> 설치가 실패해서, 시스템을 부팅할 수 없게 됩니다. 설치할 때 꾸러미를 설치하기 전에 파티션하는 단계에서 EFI 파티션을 만들고 포맷하게 됩니다. 설치를 계속하기 전에 파티션 작업에서 EFI 파티션이 있는 지 검사도 합니다. </para
><para
>펌웨어 초기화의 마지막 단계에서 EFI 부트 매니저가 나타납니다. 메뉴 목록이 나와서 사용자가 그 중의 하나를 선택합니다. 시스템의 모델과 어떤 소프트웨어를 읽어들였느냐에 따라, 이 메뉴는 시스템마다 다릅니다. 최소한 두 개의 메뉴 항목이 있어야 합니다. <command
>Boot Option Maintenance Menu</command
> 및 <command
>EFI Shell (Built-in)</command
>입니다. 첫 번째 옵션을 사용하는 게 좋지만, 그 옵션이 없거나 CD가 부팅하지 않는다면 두 번째 옵션을 사용하십시오. </para>

  <warning>
  <title
>중요</title>
<para
>EFI Boot Manager에서 정해진 몇 초가 지나면 기본 부팅 동작을 (보통 메뉴에서 첫 번째) 선택합니다. 화면 아래의 카운트다운을 보면 알 수 있습니다. 타이머가 다 되면 기본 동작을 시작하고, 그러면 설치를 계속하기 위해 기계를 다시 부팅해야 할 수도 있습니다. 기본 액션이 EFI Shell인 경우 쉘 프롬프트에서 <command
>exit</command
> 명령을 실행해 Boot Manager로 돌아오십시오. </para>
  </warning>

  <sect3 arch="ia64" id="bootable-cd">
  <title
>방법 1: Boot Option Maintenance Menu에서 부팅</title>
 

<itemizedlist>

<listitem
><para
>CD를 DVD/CD 드라이브에 넣고 기계를 다시 부팅하십시오. 펌웨어가 시스템 초기화를 마치면 EFI Boot Manager 페이지와 메뉴를 표시합니다. </para
></listitem>

<listitem
><para
>메뉴에서 화살표로 <command
>Boot Maintenance Menu</command
>를 선택해 <command
>ENTER</command
>를 누르십시오. 그러면 다른 메뉴가 나타납니다. </para
></listitem>

<listitem
><para
>메뉴에서 화살표로 <command
>Boot From a File</command
>을 선택해 <command
>ENTER</command
>를 누르십시오. 그러면 펌웨어가 찾은 장치의 목록이 나옵니다. 메뉴에서 <command
>Debian Inst [Acpi ...</command
> 혹은 <command
>Removable Media Boot</command
>라고 되어 있는 두 줄이 나옵니다. 그 메뉴 항목의 나머지를 보면, 장치와 컨트롤러 정보가 같은 지 알 수 있습니다. </para
></listitem>

<listitem
><para
>CD/DVD 드라이브를 가리키는 어떤 항목이든 선택할 수 있습니다. 화살표 키로 선택해서 <command
>ENTER</command
>를 누릅니다. <command
>Removable Media Boot</command
>를 선택한 경우 기계가 즉시 부팅 단계로 들어갑니다. 그게 아니라 <command
>Debian Inst [Acpi ...</command
>를 선택한 경우, CD의 부팅 가능 영역 디렉토리의 내용을 표시하고, 다음 단계로 진행할 수 있습니다. </para
></listitem>

<listitem
><para
>이 단계는 <command
>Debian Inst [Acpi ...</command
>를 선택한 경우에만 필요합니다. 디렉토리 목록에서는 마지막 줄 다음에 <command
>[Treat like Removable Media Boot]</command
>도 표시합니다. 이 줄을 화살표로 선택해 <command
>ENTER</command
>를 누르십시오. 그러면 부팅 과정을 시작합니다. </para
></listitem>

</itemizedlist>

<para
>데비안 부트 로더가 시작하고 부팅 커널과 옵션을 선택하는 메뉴 페이지를 표시합니다. 계속해서 부팅 커널과 옵션을 선택하십시오. </para>
  </sect3>

  <sect3 arch="ia64" id="boot-with-efi">
  <title
>방법 2: EFI Shell에서 부팅</title>
<para
>어떤 이유에서든 방법 1이 실패하면, 기계를 다시 부팅하십시오. EFI Boot Manager 화면에서 <command
>EFI Shell [Built-in]</command
>이라는 옵션이 있습니다. 다음 과정을 통해 데비안 설치 CD를 부팅하십시오: </para>

<itemizedlist>

<listitem
><para
>CD를 DVD/CD 드라이브에 넣고 기계를 다시 부팅하십시오. 펌웨어가 시스템 초기화를 마치면 EFI Boot Manager 페이지와 메뉴가 나타납니다. </para
></listitem>

<listitem
><para
>메뉴에서 화살표로 <command
>EFI Shell</command
>을 선택하고 <command
>ENTER</command
>를 누르십시오. EFI Shell은 부팅 가능한 장치를 모두 검색하고 명령어 프롬프트 앞에 장치 목록을 표시합니다. 찾아낸 부팅 가능 파티션은 <filename
>fs<replaceable
>n</replaceable
>:</filename
> 식으로 이름을 표시합니다. 그 외에 찾아낸 파티션은 <filename
>blk<replaceable
>n</replaceable
>:</filename
> 모양입니다. CD를 넣었다면 쉘에 들어가면서 CD 드라이브를 초기화하는 데 몇 초가 더 걸릴 수 있습니다. </para>
</listitem>

<listitem
><para
>쉘에서 CD-ROM 드라이브를 찾을 때 출력을 잘 살펴보십시오. 다른 장치는 <filename
>fs<replaceable
>n</replaceable
></filename
>이라고 나올 때 CD-ROM 드라이브는 <filename
>fs0:</filename
>이라고 나올 것입니다. </para
></listitem>

<listitem
><para
><command
>fs<replaceable
>n</replaceable
>:</command
>이라고 입력하고 <command
>ENTER</command
>를 눌러 선택하십시오. 여기서 <replaceable
>n</replaceable
>은 CD-ROM의 파티션 번호입니다. 그러면 파티션 번호가 쉘의 프롬프트에 표시됩니다. </para
></listitem>

<listitem
><para
><command
>elilo</command
>라고 입력하고 <command
>ENTER</command
>를 누르십시오. 그러면 부팅 과정을 시작합니다. </para
></listitem>

</itemizedlist>

<para
>방법 1과 마찬가지로, 데비안 부트 로더가 시작하면 부트 커널과 옵션을 선택하는 메뉴 페이지를 표시합니다. 쉘 프롬프트에서 더 간단히 <command
>fs<replaceable
>n</replaceable
>:elilo</command
> 명령을 입력할 수도 있습니다. 계속해서 부팅 커널과 옵션을 선택하십시오. </para>

  </sect3>

  <sect3 arch="ia64" id="serial-console">
  <title
>시리얼 콘솔을 사용해 설치하기</title>

<para
>설치할 때 모니터와 키보드를 사용할 수도 있고 시리얼 연결을 사용할 수도 있습니다. 모니터/키보드 설정을 이용하려면, [VGA console]이 들어 있는 옵션을 선택하십시오. 시리얼 연결을 통해 설치하려면, [<replaceable
>BAUD</replaceable
> baud serial console]이 들어 있는 옵션을 선택하십시오. 여기서 <replaceable
>BAUD</replaceable
>는 시리얼 콘솔의 속도입니다. ttyS0 장치가 가장 일반적인 속도로 설정되어 있는 메뉴 항목이 이미 설정되어 있습니다. </para
><para
>대부분의 경우, 설치 프로그램의 속도를 EFI 콘솔 연결과 같게 해야 합니다. 설정을 어떻게 해야 할 지 잘 모르겠다면, EFI 쉘에서 <command
>baud</command
> 명령으로 알아낼 수 있습니다. </para
><para
>사용하려는 시리얼 장치나 속도에 맞춰 설정된 옵션이 없다면, 기존 메뉴 옵션의 콘솔 설정을 바꿀 수 있습니다. 예를 들어, ttyS1 장치에 57600 baud 콘솔을 사용하려면, <classname
>Boot:</classname
> 텍스트 창에 <command
>console=ttyS1,57600n8</command
>이라고 입력하십시오. </para>

<note
><para
>대부분의 IA-64 컴퓨터는 기본 콘솔 설정이 9600bps로 되어 있습니다. 이 속도는 상당히 느려서, 기본 설치 과정에서 각 화면을 그릴 때 상당한 시간을 소모하게 됩니다. 설치 과정에서 사용하는 속도를 빠르게 하거나, 텍스트 모드 설치를 고려해 봐야 합니다. 텍스트 모드에서 설치를 시작하려면 <classname
>Params</classname
> 도움말 메뉴를 참고하십시오. </para
></note>

<warning
><para
>잘못된 콘솔 종류를 선택했다면, 커널을 선택하고 파라미터를 입력할 수는 있지만 커널이 시작하자 마자 화면과 입력이 멎어 버릴 것입니다. 그러면 다시 부팅해야 설치를 할 수 있습니다. </para
></warning>
  </sect3>

  <sect3 arch="ia64" id="kernel-option-menu">
  <title
>부팅 커널과 옵션 선택하기</title>

<para
>부트 로더에서 메뉴 목록과 <classname
>Boot:</classname
> 프롬프트가 있는 텍스트 창을 표시합니다. 화살표 키로 메뉴의 항목을 선택할 수 있고 키보드로 입력한 텍스트도 텍스트 창에 나타납니다. 각 펑션 키를 누르면 도움말 화면도 나타납니다. <classname
>General</classname
> 도움말 화면은 메뉴 선택에 대해 설명하고 <classname
>Params</classname
> 화면은 일반적인 명령행 옵션에 대해 설명합니다. </para
><para
><classname
>General</classname
> 도움말 화면을 보면 설치하는 데 가장 적합한 커널과 설치 모드에 대한 설명이 있습니다. 또 아래의 <xref linkend="boot-parms"/>에 보면 <classname
>Boot:</classname
> 텍스트 창에서 입력할 수 있는 추가 파라미터에 대한 설명이 있습니다. 커널 버전은 설치 과정과 설치된 시스템 모두에 사용할 커널의 버전을 설정합니다. 그래서 설치할 때 커널 문제가 발생하면, 설치한 시스템에서도 같은 문제가 발생할 것입니다. 다음 두 단계에서 설치 모드를 선택하고 설치를 시작합니다: </para>

<itemizedlist>

<listitem
><para
>화살표 키로 가장 적합한 커널 버전과 설치 모드를 선택하십시오. </para
></listitem>

<listitem
><para
>키보드로 부팅 파라미터가 있으면 입력하십시오. 입력한 텍스트가 텍스트 창에 직접 표시됩니다. 여기에서 커널 파라미터를 지정합니다 (예를 들어 시리얼 콘솔 설정). </para
></listitem>

<listitem
><para
><command
>ENTER</command
>를 누르십시오. 그러면 커널을 읽어들여서 시작합니다. 커널에서 초기화 메세지를 표시한 다음에 데비안 설치 프로그램의 첫 번째 화면이 나타납니다. </para
></listitem>

</itemizedlist>

<para
>다음 장으로 가서 언어 로케일, 네트워크, 디스크 파티션 설정을 계속 하십시오. </para>
  </sect3>
  </sect2>

  <sect2 arch="ia64" id="boot-tftp"
><title
>TFTP로 부팅하기</title>

<para
>네트워크에서 IA64 시스템을 부팅하는 건 CD 부팅과 비슷합니다. 차이점은 설치 커널을 읽어들이는 방법입니다. EFI 부트 관리자는 네트워크에 있는 서버에서 프로그램을 읽어들여서 실행할 수 있습니다. 일단 설치 커널을 읽어들이고 실행하면, CD 설치와 마찬가지로 시스템 설치를 진행합니다. 차이점은 베이스 설치 꾸러미를 CD 드라이브가 아니라 네트워크에서 가져온다는 점입니다. </para>


<!-- Start of file boot-installer/intro-net.xml -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부트 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>IA64 시스템에서 네트워크 부팅은 두 가지 아키텍처 전용 작업이 필요합니다. 부트 서버에서는 DHCP와 TFTP에서 <command
>elilo</command
>를 전송하도록 설정해야 합니다. 클라이언트에서는 EFI 부트 매니저가 네트워크에서 읽어들이게 하는 부트 옵션을 정의해야 합니다. </para>

  <sect3 arch="ia64" id="boot-tftp-server">
  <title
>서버 설정하기</title>
<para
>IA64 시스템에서 네트워크 부팅을 위한 TFTP 엔트리는 다음과 같습니다: <informalexample
><screen>
host mcmuffin {
        hardware ethernet 00:30:6e:1e:0e:83;
        fixed-address 10.0.0.21;
        filename "debian-installer/ia64/elilo.efi";
}
</screen
></informalexample
> 목표는 <command
>elilo.efi</command
>를 클라이언트에서 실행하는 것입니다. </para
><para
><filename
>netboot.tar.gz</filename
> 파일을 TFTP 서버의 루트에 쓸 디렉토리에 풀어 놓으십시오. TFTP 루트 디렉토리는 보통 <filename
>/var/lib/tftp</filename
> 및 <filename
>/tftpboot</filename
>입니다. 파일을 풀면 <filename
>debian-installer</filename
> 디렉토리 밑에 IA64 시스템용 부팅 파일들이 들어 있습니다. </para
><para>

<informalexample
><screen
># cd /var/lib/tftp
# tar xvfz /home/user/netboot.tar.gz
./
./debian-installer/
./debian-installer/ia64/
[...]
</screen
></informalexample
> <filename
>netboot.tar.gz</filename
> 안에는, 대부분의 경우에 동작하는 <filename
>elilo.conf</filename
> 파일이 들어 있습니다. 하지만 이 파일을 수정해야 하는 경우에는, <filename
>debian-installer/ia64/</filename
> 디렉토리 안에 있습니다. 각각의 클라이언트에 대해 다른 설정 파일을 이용하려면 파일이름을 <filename
>elilo.conf</filename
> 대신에 클라이언트의 IP 주소를 16진수로 쓰고 <filename
>.conf</filename
>를 뒤에 붙이면 됩니다. 자세한 설명은 <classname
>elilo</classname
> 꾸러미에 들어 있는 문서를 참고하십시오. </para>
  </sect3>

  <sect3 arch="ia64" id="boot-tftp-client">
  <title
>클라이언트 설정하기</title>
<para
>TFTP 부팅을 지원하도록 클라이언트를 설정하려면, EFI를 부팅해서 <guimenu
>Boot Option Maintenance Menu</guimenu
>로 들어가십시오. <itemizedlist
> <listitem
><para
> 부트 옵션을 추가하십시오. </para
></listitem
> <listitem
><para
> <guimenuitem
>Load File [Acpi()/.../Mac()]</guimenuitem
> 텍스트가 들어 있는 줄을 볼 수 있을 것입니다. 이런 항목이 여러 줄 있을 때, 부팅하려는 인터페이스의 MAC 주소가 들어 있는 항목을 선택하십시오. 화살표 키로 반전시킨 다음 enter를 누르십시오. </para
></listitem
> <listitem
><para
> 그 항목을 <userinput
>Netboot</userinput
>와 같이 이름 짓고, 저장하고, 부트 옵션 메뉴로 나가십시오. </para
></listitem
> </itemizedlist
> 이제 방금 만든 새로운 부트 옵션을 볼 수 있을 것입니다. 그 옵션을 선택하면 DHCP 쿼리를 하고, 서버에서 <filename
>elilo.efi</filename
> 파일을 서버에서 가져옵니다. </para
><para
>부트로더에서 설정 파일을 내려받고 관련된 처리를 한 다음 프롬프트를 표시합니다. 여기까지 오면, CD 설치와 마찬가지로 설치를 진행합니다. 위에서와 같이 부트 옵션을 선택하시고 네트워크에서 커널 설치를 마치면, 데비안 설치 프로그램이 시작합니다. </para
><para
>다음 장으로 가서 언어 로케일, 네트워크, 디스크 파티션 설정을 계속 하십시오. </para>
  </sect3>
  </sect2>
<!--   End of file boot-installer/ia64.xml -->

<!-- Start of file boot-installer/m68k.xml -->

  <sect2 arch="m68k"
><title
>설치 방법 고르기</title>

<para
>몇몇 &arch-title; 서브 아키텍처는 2.4.x 아니면 2.2.x 리눅스 커널중에 하나를 선택해 부팅하는 옵션이 있습니다. 그렇게 선택할 수 있는 경우, 2.4.x 리눅스 커널을 선택하십시오. 2.4.x 리눅스 커널을 사용할 때 오히려 더 작은 메모리를 사용합니다. 2.2.x는 고정된 크기의 램디스크를 사용하고 2.4.x는 tmpfs를 사용하기 때문입니다. </para
><para condition="etch"
>2.2.x 커널을 사용한다면, &ramdisksize; 커널 변수를 설정할 필요가 있습니다. </para
> <para condition="sarge"
>또한, 2.2.x 리눅스 커널을 사용한다면, 반드시 거기 맞는 램디스크를 사용해야 합니다. <ulink url="&disturl;/main/installer-&architecture;/current/images/MANIFEST"
>MANIFEST</ulink
>를 참고하십시오. 일반적으로 보통 해당 디렉토리의 initrd22.gz 램디스크를 사용해야 하면 됩니다. </para
><para
><userinput
>root=/dev/ram</userinput
>을 커널 파라미터로 사용하십시오. </para
><para
>문제가 있으면, <ulink url="&url-m68k-cts-faq;"
>cts's &arch-title; debian-installer FAQ</ulink
>를 참고하십시오. </para>

<itemizedlist>
	<listitem
><para
><xref linkend="m68k-boot-amiga"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-atari"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-bvme6000"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-mac"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-mvme"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-q40"/></para
></listitem>
</itemizedlist>


    <sect3 id="m68k-boot-amiga"
><title
>Amiga</title>
<para
>Amiga에서 설치하는 유일한 방법은 하드 드라이브입니다. (<xref linkend="m68k-boot-hd"/> 참고) <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para
><para
>현재 Amiga에서는 bogl이 동작하지 않습니다. bogl 오류가 있으면, 커널 파라미터에 <userinput
>debian-installer/framebuffer=false</userinput
>를 포함해야 합니다. </para>
    </sect3>

    <sect3 id="m68k-boot-atari"
><title
>Atari</title>
<para
>Atari용 설치 프로그램은 하드 드라이브에서 시작할 수도 있고 (<xref linkend="m68k-boot-hd"/> 참고) 플로피에서 시작할 수도 있습니다 (<xref linkend="boot-from-floppies"/> 참고). <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para
><para
>현재 Atari에서는 bogl이 동작하지 않습니다. bogl 오류가 있으면, 커널 파라미터에 <userinput
>debian-installer/framebuffer=false</userinput
>를 포함해야 합니다. </para>
    </sect3>

    <sect3 id="m68k-boot-bvme6000"
><title
>BVME6000</title>
<para
>BVME6000용 설치 프로그램은 CD-ROM (<xref linkend="m68k-boot-cdrom"/> 참고), 플로피 (<xref linkend="boot-from-floppies"/> 참고), 혹은 네트워크에서 (<xref linkend="boot-tftp"/> 참고) 실행할 수 있습니다. </para>
    </sect3>

    <sect3 id="m68k-boot-mac"
><title
>Macintosh</title>
<para
>Mac에서 사용할 수 있는 유일한 설치 방법은 하드 드라이브에서 설치하는 것입니다 (<xref linkend="m68k-boot-hd"/> 참고). <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> Mac에서는 2.4.x 커널이 동작하지 않습니다. </para
><para
>53c9x 기반 SCSI 버스를 사용하는 경우, <userinput
>mac53c9x=1</userinput
> 커널 파라미터를 써야 할 수 있습니다. Quadra 950처럼 그런 SCSI 버스가 두 개 있는 하드웨어의 경우 <userinput
>mac53c9x=2</userinput
> 파라미터를 사용해야 합니다.대신,자동발견을 켜기 위해 <userinput
>mac53c9x=-1,0</userinput
>로 설정할 수 있습니다. 하지만 이는 SCSI 연결해제를 불가능하게 할 수있습니다. 이 인수를 설정하는 것은 하나이상의 하드 디스크가 있을때 설정해야 합니다. 그외의 경우, 설정하지 않을 때 시스템이 더 빠르게 동작합니다. </para>
    </sect3>

    <sect3 id="m68k-boot-mvme"
><title
>MVME147 및 MVME16x</title>
<para
>MVME147 및 MVME16x용 설치 프로그램은 플로피 (<xref linkend="boot-from-floppies"/> 참고) 혹은 네트워크에서 (<xref linkend="boot-tftp"/> 참고) 설치할 수 있습니다. <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para>
    </sect3>

    <sect3 id="m68k-boot-q40"
><title
>Q40/Q60</title>
<para
>Q40/Q60에서 설치하는 유일한 방법은 하드 드라이브에서 설치하는 것입니다 (<xref linkend="m68k-boot-hd"/> 참고). <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para>
    </sect3>

  </sect2>

  <sect2 arch="m68k" id="m68k-boot-hd"
><title
>하드 디스크에서 부팅하기</title>


<!-- Start of file boot-installer/intro-hd.xml -->

<para
>기존 운영 체제에서 부팅하는 게 가장 편리한 방법입니다. 몇몇 시스템의 경우에는 이게 유일한 설치 방법입니다. </para
><para
>하드 디스크에서 설치 프로그램을 부팅하려면, <xref linkend="boot-drive-files"/>에서 필요한 파일들을 내려 받아서 하드 디스크에 저장해 놓습니다. </para>
<!--   End of file boot-installer/intro-hd.xml -->

<para
>하드 드라이브에서 부팅하려면 최소한 여섯 가지의 램디스크를 사용할 수 있습니다. 2.2.x 리눅스 커널이 지원하는 3가지와 지원하지 않는 3가지가 있습니다. (자세한 설명은 <ulink url="&disturl;/main/installer-&architecture;/current/images/MANIFEST"
>MANIFEST</ulink
> 참고) </para
><para
>세 가지 종류의 램 디스크는 <filename
>cdrom</filename
>, <filename
>hd-media</filename
>, <filename
>nativehd</filename
>입니다. 이 램디스크는 설치 꾸러미의 위치만 다릅니다. <filename
>cdrom</filename
> 램디스크는 debian-installer 꾸러미를 CD-ROM에서 가져옵니다. <filename
>hd-media</filename
> 램디스크는 하드 디스크에 들어 있는 CD-ROM의 ISO 이미지를 사용합니다. 마지막으로, <filename
>nativehd</filename
> 램디스크는 꾸러미를 설치하는 데 네트워크를 사용합니다. </para>

<itemizedlist>
	<listitem
><para
><xref linkend="m68k-boothd-amiga"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boothd-atari"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boothd-mac"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boothd-q40"/></para
></listitem>
</itemizedlist>


    <sect3 id="m68k-boothd-amiga"
><title
>AmigaOS에서 부팅하기</title>
<para
><command
>Workbench</command
>에서는, <filename
>debian</filename
> 디렉토리 안의 <guiicon
>StartInstall</guiicon
> 아이콘을 더블클릭해서 리눅스 설치를 시작하십시오. </para
><para
>Amiga 설치 프로그램에서 디버깅 정보를 창에 출력하면 &enterkey;를 두 번 눌러야 합니다. 그 다음에 화면이 없어지면 몇 초간 딜레이가 있을 것입니다. 그 다음에 흰 글자의 검은 화면이 나타나고, 커널 디버깅 정보를 표시합니다. 이 메세지는 읽기에는 너무 빠르게 스크롤 되겠지만, 상관없습니다. 몇 초 후에 설치 프로그램이 자동으로 시작하고, <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>
    </sect3>


    <sect3 id="m68k-boothd-atari"
><title
>Atari TOS에서 부팅하기</title>
<para
>GEM 데스크탑에서, <filename
>debian</filename
> 디렉토리의 <guiicon
>bootstra.prg</guiicon
> 아이콘을 더블 클릭하고 프로그램 옵션 대화 상자의 <guibutton
>Ok</guibutton
>를 클릭해 리눅스 설치를 시작하십시오. </para
><para
>Atari 부팅 프로그램에서 디버깅 정보를 창에 출력하면 &enterkey;를 눌러야 합니다. 그 다음에 화면이 없어지면 몇 초간 딜레이가 있을 것입니다. 그 다음에 흰 글자의 검은 화면이 나타나고, 커널 디버깅 정보를 표시합니다. 이 메세지는 읽기에는 너무 빠르게 스크롤 되겠지만, 상관없습니다. 몇 초 후에, 설치 프로그램이 자동으로 시작하고, <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>
    </sect3>


    <sect3 id="m68k-boothd-mac"
><title
>MacOS에서 부팅하기</title>
<para
>원래 Mac 시스템을 유지하면서 그 시스템에서 부팅해야 합니다. MacOS가 부팅하면서 Penguin 리눅스 로더 부팅 준비를 할 때, <keycap
>shift</keycap
> 키를 눌러 확장 기능을 읽어들이지 않도록 해야 하는 게 <emphasis
>중요합니다</emphasis
>. 리눅스를 읽어들이는 것 이외에 MacOS를 사용하지 않는다면, Mac의 시스템 폴더에서 모든 확장 기능과 컨트롤 패널을 지우면 됩니다. 그렇지 않으면 확장 기능을 실행해서 리눅스 커널 실행에 여러 가지 문제가 발생할 수 있습니다. </para
><para
>Mac에서는 <command
>Penguin</command
> 부트로더가 필요합니다. <command
>Stuffit</command
> 아카이브를 다루는 도구가 없다면, &penguin19.hfs;가 <command
>Penguin</command
>이 들어 있는 HFS 디스크 이미지입니다. <xref linkend="create-floppy"/>에서 이미지를 플로피로 복사하는 방법을 설명합니다. </para
><para
>MacOS 데스크탑에서는 <filename
>Penguin</filename
> 디렉토리 안의 <guiicon
>Penguin Prefs</guiicon
> 아이콘을 더블클릭해 리눅스 설치를 시작하십시오. <command
>Penguin</command
> 부팅 프로그램이 시작합니다. <guimenu
>File</guimenu
> 메뉴에서 <guimenuitem
>Settings</guimenuitem
> 항목으로 가서, <guilabel
>Kernel</guilabel
> 탭을 클릭하십시오. 커널과 (<filename
>vmlinuz</filename
>) 램디스크 (<filename
>initrd.gz</filename
>) 이미지를 <filename
>install</filename
> 디렉토리에서 위의 오른쪽의 해당 단추를 클릭해 선택하십시오. 그리고 파일 선택 대화 상자를 이용해 파일을 찾으십시오. </para
><para
>Penguin에서 부팅 파라미터를 설정하려면, <guimenu
>File</guimenu
> -&gt; <guimenuitem
>Settings...</guimenuitem
>을 선택하시고, <guilabel
>Options</guilabel
> 탭으로 바꾸십시오. 텍스트 입력 창에서 부팅 파라미터를 입력할 수 있습니다. 항상 그 설정을 이용하려면, <guimenu
>File</guimenu
> -&gt; <guimenuitem
>Save Settings as Default</guimenuitem
>를 선택하십시오. </para
><para
><guilabel
>Settings</guilabel
> 대화 상자를 닫고, 설정을 저장하고 <guimenu
>File</guimenu
> 메뉴의 <guimenuitem
>Boot Now</guimenuitem
> 항목을 이용해 부팅을 시작하십시오. </para
><para
><command
>Penguin</command
> 부팅 프로그램에서 디버깅 정보를 창에 출력합니다. 그 다음에 화면이 회색으로 변하고, 몇 초간 딜레이가 있을 것입니다. 그 다음에 흰 글자의 검은 화면이 나타나고, 커널 디버깅 정보를 표시합니다. 이 메세지는 읽기에는 너무 빠르게 스크롤 되겠지만, 상관없습니다. 몇 초 후에, 설치 프로그램이 자동으로 시작하고, <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>

    </sect3>

    <sect3 id="m68k-boothd-q40"
><title
>Q40/Q60에서 부팅하기</title>

<para
>FIXME </para
><para
>설치 프로그램이 자동으로 시작합니다. <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>

    </sect3>
  </sect2>


  <sect2 arch="m68k" id="m68k-boot-cdrom"
><title
>CD-ROM에서 부팅하기</title>
<para
>현재 CD-ROM 부팅을 지원하는 &arch-title; 서브 아키텍처는 BVME6000뿐입니다. </para>


<!-- Start of file boot-installer/intro-cd.xml -->

<para
>대부분의 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 것입니다. CD 세트를 가지고 있고, 기계에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="i386"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고 이 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 꾸러미를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 꾸러미를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

  </sect2>


  <sect2 arch="m68k" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부트 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>VMEbus 시스템이 부팅하면, LILO <prompt
>Boot:</prompt
> 프롬프트가 나타납니다. 프롬프트에서 다음 중의 하나를 입력하면 리눅스를 부팅하고 vt102 터미널 에뮬레이션을 이용해 데비안 설치를 시작합니다. <itemizedlist>
<listitem
><para
>BVME4000/6000에 설치하려면 <screen
>i6000 &enterkey;</screen
>라고 입력하십시오 </para
></listitem>
<listitem
><para
>MVME162에 설치하려면 <screen
>i162 &enterkey;</screen
>라고 입력하십시오 </para
></listitem>
<listitem
><para
>MVME166/167에 설치하려면 <screen
>i167 &enterkey;</screen
>라고 입력하십시오 </para
></listitem>
    </itemizedlist>

</para
><para
>vt100 터미널 에뮬레이션을 이용하려면 <screen
>TERM=vt100</screen
> 파라미터를 붙일 수 있습니다. 예를 들어, <screen
>i6000 TERM=vt100 &enterkey;</screen
>. </para>
  </sect2>


  <sect2 arch="m68k" id="boot-from-floppies">
  <title
>플로피에서 부팅하기</title>
<para
>대부분의 &arch-title; 아키텍처의 경우, 로컬 파일시스템에서 부팅하는 게 가장 권장하는 방법입니다. </para
><para
>부트 플로피에서 부팅은 현재 Atari와 VMW에서만 (VME의 경우 SCSI 플로피 드라이브가 있으면) 동작합니다. </para>
 </sect2>
<!--   End of file boot-installer/m68k.xml -->

<!-- Start of file boot-installer/mips.xml -->


  <sect2 arch="mips" id="boot-tftp"
><title
>TFTP로 부팅하기</title>

   <sect3>
   <title
>SGI Indy TFTP 부팅</title>
<para
>SGI Indy에서 리눅스를 부팅하고 설치를 시작하려면 커맨드 모니터로 들어간 다음 다음 명령을 사용하십시오: <informalexample
><screen>
bootp():
</screen
></informalexample
> 이렇게 하려면, <envar
>netaddr</envar
> 환경 변수를 지워야 할 수도 있습니다. 지우려면 커맨드 모니터에서 다음 명령을 타이프하십시오: <informalexample
><screen>
unsetenv netaddr
</screen
></informalexample
> </para>
  </sect3>

   <sect3>
   <title
>Broadcom BCM91250A TFTP 부팅</title>
<para
>Broadcom BCM91250A 평가보드에서는 TFTP를 통해 SiByl 부트 로더를 읽어들여야 합니다. 그러면 데비안 설치 프로그램을 읽어들여서 시작합니다. 대부분의 경우 DHCP를 통해 IP 주소를 받지만 고정 주소를 설정할 수도 있습니다. DHCP를 사용하려면, CFE 프롬프트에서 다음 명령을 입력하십시오: <informalexample
><screen>
ifconfig eth0 -auto
</screen
></informalexample
> IP 주소를 받으면, 다음 명령으로 SiByl을 읽어들일 수 있습니다: <informalexample
><screen>
boot 192.168.1.1:/boot/sibyl
</screen
></informalexample
> 위의 예에서 IP 주소는 TFTP 주소의 이름 혹은 IP 주소로 바꿔야 합니다. 일단 이 명령을 실행하면, 설치 프로그램을 자동으로 읽어들입니다. </para>
</sect3>
  </sect2>

  <sect2 arch="mips"
><title
>부팅 파라미터</title>

   <sect3>
   <title
>SGI Indy TFTP 부팅</title>
<para
>SGI Indy에서는 커맨드 모니터에서 부팅 파라미터를 <command
>bootp():</command
> 명령어 뒤에 붙일 수 있습니다. </para
><para
>bootp/dhcp 서버에서 부팅할 파일을 지정하지 않았다면, <command
>bootp():</command
> 명령 뒤에 부팅할 파일의 경로와 이름을 지정할 수 있습니다. 예를 들어: <informalexample
><screen>
bootp():/boot/tftpboot.img
</screen
></informalexample
> 그 외의 커널 파라미터는 <command
>append</command
>를 통해 넘길 수 있습니다: <informalexample
><screen
>bootp(): append="root=/dev/sda1"
</screen
></informalexample>

</para>
  </sect3>

   <sect3>
   <title
>Broadcom BCM91250A TFTP 부팅</title>
<para
>CFE 프롬프트에서는 부트 파라미터를 직접 넘길 수 없습니다. 대신에 TFTP 서버에 있는 <filename
>/boot/sibyl.conf</filename
> 파일을 편집해서 <replaceable
>extra_args</replaceable
> 변수에 파라미터를 추가해야 합니다. </para>
  </sect3>

  </sect2>
<!--   End of file boot-installer/mips.xml -->
<!-- &boot-installer-mipsel.xml; -->

<!-- Start of file boot-installer/s390.xml -->

  <sect2 arch="s390"
><title
>s390 한계</title>
<para
>S/390에서 설치 시스템을 실행하려면 제대로 동작하는 네트워크 설정이 있어야 하고 SSH 세션이 필요합니다. </para
><para
>부팅 과정은 몇 가지 네트워크 파라미터를 설정하는 네트워크 설정으로 시작합니다. 설정이 성공하면, SSH 세션으로 로그인해서 거기에서 표준 설치 시스템을 시작합니다. </para>
  </sect2>


  <sect2 arch="s390"
><title
>s390 부팅 파라미터</title>
<para
>S/390에서는 parm 파일에 부팅 파라미터를 추가할 수 있습니다. ASCII나 EBCDIC 형식을 쓸 수 있습니다. S/390 관련 부팅 파라미터에 관한 더 자세한 정보는 <ulink url="&url-s390-devices;"
>Device Drivers and Installation Commands</ulink
>를 읽어 보십시오. </para>
  </sect2>
<!--   End of file boot-installer/s390.xml -->

<!-- Start of file boot-installer/powerpc.xml -->

  <sect2 arch="powerpc" id="boot-cd"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->

<para
>대부분의 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 것입니다. CD 세트를 가지고 있고, 기계에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="i386"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고 이 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 꾸러미를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 꾸러미를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<para
>현재, &arch-title; 서브 아키텍처중에서 CD-ROM 부팅을 지원하는 경우는 PReP 및 New World PowerMac뿐입니다. PowerMac에서 CD-ROM 부팅을 하려면, <keycap
>c</keycap
> 키를 누르고 있거나, <keycap
>Command</keycap
>, <keycap
>Option</keycap
>, <keycap
>Shift</keycap
>, <keycap
>Delete</keycap
> 키를 동시에 누르고 있으십시오. </para
><para
>OldWorld PowerMacs은 데비안 CD를 부팅하지 못합니다. OldWorld 컴퓨터는 CD에 있는 Mac OS ROM CD 부트 드라이버에 의존하기 때문입니다. 그리고 이 드라이버는 자유 소프트웨어 버전이 없습니다. 모든 OldWorld 시스템에는 플로피 드라이브가 있으므로, 이 플로피 드라이브로 설치 프로그램을 실행하십시오. 그 다음에 설치 프로그램에서 필요한 파일이 있으면 CD를 지정하십시오. </para
><para
>시스템이 CD-ROM에서 직접 부팅하지 못하는 경우에도, CD-ROM을 사용해 시스템을 설치할 수 있습니다. NewWorld에서는 OpenFirmware 명령을 이용해 CD-ROM을 수동으로 부팅할 수 있습니다. 하드디스크에 부팅하려면 <xref linkend="boot-newworld"/>에 있는 설명을 따라하십시오. 단 다음과 같이 CD에 있는 <command
>yaboot</command
> 경로를 사용하십시오 <informalexample
><screen
>0 &gt; boot cd:,\install\yaboot
</screen
></informalexample>

</para>
  </sect2>

  <sect2 arch="powerpc" id="install-drive">
  <title
>하드 디스크에서 부팅하기</title>


<!-- Start of file boot-installer/intro-hd.xml -->

<para
>기존 운영 체제에서 부팅하는 게 가장 편리한 방법입니다. 몇몇 시스템의 경우에는 이게 유일한 설치 방법입니다. </para
><para
>하드 디스크에서 설치 프로그램을 부팅하려면, <xref linkend="boot-drive-files"/>에서 필요한 파일들을 내려 받아서 하드 디스크에 저장해 놓습니다. </para>
<!--   End of file boot-installer/intro-hd.xml -->

  <sect3
><title
>OpenFirmware에서 CHRP 부팅하기</title>

<para>

  <emphasis
>Not yet written.</emphasis>

</para>
   </sect3>

   <sect3
><title
>MacOS에서 OldWorld PowerMac 부팅하기</title>
<para
><xref linkend="files-oldworld"/>의 BootX를 설정하는 경우, BootX를 이용해 설치 시스템을 부팅할 수 있습니다. <guiicon
>BootX</guiicon
> 애플리케이션 아이콘을 더블 클릭하십시오. <guibutton
>Options</guibutton
> 단추를 클릭해 <guilabel
>Use Specified RAM Disk</guilabel
>를 선택하십시오. 그러면 <filename
>ramdisk.image.gz</filename
> 파일을 선택할 수 있습니다. 하드웨어에 따라서는 <guilabel
>No Video Driver</guilabel
> 체크박스를 선택해야 할 수도 있습니다. 그리고 <guibutton
>Linux</guibutton
> 단추를 눌러 MacOS를 끝내고 설치 프로그램을 시작하십시오. </para>
   </sect3>


  <sect3 id="boot-newworld">
  <title
>OpenFirmware에서 NewWorld Mac 부팅하기</title>
<para
><xref linkend="files-newworld"/>의 <filename
>vmlinux</filename
>, <filename
>initrd.gz</filename
>, <filename
>yaboot</filename
>, <filename
>yaboot.conf</filename
> 파일을 HFS 파티션의 맨 위에 저장해 놓으십시오. 컴퓨터를 다시 시작하고, 즉시 (삐 소리가 날 때) <keycap
>Option</keycap
>, <keycap
>Command (클로버잎/Apple)</keycap
>, <keycap
>o</keycap
>, <keycap
>f</keycap
> 키를 동시에 누르고 있으십시오. 몇 초 후에 Open Firmware 프롬프트가 나타납니다. 프롬프트에서 다음을 입력하십시오: <informalexample
><screen>
0 &gt; boot hd:<replaceable
>x</replaceable
>,yaboot
</screen
></informalexample
> 여기서 <replaceable
>x</replaceable
>를 커널과 yaboot 파일이 들어 있는 HFS 파티션의 파티션 번호로 바꾸시고, &enterkey;를 누르십시오. 일부 시스템에서는, <userinput
>hd:</userinput
> 대신에 <userinput
>ide0:</userinput
>을 써야 할 수도 있습니다. 몇 초 안에 yaboot 프롬프트를 볼 수 있을 겁니다 <informalexample
><screen>
boot:
</screen
></informalexample
> yaboot의 <prompt
>boot:</prompt
> 프롬프트에서 <userinput
>install</userinput
> 혹은 <userinput
>install video=ofonly</userinput
> 명령을 입력하고 &enterkey;를 누르십시오. <userinput
>video=ofonly</userinput
> 인수는 <userinput
>install</userinput
>이 동작하지 않을 때에 호환성을 최대화하기 위해 시도해 볼 수 있습니다. 그러면 데비안 설치 프로그램이 시작합니다. </para>
   </sect3>
  </sect2>

  <sect2 arch="powerpc" id="usb-boot">
  <title
>USB 메모리 스틱에서 부팅하기</title>
<para
>현재 NewWorld PowerMacs 시스템은 USB 부팅을 지원한다고 알려져 있습니다. </para>

<para
><xref linkend="boot-usb-files"/>에 있는 모든 걸 준비해야 합니다. Macintosh 시스템을 USB 스틱에서 부팅하려면, Open Firmware는 USB 저장 장치를 검색하지 않기 때문에 프롬프트를 직접 사용해야 합니다. 프롬프트가 나오게 하려면, <keycombo
><keycap
>Command</keycap
> <keycap
>Option</keycap
> <keycap
>o</keycap
> <keycap
>f</keycap
></keycombo
> 키를 부팅하는 동안 동시에 누르고 계십시오. (<xref linkend="invoking-openfirmware"/> 참고) </para
><para
>장치 트리에서 USB 저장 장치가 나타나는 위치를 조정할 필요가 있습니다. 현재는 <command
>ofpath</command
>에서 자동으로 조정하지 못하기 때문입니다. Open Firmware 프롬프트에서 <userinput
>dev / ls</userinput
> 및 <userinput
>devalias</userinput
> 명령으로 모든 장치와 장치 별명의 목록을 보십시오. 예를 들어 문서 저자의 시스템에는 <filename
>usb0/disk</filename
>, <filename
>usb0/hub/disk</filename
>, <filename
>/pci@f2000000/usb@1b,1/disk@1</filename
>, 그리고 <filename
>/pci@f2000000/usb@1b,1/hub@1/disk@1</filename
>이 동작하고 있습니다. </para
><para
>장치 경로를 조정하고 나면, 다음과 같은 명령으로 설치 프로그램을 시작하십시오: <informalexample
><screen>
boot <replaceable
>usb0/disk</replaceable
>:<replaceable
>2</replaceable
>,\\:tbxi
</screen
></informalexample
> 여기서 <replaceable
>2</replaceable
>는 앞에서 부트 이미지를 복사해 놓은 Apple_HFS 혹은 Apple_Bootstrap 파티션이고, <userinput
>,\\:tbxi</userinput
> 부분은 전에 <command
>hattrib -b</command
> 해 놓은 디렉토리에 있는 "tbxi" 타입의 HFS 파일에서 (예를 들어 <command
>yaboot</command
>) 부팅하도록 Open Firmware에 알려 주는 역할을 합니다. </para
><para
>시스템이 부팅하고, <prompt
>boot:</prompt
> 프롬프트가 나타납니다. 여기서 다른 부팅 파라미터가 필요하면 입력하고, 아니면 그냥 &enterkey;를 누르십시오. </para
><warning
><para
>이 부팅 방법은 새로운 방법으로, 일부 NewWorld 시스템에서는 어려울 수도 있습니다. 문제가 있으면 설치 보고서를 <xref linkend="submit-bug"/>에 설명되어 있는 대로 제출해 주십시오. </para
></warning>
  </sect2>

  <sect2 arch="powerpc" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부트 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>현재, PReP 및 New World PowerMac 시스템은 네트부팅을 지원합니다. </para
><para
>NewWorld Power Mac과 같은 Open Firmware 기계에서는, 부트 모니터로 들어가서 (<xref linkend="invoking-openfirmware"/> 참고) <command
>boot enet:0</command
> 명령을 사용하십시오. PReP 및 CHRP 컴퓨터는 네트워크 위치를 지정하는 방법이 다릅니다. PReP 기계에서는, <userinput
>boot <replaceable
>server_ipaddr</replaceable
>,<replaceable
>file</replaceable
>,<replaceable
>client_ipaddr</replaceable
></userinput
>라고 시도해 보십시오. </para>
  </sect2>


  <sect2 arch="powerpc">
  <title
>플로피에서 부팅하기</title>
<para
>플로피 부팅은 &arch-title;에서 지원하지만, 보통 OldWorld 시스템에서만 사용 가능합니다. NewWorld 시스템에는 플로피 드라이브가 없고, 부팅을 지원하지 않는 USB 플로피 드라이브만 붙어 있습니다. </para
><para
>필요한 플로피 이미지를 내려받아서 <xref linkend="create-floppy"/>에 설명한 대로 이미지에서 플로피를 만듭니다. </para
><para
><filename
>boot-floppy-hfs.img</filename
> 플로피에서 부팅하려면, 시스템을 끄고 전원 단추를 누르기 전에 플로피 드라이브에 넣으십시오. </para
><note
><para
>Macintosh 플로피 작업에 익숙하지 않은 분들을 위해: 부팅하기 전에 넣은 플로피가 첫 번째 부팅 우선 순위를 가집니다. 부팅 시스템이 없는 플로피는 튀어 나오게 되고, 부팅 가능한 하드 디스크 파티션을 찾게 됩니다. </para
></note
><para
>부팅한 다음, <filename
>root.bin</filename
> 플로피를 요청합니다. 루트 플로피를 넣고 &enterkey;를 누르십시오. 루트 시스템을 메모리에 읽어들이면 설치 프로그램을 자동으로 시작합니다. </para>
  </sect2>


  <sect2 arch="powerpc"
><title
>PowerPC 부팅 파라미터</title>
<para
>오래된 Apple 모니터는 다수가 640x480 67Hz 모드를 사용합니다. 오래된 Apple 모니터에서 화면이 찌그러진다면, <userinput
>video=atyfb:vmode:6</userinput
> 부팅 파라미터를 추가해 보십시오. 그러면 대부분의 Mach64와 Rage 비디오 하드웨어에 맞는 비디오 모드를 선택합니다. Rage 128 하드웨어의 경우에는, <userinput
>video=aty128fb:videomode:6</userinput
>이라고 하십시오. </para>
  </sect2>
<!--   End of file boot-installer/powerpc.xml -->

<!-- Start of file boot-installer/sparc.xml -->

  <sect2 arch="sparc" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부트 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>OpenBoot 기계의 경우, 설치하려는 기계의 부트 모니터로 들어가십시오 (<xref linkend="invoking-openboot"/>). <userinput
>boot net</userinput
> 명령으로 TFTP 및 RARP 서버에서 부팅하거나 <userinput
>boot net:bootp</userinput
>나 <userinput
>boot net:dhcp</userinput
> 명령으로 TFTP와 BOOTP 혹은 DHCP 서버에서 부팅하십시오. 일부 오래된 OpenBoot 버전에서는 <userinput
>boot le()</userinput
>처럼 장치 이름을 써야 합니다; 그러한 버전에서는 BOOTP나 DHCP를 지원하지 않을 것입니다. </para>
  </sect2>


  <sect2 arch="sparc"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->

<para
>대부분의 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 것입니다. CD 세트를 가지고 있고, 기계에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="i386"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고 이 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 꾸러미를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 꾸러미를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<para
>대부분의 OpenBoot 버전은 <userinput
>boot cdrom</userinput
> 명령을 지원합니다. 그러면 SCSI 장치의 6번 ID에서 (아니면 IDE 기반 시스템의 경우 secondary master에서) 부팅합니다. 이 명령을 지원하지 않는 옛날 OpenBoot 버전에서는 실제 장치 이름을 써야 할 수도 있습니다. Sun4m에서 (예를 들어 Sparc 10s 및 Sparc 20s) CD-ROM에서 부팅할 때 문제가 발견되었습니다. </para>
  </sect2>


  <sect2 arch="sparc" condition="supports-floppy-boot">
  <title
>플로피에서 부팅하기</title>
<para
>Sparc에서 플로피에서 부팅하려면, 다음 명령을 사용하십시오: <informalexample
><screen>
Stop-A -&gt; OpenBoot: "boot floppy"
</screen
></informalexample
> 단 새로운 Sun4u (ultra) 아키텍처의 경우 플로피 부팅을 지원하지 않습니다. 보통 오류 메세지는 <computeroutput
>Bad magic number in disk label - Can't open disk label package</computeroutput
>입니다. 게다가, 많은 Sun4c 모델은 (예를 들어 IPX) 압축한 이미지를 지원하지 않고, 그래서 그러한 모델들은 지원하지 않습니다. </para
><para
>일부 Sparc에서는 (예를 들어 Ultra 10) OBP 버그때문에 부팅하지 못합니다. OBP 업데이트는 <ulink url="http://sunsolve.sun.com"
></ulink
>의 product ID 106121에서 내려받을 수 있습니다. </para
><para
>플로피에서 부팅하는 경우에 다음과 같은 메세지를 본다면 <informalexample
><screen>
Fatal error: Cannot read partition
Illegal or malformed device name
</screen
></informalexample
> 플로피 부팅을 지원하지 않는 경우일 수도 있습니다. </para>
  </sect2>

  <sect2 arch="sparc"
><title
>IDPROM 메세지</title>
<para
><quote
>IDPROM</quote
> 관련된 문제에 관한 메세지가 나오면서 부팅하지 못한다면, 펌웨어의 설정 정보가 들어 있는 NVRAM의 배터리가 방전된 경우일 수 있습니다. 자세한 정보는 <ulink url="&url-sun-nvram-faq;"
>Sun NVRAM FAQ</ulink
>를 참고하십시오. </para>
  </sect2>
<!--   End of file boot-installer/sparc.xml -->

 </sect1>


<!-- Start of file boot-installer/parameters.xml -->

 <sect1 id="boot-parms"
><title
>부팅 파라미터</title>
<para
>부팅 파라미터는 리눅스 커널 파라미터로 보통 주변 장치를 제대로 동작하도록 제어하는 데 이용합니다. 대부분 커널에서 주변 장치에 관한 정보를 자동으로 찾아 냅니다. 하지만 몇몇 경우에는 파라미터로 커널을 조금 도와줘야 합니다. </para
><para
>시스템을 첫 번째로 부팅하는 경우라면, 기본 부팅 파라미터를 시도해 보시고 (즉 파라미터를 사용하지 않는 것) 제대로 동작하는 지 보십시오. 보통은 제대로 동작할 것입니다. 제대로 동작하지 않는 경우에 다시 부팅해서 하드웨어에 필요한 특별한 파라미터가 있는 지 찾아 보십시오. </para
><para
>부팅 파라미터에 관한 정보는 <ulink url="http://www.tldp.org/HOWTO/BootPrompt-HOWTO.html"
>Linux BootPrompt HOWTO</ulink
>에 (여러가지 보기드문 하드웨어에 대한 정보 포함) 있습니다. 여기서는 몇 가지 많이 이용하는 파라미터에 대한 대략만 다룹니다. 많이 발생하는 문제점 몇 개는 <xref linkend="boot-troubleshooting"/>에 들어 있습니다. </para
><para
>커널이 부팅할 때 다음과 같은 메세지가 나와야 합니다: <informalexample
><screen>
Memory:<replaceable
>avail</replaceable
>k/<replaceable
>total</replaceable
>k available 
</screen
></informalexample
> 여기서 <replaceable
>total</replaceable
>은 전체 RAM의 크기입니다(킬로바이트 단위). 이 숫자가 실제 설치한 RAM의 용량과 다르다면, <userinput
>mem=<replaceable
>ram</replaceable
></userinput
> 파라미터를 사용해야 합니다. 여기서 <replaceable
>ram</replaceable
>은 메모리의 양이고, 킬로바이트의 경우 ``k'', 메가바이트의 경우 ``m''을 뒤에 붙입니다. 예를 들어, <userinput
>mem=65536k</userinput
>나 <userinput
>mem=64m</userinput
>은 모두 64MB의 RAM을 뜻합니다. </para
><para condition="supports-serial-console"
>시리얼 콘솔로 부팅하는 경우, 보통 자동으로 찾아냅니다. <phrase arch="mipsel"
>(DECstation에서는 아닙니다.)</phrase
> 시리얼 콘솔로 부팅하려는 컴퓨터에 비디오 카드와 (프레임버퍼) 키보드가 붙어 있다면, <userinput
>console=<replaceable
>device</replaceable
></userinput
> 파라미터를 커널에 넘겨야 할 수 있습니다. 여기서 <replaceable
>device</replaceable
>는 시리얼 장치이고, <filename
>ttyS0</filename
>과 같이 씁니다. </para
><para arch="sparc"
>&arch-title;에서 시리얼 장치는 <filename
>ttya</filename
> 혹은 <filename
>ttyb</filename
>입니다. 다른 방법으로, <envar
>input-device</envar
> 및 <envar
>output-device</envar
> OpenPROM 변수를 <filename
>ttya</filename
>로 맞출 수도 있습니다. </para>


  <sect2 id="installer-args"
><title
>데비안 설치 프로그램 파라미터</title>
<para
>설치 시스템에서는 유용하게 쓸 수도 있는 부팅 파라미터 몇 개를 더 인식합니다<footnote
> <para
> 커널에서는 최대 8개의 명령행 옵션과 8개의 환경 옵션만 사용할 수 있습니다 (설치 프로그램에서 기본으로 사용하는 옵션 포함). 이 개수가 넘어가면 2.4 커널에서는 넘어가는 파라미터를 버리고, 2.6 커널은 멎어 버립니다. <phrase condition="etch"
>커널 2.6.9 이후인 경우 32개의 명령행 옵션과 32개의 환경변수를사용할 수 있습니다.</phrase
></para
> </footnote
>. </para>

<variablelist>
<varlistentry>
<term
>debconf/priority</term>
<listitem
><para
>이보다 같거나 높은 우선순위의 메세지만 표시합니다. </para
><para
>기본 설치에서는 <userinput
>debconf/priority=high</userinput
>를 사용합니다. 즉, 높음 우선 순위와 필수 우선순위의 메세지를 표시하지만, 보통과 낮음 우선 순위 메세지는 넘어갑니다. 문제가 발생할 경우에는 설치 프로그램에서 우선순위를 필요에 따라 조정합니다. </para
><para
><userinput
>debconf/priority=medium</userinput
>을 부팅 파라미터로 쓴 경우, 설치 메뉴에서 설치 메뉴에서 더 많은 조정을 할 수 있습니다. <userinput
>debconf/priority=low</userinput
>라고 쓴 경우, 모든 메세지를 볼 수 있습니다. (<emphasis
>expert</emphasis
> 부팅 방법과 동일합니다.) <userinput
>debconf/priority=critical</userinput
>의 경우, 필수 메세지만 표시하고 질문들에 신경 쓰지 않고 설치를 진행합니다. </para
></listitem>
</varlistentry>


<varlistentry>
<term
>DEBIAN_FRONTEND</term>
<listitem
><para
>이 부팅 파라미터는 설치 프로그램에서 사용할 사용자 인터페이스 종류를 설정합니다. 현재 가능한 파라미터 값은: <itemizedlist
> <listitem
> <para
><userinput
>DEBIAN_FRONTEND=noninteractive</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=text</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=newt</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=slang</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=ncurses</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=bogl</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=gtk</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=corba</userinput
></para
> </listitem
> </itemizedlist
> 기본 프론트엔드는 <userinput
>DEBIAN_FRONTEND=newt</userinput
>입니다. 시리얼 콘솔 설치의 경우 <userinput
>DEBIAN_FRONTEND=text</userinput
>가 더 좋을 수도 있습니다. 보통 기본 설치 미디어에서는 <userinput
>newt</userinput
> 프론트엔드만 사용할 수 있기 때문에, 이 파라미터는 현재 별로 쓸모가 없습니다. </para
></listitem>
</varlistentry>


<varlistentry>
<term
>BOOT_DEBUG</term>
<listitem
><para
>           2                                         .    3                                             .(                           .) <variablelist>
<varlistentry>
<term
><userinput
>BOOT_DEBUG=0</userinput
></term>
<listitem
><para
>기본값입니다.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><userinput
>BOOT_DEBUG=1</userinput
></term>
<listitem
><para
>보통때보다 많은 디버깅 정보.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><userinput
>BOOT_DEBUG=2</userinput
></term>
<listitem
><para
>디버깅 정보 아주 많이.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><userinput
>BOOT_DEBUG=3</userinput
></term>
<listitem
><para
>부팅 과정의 곳곳에서 쉘을 실행해서 자세히 디버깅을 할 수 있습니다. 부팅을 계속하려면 쉘을 나가면 됩니다. </para
></listitem>
</varlistentry>
</variablelist>

</para
></listitem>
</varlistentry>


<varlistentry>
<term
>INSTALL_MEDIA_DEV</term>
<listitem
><para
>이 파라미터의 값은 데비안 설치 프로그램을 읽어들일 장치의 경로입니다. 예를 들어 <userinput
>INSTALL_MEDIA_DEV=/dev/floppy/0</userinput
> </para
><para
>부트 플로피는 루트 플로피를 찾으면서, 검색할 수 있는 모든 플로피와 USB 저장 장치를 검색합니다. 이 파라미터를 이용해서 장치 한 개만 검색하도록 만들 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>debian-installer/framebuffer</term>
<listitem
><para
>어떤 아키텍처에서는 커널 프레임 버퍼를 사용해 여러 가지 언어로 설치를 지원합니다. 프레임버퍼가 문제가 있는 경우 <userinput
>debian-installer/framebuffer=false</userinput
> 파리미터를 통해 프레임버퍼를 끌 수 있습니다. 문제의 증상은 bterm이나 bogl 관련된 오류 메세지, 검은 화면, 설치를 시작하고 몇 분 후에 멈추는 증상입니다. </para
><para arch="i386"
><userinput
>video=vga16:off</userinput
> 파라미터로 프레임버퍼를 끌 수도 있습니다. 그러한 문제가 Mobile Radeon 카드를 사용하는 Dell Inspiron에서 보고되었습니다. </para
><para arch="m68k"
>Amiga 1200과 SE/30에서 그러한 문제가 보고되었습니다. </para
><para arch="hppa"
>hppa에서 그러한 문제가 보고되었습니다. </para
><note arch="sparc"
><para
>일부 시스템의 화면 표시 문제때문에, &arch-title;에서는 프레임 버퍼를 <emphasis
>기본으로 지원하지 않습니다</emphasis
>. 그 때문에 ATI 그래픽 카드같은 게 있어서 프레임버퍼를 지원하는 시스템에서조차 화면 표시가 보기가 안 좋을 수도 있습니다. 설치 프로그램에서 화면 표시 문제가 발생하면, <userinput
>debian-installer/framebuffer=true</userinput
> 파라미터를 넣고 부팅해 보십시오. </para
></note
></listitem>
</varlistentry>

<varlistentry>
<term
>debian-installer/probe/usb</term>
<listitem
><para
>부팅할 때 USB 검색이 문제가 있는 경우, <userinput
>false</userinput
>로 설정해 USB 검색을 하지 않습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>netcfg/disable_dhcp</term>
<listitem
><para
>기본값으로, &d-i;는 DHCP를 통해 네트워크 설정을 검색합니다. 검색이 성공하면, 그 설정을 검사해 보거나 바꿀 기회가 없습니다. DHCP 검색이 실패할 경우에만 수동 네트워크 셋업을 할 수 있습니다. </para
><para
>랜에 DHCP 서버가 있지만 DHCP를 사용하고 싶지 않을 때 (예를 들어 잘못된 응답을 한다든지 때문에), <userinput
>netcfg/disable_dhcp=true</userinput
> 파라미터를 사용하면 DHCP 네트워크 설정을 막고 수동으로 정보를 입력할 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>hw-detect/start_pcmcia</term>
<listitem
><para
>PCMCIA에 문제가 있을 때 <userinput
>false</userinput
>로 하면 PCMCIA 서비스를 시작하지 않습니다. 일부 노트북 컴퓨터에서 이와 관련해 문제가 발생합니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>preseed/url</term>
<listitem
><para
>미리 설정해 놓은 파일을 내려받을 URL을 지정합니다. 이 파일을 이용해 설치를 자동화합니다. <xref linkend="automatic-install"/> 참고. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>preseed/file</term>
<listitem
><para
>미리 설정해 놓은 파일을 읽어들일 URL을 지정합니다. 이 파일을 이용해 자동 설치를 합니다. <xref linkend="automatic-install"/> 참고. </para
></listitem>
</varlistentry>

<varlistentry condition="etch">
<term
>cdrom-detect/eject</term>
<listitem
><para
>기본적으로 &d-i;에서는 다시 시작하기 전에 설치할 때 사용했던 광학 미디어를 자동으로 뺍니다. 시스템이 CD에서 자동으로 부팅하는 경우가 아니라면 이럴 필요가 없을 수도 있습니다. 어떤 경우에는 이렇게 하지 않는 게 좋을 때도 있습니다. 예를 들어, 해당 광학 드라이브가 미디어를 다시 집어넣지 못하는 경우나 사용자가 그 자리에 없기 때문에 수동으로 미디어를 집어넣지 못하는 경우입니다. 많은 슬롯 스타일의 드라이브는 미디어를 자동으로 다시 집어넣지 못합니다. </para
><para
>자동으로 미디어를 꺼내지 않으려면 <userinput
>false</userinput
>로 설정합니다. 단 설치한 후에 시스템이 광학 드라이브에서 자동으로 부팅하지 않도록 하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>ramdisk_size</term>
<listitem
><para
>2.2.x 커널을 사용한다면, &ramdisksize;로 설정해야 합니다. </para
></listitem>
</varlistentry>

<varlistentry condition="etch">
<term
>rescue/enable</term>
<listitem
><para
>                              <userinput
> true</userinput
>         .         <xref linkend="rescue"/>         . </para
></listitem>
</varlistentry>

</variablelist>
  </sect2>
 </sect1>

<!--   End of file boot-installer/parameters.xml -->

<!-- Start of file boot-installer/trouble.xml -->

 <sect1 id="boot-troubleshooting">
 <title
>설치 과정의 문제 해결</title>
 

  <sect2 condition="supports-floppy-boot" id="unreliable-floppies">
  <title
>플로피 디스크 신뢰성</title>

<para
>플로피 디스크를 사용해 설치하는 사람이 겪는 가장 큰 문제는 플로피 디스크 신뢰성 문제일 것입니다. </para
><para
>부트 플로피가 가장 문제가 많은 플로피입니다. 부트 플로피는 리눅스가 아니라 하드웨어에서 직접 읽어들이기 때문입니다. 가끔 하드웨어는 리눅스 플로피 디스크 드라이버가 하는 것 만큼 안정적으로 플로피를 읽지 못합니다. 또 잘못된 데이터를 읽은 경우에도 오류 메세지를 표시하지 않고 멈춰버리기도 합니다. 드라이버 플로피에서도 디스크 입출력 오류 메세지만 가득 나오는 문제가 발생하기도 합니다. </para
><para
>설치 도중에 특정 플로피에서 멈추는 현상이 발생하면, 가장 먼저 할 일은 플로피 디스크 이미지를 다시 받아서 <emphasis
>다른</emphasis
> 플로피에 만들어 보는 것입니다. 기존의 플로피를 다시 포맷하는 것만으로는 (애러 없이 포맷이 되더라도) 안 됩니다. 다른 시스템에서 플로피를 만드는 게 도움이 될 수도 있습니다. </para
><para
>어떤 사용자는 플로피가 제대로 동작할 때까지 이미지를 무려 <emphasis
>세 번</emphasis
> 써야 했다고 하고, 세 번째 플로피에서 제대로 동작했다고 합니다. </para
><para
>또 어떤 사용자는 같은 플로피를 가지고 여러 번 다시 부팅하니까 성공적으로 부팅했다고 합니다. 이러한 현상은 모두 문제가 있는 하드웨어나 펌웨어의 플로피 드라이버때문입니다. </para>
  </sect2>

  <sect2
><title
>부팅 설정</title>

<para
>문제가 생겨서 커널이 부팅 과정에서 멈추거나, 주변 장치를 인식하지 못하거나, 드라이브를 제대로 인식하지 못하거나 하는 경우, 먼저 부팅 파라미터가 <xref linkend="boot-parms"/>에 쓰여 있는 것처럼 제대로 되었는 지 확인하십시오. </para
><para
>설치 프로그램에 들어 있는 커널 대신에 직접 만든 커널로 부팅하려면, <userinput
>CONFIG_DEVFS</userinput
>를 꼭 설정하십시오. 설치 프로그램에서 <userinput
>CONFIG_DEVFS</userinput
>가 필요합니다. </para
><para
>추가 장치나 주변 기기를 없앤 다음에 다시 부팅하면 문제가 없어질 수도 있습니다. <phrase arch="i386"
>내장 모뎀, 사운드 카드 및 플러그앤플레이 장치들이 특히 문제가 많습니다.</phrase
> </para
><para
>기계에 512M 보다 더 많은 메모리가 붙어 있는 경우에 설치 프로그램의 커널이 부팅할 때 멈춘다면, 커널에 보이는 메모리 양을 제한하는 부팅 파라미터를 써야 할 수도 있습니다. 예를 들어 <userinput
>mem=512m</userinput
>과 같이 씁니다. </para>
  </sect2>

  <sect2 arch="i386" id="i386-boot-problems">
  <title
>자주 발생하는 &arch-title; 설치 문제</title>
<para
>자주 발생하는 설치 문제중에 몇 개는 설치 프로그램에 부팅 파라미터를 넘기는 방법으로 해결할 수 있습니다. </para
><para
>일부 시스템에는 ``DCL이 뒤바뀐'' 플로피가 달려 있습니다. 플로피가 문제가 없는 게 분명한데도 플로피를 읽다가 오류가 발생하면, <userinput
>floppy=thinkpad</userinput
> 파라미터를 시도해 보십시오. </para
><para
>IBM PS/1이나 ValuePoint같은 (ST-506 디스크 드라이버가 있는) 일부 시스템에서는 IDE 드라이브를 제대로 인식하지 못하기도 합니다. 먼저 파라미터 없이 IDE 드라이버를 제대로 인식하는 지 시도해 보십시오. 제대로 인식하지 못하면, 드라이브 크기를 (실린더, 헤드, 섹터) 알아보고, <userinput
>hd=<replaceable
>cylinders</replaceable
>,<replaceable
>heads</replaceable
>,<replaceable
>sectors</replaceable
></userinput
> 파라미터를 사용하십시오. </para
><para
>아주 오래된 기계에서 <computeroutput
>Checking 'hlt' instruction...</computeroutput
>라고 나오면서 커널이 멈춘다면, hlt 인스트럭션 테스트를 하지 않도록 <userinput
>no-hlt</userinput
> 파라미터를 시도해 보십시오. </para
><para
>커널이 부팅할 때 화면에 괴상한 그림이 나온다면, 예를 들어 전부 하얀 색이 되거나 전부 검은 색이 되거나 가지가지 색의 픽셀 쓰레기가 나오거나 하면, 프레임버퍼 모드로 제대로 전환하지 못하는 문제 있는 비디오 카드가 붙어 있다는 뜻입니다. 그러면 <userinput
>debian-installer/framebuffer=false</userinput
> 혹은 <userinput
>video=vga16:off</userinput
> 파라미터로 프레임버퍼 콘솔을 끌 수 있습니다. 콘솔 기능의 한계때문에 설치할 때 언어는 영어만 사용할 수 있습니다. 자세한 건 <xref linkend="boot-parms"/> 부분을 참고하십시오. </para>

  <sect3>
  <title
>PCMCIA 설정 단계에서 시스템 멈춤</title>
<para
>Dell에서 제조한 일부 노트북 모델은 PCMCIA 장치를 찾을 때 특정 하드웨어 주소에 접근하는 순간 멈춰 버립니다. 그 외의 노트북 모델도 비슷한 현상이 나타날 수 있습니다. 만약 그러한 문제가 발생하고 설치할 때 PCMCIA 기능이 필요없다면, <userinput
>hw-detect/start_pcmcia=false</userinput
> 부팅 파라미터로 PCMCIA를 끌 수 있습니다. 설치를 마친 다음에 PCMCIA를 설정해서 문제가 발생하는 구간을 제외할 수 있습니다. </para
><para
>다른 방법으로, 전문가 모드에서 설치 프로그램을 부팅할 수 있습니다. 그 다음에 하드웨어에 필요한 리소스 범위를 입력합니다. 예를 들어, 위에서 말한 Dell 노트북을 가지고 있다면, 여기서 <userinput
>exclude port 0x800-0x8ff</userinput
>라고 입력합니다. <ulink url="http://pcmcia-cs.sourceforge.net/ftp/doc/PCMCIA-HOWTO-1.html#ss1.12"
>System resource settings section of the PCMCIA HOWTO</ulink
>에 보면 리소스 범위 관련 옵션의 목록이 있습니다. 설치 프로그램에서 이 값을 입력할 때, 쉼표를 쓰지 않는다는 것에 유의하십시오. </para>
   </sect3>

   <sect3>
   <title
>USB 모듈을 읽어들이다가 시스템 멈춤</title>
<para
>일부 표준이 아닌 USB 키보드를 지원하기 위해 커널에서 USB 모듈과 USB 키보드 드라이버를 읽어들입니다. 하지만 일부 문제 있는 USB 시스템에서는 드라이버를 읽어들일 때 멈춥니다. 한 가지 방법은 메인보드의 BIOS 설정에서 USB 컨트롤러를 끄는 것입니다. 또 다른 방법은 <userinput
>debian-installer/probe/usb=false</userinput
> 파라미터를 부팅 프롬프트에 써서, USB 모듈을 읽어들이지 못하게 하는 것입니다. </para>
   </sect3>
  </sect2>

  <sect2 id="kernel-msgs">
  <title
>커널 시작 메세지 해석하기</title>

<para
>부팅 과정에서, <computeroutput
>can't find <replaceable
>something</replaceable
> </computeroutput
> 혹은 <computeroutput
> <replaceable
>something</replaceable
> not present</computeroutput
>, <computeroutput
>can't initialize <replaceable
>something</replaceable
> </computeroutput
>, 아니면 심지어는 <computeroutput
>this driver release depends on <replaceable
>something</replaceable
> </computeroutput
> 형식의 메세지를 볼 수 있을 것입니다. 이러한 메세지의 대부분은 아무런 문제를 일으키지 않습니다. 설치 시스템은 여러 가지 주변 장치가 달린 컴퓨터에서 동작하도록 만들어졌기 때문에 이런 메세지가 나옵니다. 당연히 그 어떤 컴퓨터라고 해도 모든 주변 장치를 가진 컴퓨터는 없으므로, 운영체제에서는 찾으려는 주변 장치가 없을 때 이러한 메세지를 내보냅니다. 또 시스템이 일시적으로 멈추는 현상이 일어날 수도 있습니다. 이러한 현상은 어떤 장치가 응답할 때까지 기다리는데, 그 장치가 없을 때 발생합니다. 이런 시간이 너무 오래 걸린다고 생각한다면, 나중에 직접 설정한 커널을 사용할 수 있습니다. (<xref linkend="kernel-baking"/> 참고.) </para>
  </sect2>


  <sect2 id="problem-report">
  <title
>버그 보고</title>
<para
>최초 부팅 단계를 지나갔지만 설치를 마치지 못했다면, 버그 보고 메뉴가 도움이 될 수도 있습니다. <phrase condition="sarge"
>이 메뉴는 시스템 오류 로그와 설정 정보를 사용자의 플로피에 복사합니다.</phrase
> <phrase condition="etch"
>이 메뉴는 시스템 오류 로그와 설정 정보를 설치 프로그램에서 플로피로 복사하거나, 웹브라우저로 다운로드할 수 있습니다. </phrase
> 이 정보는 무엇이 잘못되었는지 및 어떻게 고치는 지에 대한 단서가 들어 있습니다. 버그를 보고할 때 이 정보를 버그 보고에 첨부해 주십시오. </para
><para
>그 외의 설치 메세지는 설치할 때 <filename
>/var/log/</filename
>에 들어 있고, 설치된 시스템으로 부팅한 다음에는 <filename
>/var/log/debian-installer/</filename
>에 들어 있습니다. </para>
  </sect2>

  <sect2 id="submit-bug">
  <title
>설치 보고 제출</title>
<para
>그래도 문제가 있다면, 설치 리포트를 보내 주십시오. 설치가 성공했을 경우에도 설치 리포트를 보내 주시는 게 좋습니다. 그래야 사용자가 어떤 하드웨어 설정을 사용하는 지에 대한 정보를 많이 얻을 수 있습니다. </para
><para condition="etch"
>이미 동작하고 있는 데비안 시스템이 있다면, 설치 리포트를 보내는 가장 쉬운 방법은 installation-report 및 reportbug 꾸러미를 설치하고 (<command
>apt-get install installation-report reportbug</command
>) <command
>reportbug installation-report</command
> 명령을 실행하는 것입니다. </para
><para
>설치 보고서를 작성하실 때 아래 형식을 이용하시고, <classname
>installation-reports"</classname
> 꾸러미에 대한 버그를 <email
>submit@bugs.debian.org</email
>로 메일을 보내 제출해 주십시오.  <informalexample
><screen>
Package: installation-reports

Boot method: &lt;설치 프로그램을 어떻게 부팅했는지? CD? 플로피? 네트워크?&gt;
Image version: &lt;설치 이미지를 받은 날짜와 이미지를 받은 곳을 넣으십시오&gt;
Date: &lt;설치한 날짜 및 시각&gt;

Machine: &lt;기계 설명 (예, IBM Thinkpad R32)&gt;
Processor:
Memory:
Partitions: &gt;df -Tl 명령어의 결과. 파티션 테이블의 로우 정보가 좋습니다.&gt;

Output of lspci and lspci -n:

Base System Installation Checklist:
[O] = OK, [E] = Error (please elaborate below), [ ] = didn't try it

Initial boot worked:    [ ]
Configure network HW:   [ ]
Config network:         [ ]
Detect CD:              [ ]
Load installer modules: [ ]
Detect hard drives:     [ ]
Partition hard drives:  [ ]
Create file systems:    [ ]
Mount partitions:       [ ]
Install base system:    [ ]
Install boot loader:    [ ]
Reboot:                 [ ]

Comments/Problems:

&lt;설치 과정을 문장으로 설명하십시오. 그리고 처음에 설치했을 때 
      들었던 생각, 평가, 아이디어 따위도 써 주십시오.&gt;
</screen
></informalexample
> 버그 보고서에 문제가 무엇인지 설명하시고, 커널이 멈춘 경우에 마지막으로 볼 수 있는 커널 메세지를 포함하십시오. 문제가 발생할 때 어떤 과정을 거쳤는 지 설명하십시오. </para>
  </sect2>
 </sect1>
<!--   End of file boot-installer/trouble.xml -->

</chapter>
<!--   End of file boot-installer/boot-installer.xml -->
