<!-- Start of file preparing/preparing.xml -->

<chapter id="preparing">
 <title
>&debian;를 설치하기 전에</title>
<para
>이 장에서는 설치 프로그램을 부팅하기 전에 해야 할 데비안 설치 준비 사항에 대해 다룹니다. 데이터 백업, 하드웨어에 대한 정보 모으기, 기타 필요한 정보 찾기와 같은 준비를 해야 합니다. </para>


<!-- Start of file preparing/install-overview.xml -->

 <sect1 id="install-overview">
 <title
>설치 과정의 개요</title>
<para
>먼저, 시스템을 완전히 다시 설치하는 것에 대해 설명합니다. 데비안에서는 처음부터 시스템을 다시 설치해야 할 상황은 아주 드뭅니다. 다시 설치해야 하는 경우는 아마도 하드 디스크가 물리적으로 망가진 경우가 대부분일 것입니다. </para
><para
>널리 쓰이는 많은 운영체제들에서는 치명적인 문제점이 발생하거나 새로운 운영체제의 버전으로 업그레이드하려는 경우 완전히 새로 설치해야 합니다. 처음부터 완전히 새로 설치할 필요는 없다고 해도, 프로그램들이 새로운 운영 체제에서 제대로 동작하려면 프로그램들을 다시 설치해야 합니다. </para
><para
>&debian;에서는 운영체제에서 무언가 문제점이 있으면, 운영체제를 바꿔 버리는 게 아니라 바로 잡습니다. 업그레이드할 때 전부 다 설치할 필요는 없고, 항상 그 자리에서 업그레이드할 수 있습니다. 그리고 프로그램은 거의 항상 뒤의 운영체제 릴리스에서도 호환됩니다. 어떤 프로그램의 새 버전에서도 다른 소프트웨어의 새 버전이 필요한 경우라면, 데비안 꾸러미 시스템에서 필요한 소프트웨어를 모두 알아서 자동으로 설치합니다. 즉 다시 설치할 필요가 없도록 많은 노력이 들어가 있기 때문에, 처음부터 다시 설치기는 마지막 선택으로 남겨 두십시오. 설치 프로그램은 기존 시스템 위에 다시 설치하도록 설계되지 <emphasis
>않았습니다</emphasis
>. </para
><para
>다음은 설치 과정에서 해야 할 단계입니다. </para>

<orderedlist>
<listitem
><para
>설치하려는 하드 디스크에 들어 있는 데이터나 문서를 백업하십시오. </para
></listitem>
<listitem
><para
>설치를 시작하기 전에, 해당 컴퓨터에 대한 정보와 필요한 문서를 모으십시오. </para
></listitem>
<listitem
><para
>하드 디스크에 데비안에 쓸 파티션 가능한 공간을 만드십시오. </para
></listitem>
<listitem
><para
>해당 컴퓨터에 필요한 설치 프로그램 소프트웨어 및 필요한 드라이버 파일을 찾아서 내려받으십시오. (데비안 CD 사용자 제외) </para
></listitem>
<listitem
><para
>부팅 테이프/플로피/USB 스틱을 만드십시오. 혹은 부팅 파일을 저장해 놓으십시오. (데비안 CD 사용자는 대부분 데비안 CD 중 한장으로 부팅합니다) </para
></listitem>
<listitem
><para
>설치 시스템을 부팅하십시오. </para
></listitem>
<listitem arch="not-s390"
><para
>설치 언어를 선택하십시오. </para
></listitem>
<listitem arch="not-s390"
><para
>이더넷 네트워크 연결이 있으면 활성화하십시오. </para
></listitem>

<listitem arch="s390"
><para
>네트워크 인터페이스를 하나 설정하십시오. </para
></listitem>
<listitem arch="s390"
><para
>새 시스템에 ssh 연결을 여십시오. </para
></listitem>
<listitem arch="s390"
><para
>한 개 이상의 DASD를 (Direct Access Storage Device) 부착하십시오. </para
></listitem>

<listitem
><para
>데비안을 설치할 파티션을 만들고 마운트하십시오. </para
></listitem>
<listitem
><para
><firstterm
>베이스 시스템</firstterm
>의 자동 내려받기/설치/설정을 보십시오. </para
></listitem>
<listitem
><para
>데비안 그리고/혹은 기존 시스템을 시작할 수 있는 <firstterm
>부트 로더</firstterm
>를 설치하십시오. </para
></listitem>
<listitem
><para
>새로 설치한 시스템을 맨 처음 시작하고, 몇 가지 초기 시스템 설정을 하십시오. </para
></listitem>
<listitem arch="s390"
><para
>새 시스템에 ssh 연결을 여십시오. </para
></listitem>
<listitem
><para
>필요하다고 생각하는 추가 소프트웨어를 (<firstterm
>태스크</firstterm
> 및/혹은 <firstterm
>꾸러미</firstterm
>) 설치하십시오. </para
></listitem>
</orderedlist>

<para
>설치할 때 문제가 발생할 때를 대비해서, 각 단계가 어떤 꾸러미와 상관이 있는지 알아 두는 게 좋습니다. 이 설치 단계의 주요 소프트웨어들을 소개하면: </para
><para
>설치 소프트웨어인 <classname
>debian-installer</classname
>는 이 매뉴얼에서 가장 중점적으로 다룹니다. <classname
>debian-installer</classname
>는 하드웨어를 찾아서 적당한 드라이버를 읽어들이고, <classname
>dhcp-client</classname
>를 이용해 네트워크 연결을 설정하고, <classname
>debootstrap</classname
>을 실행해 베이스 시스템 꾸러미를 설치합니다. 이 외에 많은 소프트웨어들이 각 단계에서 작은 역할들을 담당하고 있지만, 새 시스템이 처음 시작하기까지 전까지는 <classname
>debian-installer</classname
>가 작업을 마칩니다. </para
><para
>베이스 시스템을 새로 시작하면, <classname
>base-config</classname
>를 통해 사용자를 추가하고, 시간대를 설정하고 (<classname
>tzsetup</classname
>을 통해), 꾸러미 설치 시스템을 설정합니다 (<classname
>apt-setup</classname
> 이용). 다음에 <classname
>tasksel</classname
>을 실행해 여러 관련된 프로그램의 모음을 선택하고, <classname
>aptitude</classname
>를 실행해 각각의 소프트웨어 꾸러미를 선택합니다. </para
><para
>맨 처음 시스템이 시작하기 전에 <classname
>debian-installer</classname
>가 끝나면, 아주 기본적인 명령행 기반 시스템만 사용할 수 있습니다. 모니터에 창이 여러 개 나오는 그래픽 인터페이스는 설치하지 않습니다. 마지막 단계에서 <classname
>tasksel</classname
>이나 <classname
>aptitude</classname
>를 이용해 따로 설치해야 합니다. 많은 &debian; 시스템과 서버에서는 그래픽 사용자 인터페이스가 전혀 필요없기 때문에 그래픽 사용자 인터페이스는 옵션입니다. </para
><para arch="not-s390"
>X 시스템은 <classname
>debian-installer</classname
>와는 완전히 다르고, 실제로는 훨씬 더 복잡합니다. X 윈도우의 설치나 X 윈도우의 문제점 해결은 이 매뉴얼이 다루는 범위를 벗어납니다. </para>
 </sect1>

<!--   End of file preparing/install-overview.xml -->

<!-- Start of file preparing/backup.xml -->

 <sect1 id="backup">
 <title
>기존 데이터를 백업하십시오!</title>
<para
>시작하기 전에, 지금 시스템에 있는 모든 파일을 백업해 두십시오. 컴퓨터에 처음으로 원래 설치된 운영체제가 아닌 운영 체제를 설치하는 거라면, &debian;의 루트로 쓸 디스크를 다시 파티션해야 합니다. 디스크를 파티션하면 파티션 프로그램으로 어떤 프로그램을 사용하든 간에 그 디스크에 있는 모든 파일을 잃어버리게 됩니다. 설치에 사용하는 프로그램은 상당히 안정적이고 수년동안 사용해 온 프로그램이지만, 그만큼 강력하기도 해서 조금만 잘못하면 막심한 손해가 발생합니다. 백업을 한 뒤에도 대답을 할 때나 어떤 작업을 할 때 신중을 기하십시오. 2분만 더 생각하면 수 시간의 불필요한 작업을 방지할 수 있습니다. </para
><para
>멀티 부팅 시스템을 만든다면, 현재 운영 체제의 배포 미디어를 가지고 있으십시오. 특히 부팅 드라이브를 다시 파티션하는 경우라면, 운영 체제의 부트 로더를 다시 설치해야 할 수도 있고, 더 많은 경우에 운영 체제 전체를 해당 파티션에 다시 설치해야 합니다. </para>

<para arch="m68k"
>BVM과 Motorola VMEbus 컴퓨터를 제외하면 m68k 시스템에서 지원하는 유일한 설치 방법은, AmigaOS/TOS/MacOS기반 부트스트랩을 이용해 로컬 디스크 혹은 플로피 디스크에서 부팅하는 것입니다. 이 시스템에서 리눅스를 부팅하려면 원래 운영 체제를 가지고 있어야 합니다. BVM과 Motorola VMEbus 기계에서는  <quote
>BVMBug</quote
> 혹은 <quote
>16xBug</quote
> 부트롬을 사용합니다. </para>

 </sect1>
<!--   End of file preparing/backup.xml -->

<!-- Start of file preparing/needed-info.xml -->

 <sect1 id="needed-info">
 <title
>필요한 정보</title>

  <sect2>
  <title
>문서</title>

   <sect3>
   <title
>설치 매뉴얼</title>

<para condition="for_cd"
>지금 읽고 있는 문서로, 일반 텍스트, HTML, 혹은 PDF 형식 </para>

<itemizedlist condition="for_cd"
>&list-install-manual-files; </itemizedlist>

<para condition="for_wdo"
>지금 읽고 있는 이 문서는 <ulink url="&url-release-area;/installmanual"
>다양한 형식과 번역</ulink
>으로 구할 수 있는 데비안 릴리즈 &releasename;의 설치 가이드의 공식 버전입니다. </para>

<para condition="for_alioth"
>지금 읽고 있는 이 문서는 <ulink url="&url-d-i-alioth-manual;"
>다양한 형식과 번역</ulink
>으로 구할 수 있는 데비안의 다음  릴리즈를 위한  설치 가이드의 개발 버전입니다. </para>

</sect3>


   <sect3
><title
>하드웨어 문서</title>
<para
>하드웨어를 설정하고 이용하는 법에 관한 유용한 정보가 들어있습니다. </para>

 <!-- We need the arch dependence for the whole list to ensure proper xml
      as long as not architectures have a paragraph -->
 <itemizedlist arch="i386;m68k;alpha;sparc;mips;mipsel">
<listitem arch="i386"
><para>

<ulink url="&url-hardware-howto;"
>리눅스 하드웨어 호환성 HOWTO</ulink>

</para
></listitem>

<listitem arch="m68k"
><para>

<ulink url="&url-m68k-faq;"
>Linux/m68k FAQ</ulink>

</para
></listitem>

<listitem arch="alpha"
><para>

<ulink url="&url-alpha-faq;"
>Linux/Alpha FAQ</ulink>

</para
></listitem>

<listitem arch="sparc"
><para>

<ulink url="&url-sparc-linux-faq;"
>Linux for SPARC Processors FAQ</ulink>

</para
></listitem>

<listitem arch="mips;mipsel"
><para>

<ulink url="&url-linux-mips;"
>Linux/Mips 웹사이트</ulink>

</para
></listitem>

</itemizedlist>
   </sect3>


   <sect3 arch="s390">
   <title
>&arch-title; 하드웨어 참고서</title>
<para
>커널 2.4를 사용한 리눅스 설치 방법 및 장치 드라이버 (DASD, XPRAM, 콘솔, 테이프, z90 crypto, chandev, 네트워크) </para>

<itemizedlist>
<listitem
><para>

<ulink url="http://oss.software.ibm.com/developerworks/opensource/linux390/docu/l390dd08.pdf"
>장치 드라이버 및 설치 명령어</ulink>

</para
></listitem>
</itemizedlist>

<para
>IBM Redbook, zSeries 및 &arch-title; 하드웨어에서 z/VM에 리눅스를 쓰는 방법을 설명합니다 </para>

<itemizedlist>
<listitem
><para>

<ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg244987.pdf"
>&arch-title;용 리눅스</ulink>

</para
></listitem>
</itemizedlist>

<para
>메인프레임용 리눅스 배포판에 대해 설명하는 IBM Redbook입니다. Redbook에는 데비안에 관한 내용이 들어 있지 않지만 기본적인 설치 방법은 모든 &arch-title; 배포판에서 똑같습니다. </para>

<itemizedlist>
<listitem
><para>

<ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg246264.pdf"
>Linux for IBM eServer zSeries and &arch-title;: Distributions</ulink>

</para
></listitem>
</itemizedlist>
   </sect3>

  </sect2>

  <sect2 id="fsohi">
  <title
>하드웨어 정보가 있는 곳 찾기</title>
<para
>보통은 설치 프로그램에서 자동으로 하드웨어를 찾아 냅니다. 하지만 철저히 준비하려면, 설치하기 전에 하드웨어에 대해 잘 알아 두는 게 좋습니다. </para
><para
>하드웨어 정보는 다음에서 얻을 수 있습니다: </para>

<itemizedlist>
<listitem
><para
>하드웨어에 같이 들어 있는 설명서. </para
></listitem>
<listitem
><para
>컴퓨터의 BIOS 설정 화면. 컴퓨터가 시작할 때 어떤 키 조합을 누르면 BIOS 설정 화면을 볼 수 있습니다. 보통 <keycap
>Delete</keycap
> 키입니다. </para
></listitem>
<listitem
><para
>하드웨어의 케이스 및 포장. </para
></listitem>

<listitem arch="i386"
><para
>Windows 제어판의 시스템 창. </para
></listitem>
<listitem
><para
>파일 관리자에서 표시하는 것 등과 같은, 다른 운영체제의 시스템 명령어 및 시스템 도구들. 특히 RAM과 하드 드라이브에 대한 정보를 알아내는 데 유용합니다. </para
></listitem>
<listitem
><para
>시스템 관리자 혹은 인터넷 서비스 회사. 여기서는 네트워크 및 전자메일 설정에 관련된 사항을 알 수 있습니다. </para
></listitem>
</itemizedlist>

<para>

<table>
<title
>설치하는 데 필요한 하드웨어 정보</title>
<tgroup cols="2">
<thead>
<row>
  <entry
>하드웨어</entry
><entry
>필요할 수도 있는 정보</entry>
</row>
</thead>

<tbody>
<row arch="not-s390">
  <entry morerows="5"
>하드 드라이브</entry>
  <entry
>용량이 얼마나 되는 지.</entry>
</row>
<row arch="not-s390"
><entry
>시스템에 붙어 있는 순서.</entry
></row>
<row arch="not-s390">
  <entry
>IDE인지 SCSI인지 (대부분의 컴퓨터는 IDE입니다).</entry>
</row>
<row arch="not-s390"
><entry
>사용 가능한 빈 공간.</entry
></row>
<row arch="not-s390"
><entry
>파티션.</entry
></row>
<row arch="not-s390">
  <entry
>다른 운영 체제가 설치되어 있는 파티션.</entry>
</row>

<row arch="not-s390">
  <entry morerows="5"
>모니터</entry>
  <entry
>모델 및 제조사.</entry>
</row>
<row arch="not-s390"
><entry
>지원하는 해상도.</entry
></row>
<row arch="not-s390"
><entry
>가로 출력 주파수.</entry
></row>
<row arch="not-s390"
><entry
>세로 출력 주파수.</entry
></row>
<row arch="not-s390">
  <entry
>지원하는 색상수.</entry>
</row>
<row arch="not-s390"
><entry
>화면 크기.</entry
></row>

<row arch="not-s390">
  <entry morerows="3"
>마우스</entry>
  <entry
>종류: 시리얼, PS/2, 혹은 USB.</entry>
</row>
<row arch="not-s390"
><entry
>포트.</entry
></row>
<row arch="not-s390"
><entry
>제조사.</entry
></row>
<row arch="not-s390"
><entry
>단추 개수.</entry
></row>

<row arch="not-s390">
  <entry morerows="1"
>네트워크</entry>
  <entry
>모델 및 제조사.</entry>
</row>
<row arch="not-s390"
><entry
>어댑터 종류.</entry
></row>

<row arch="not-s390">
  <entry morerows="1"
>프린터</entry>
  <entry
>모델 및 제조사.</entry>
</row>
<row arch="not-s390"
><entry
>지원하는 인쇄 해상도.</entry
></row>

<row arch="not-s390">
  <entry morerows="2"
>비디오 카드</entry>
  <entry
>모델 및 제조사.</entry>
</row>
<row arch="not-s390"
><entry
>비디오 RAM 크기.</entry
></row>
<row arch="not-s390">
  <entry
>지원하는 해상도 및 색상수 (모니터에서도 지원하는 지 확인해야 합니다).</entry>
</row>

<row arch="s390">
  <entry morerows="1"
>DASD</entry>
  <entry
>장치 번호.</entry>
</row>
<row arch="s390"
><entry
>사용 가능한 빈 공간.</entry
></row>

<row arch="s390">
  <entry morerows="2"
>네트워크</entry>
  <entry
>어댑터 종류.</entry>
</row>
<row arch="s390"
><entry
>장치 번호.</entry
></row>
<row arch="s390"
><entry
>OSA 카드의 상대 어댑터 번호.</entry
></row>

</tbody
></tgroup
></table>

</para>
  </sect2>

  <sect2>
  <title
>하드웨어 호환성</title>

<para
>많은 유명 제품들에서 아무 문제없이 리눅스가 동작합니다. 또 리눅스용 하드웨어가 날이 갈 수록 발전하고 있습니다. 하지만 아직도 리눅스는 다른 운영체제만큼 다양한 종류의 하드웨어에서 동작하지는 못합니다. </para
><para arch="i386"
>특히 Windows가 있어야 동작하는 하드웨어는 리눅스에서 이용하지 못합니다. </para
><para arch="i386"
>일부의 Windows 전용 하드웨어는 리눅스에도 쓸 수 있긴 하지만, 보통 추가적인 노력이 필요합니다. 게다가 Windows 전용 하드웨어의 리눅스 드라이버는 보통 한 개의 리눅스 커널 버전에서만 쓸 수 있습니다. 그래서 그러한 드라이버는 금방 사용할 수 없게 됩니다. </para
><para arch="i386"
>이른바 win-modem은 그러한 가장 전형적인 하드웨어입니다. 프린터와 그 외의 장치도 윈도우 전용이 있습니다. </para
><para
>다음 방법으로 하드웨어 호환성을 알아볼 수 있습니다: <itemizedlist>
<listitem
><para
>제조사의 웹사이트에서 새 드라이버 확인하기. </para
></listitem>
<listitem
><para
>웹사이트와 매뉴얼에서 에뮬레이션에 대한 정보 찾아보기. 덜 알려진 상표의 제품이 더 많이 알려진 제품의 드라이버와 설정들을 그대로 사용하기도 합니다. </para
></listitem>
<listitem
><para
>해당 아키텍처에 관한 웹사이트에서 리눅스 하드웨어 호환성 목록 확인. </para
></listitem>
<listitem
><para
>인터넷에서 다른 사용자의 사용담 검색해 보기. </para
></listitem>
</itemizedlist>

</para>
  </sect2>

  <sect2>
  <title
>네트워크 설정</title>

<para
>컴퓨터가 하루 24시간 내내 네트워크에 연결되어 있다면 (이더넷이나 그같은 연결의 경우 &mdash; PPP 아님), 네트워크 시스템 관리자에게 이러한 정보를 알아봐야 합니다. <itemizedlist>
<listitem
><para
>호스트 이름 (직접 결정할 수도 있습니다). </para
></listitem>
<listitem
><para
>도메인 이름. </para
></listitem>
<listitem
><para
>컴퓨터의 IP 주소. </para
></listitem>
<listitem
><para
>네트워크에 사용할 네트마스크. </para
></listitem>
<listitem
><para
>라우팅하는 데 쓸 기본 게이트웨이 시스템의 IP 주소 (게이트웨이가 <emphasis
>있는 경우</emphasis
>). </para
></listitem>
<listitem
><para
>네트워크에서 DNS (Domain Name Service) 서버로 사용할 시스템. </para
></listitem>
</itemizedlist>

</para
><para condition="supports-dhcp"
>한편 관리자가 DHCP 서버를 사용할 수 있다고 하고 DHCP 서버 사용을 추천한다고 하면, 이 정보가 필요 없습니다. 설치할 때 DHCP 서버에서 컴퓨터에 이 정보를 알려줍니다. </para
><para
>무선 네트워크를 사용한다면, 다음도 알아봐야 합니다: <itemizedlist>
<listitem
><para
>무선 네트워크의 ESSID. </para
></listitem>
<listitem
><para
>WEP 보안 키 (보안 키를 사용하는 경우). </para
></listitem>
</itemizedlist>

</para>
  </sect2>

 </sect1>
<!--   End of file preparing/needed-info.xml -->

<!-- Start of file preparing/minimum-hardware-reqts.xml -->

 <sect1 id="minimum-hardware-reqts">
<title
>최소 하드웨어 요구사항 맞추기</title>
<para
>컴퓨터의 하드웨어에 대한 정보를 모았으면, 설치하려는 방법대로 그 하드웨어에서 설치할 수 있는 지 확인하십시오. </para
><para arch="not-s390"
>필요에 따라서는, 아래의 표에 나온 하드웨어보다 성능이 떨어지는 하드웨어로도 설치할 수 있을 수도 있습니다. 하지만 아래 제안을 무시할 경우 대부분 사용자들은 짜증나는 문제를 겪게 됩니다. </para
><para arch="i386"
>데스크탑은 최소 Pentium 100, 서버는 최소 Pentium II-300을 추천합니다. </para
><para arch="m68k"
>m68k에서 설치할 때는 68030이나 그보다 상위 프로세서를 추천합니다. 보기보다 약간 더 적은 드라이브 공간으로 설치할 수도 있습니다. </para
><para arch="powerpc"
>OldWorld 혹은 NewWorld PowerPC는 데스크탑 시스템으로 쓸 수 있습니다. 서버로 쓰려면 최소 132 Mhz 기계를 추천합니다. </para>

<table>
<title
>추천하는 최소 시스템 요구사항</title>
<tgroup cols="3">
<thead>
<row>
  <entry
>설치 종류</entry
><entry
>RAM</entry
><entry
>하드 드라이브</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>데스크탑 없음</entry>
  <entry
>24메가바이트</entry>
  <entry
>450메가바이트</entry>
</row
><row>
  <entry
>데스크탑 포함</entry>
  <entry
>64메가바이트</entry>
  <entry
>1기가바이트</entry>
</row
><row>
  <entry
>서버</entry>
  <entry
>128메가바이트</entry>
  <entry
>4기가바이트</entry>
</row>

</tbody
></tgroup
></table>

<para
>많이 쓰이는 데비안 시스템의 예제입니다. <xref linkend="tasksel-size-list"/>에 보면 관련된 프로그램들이 차지하는 디스크 공간이 얼마나 되는 지 대략 알 수 있습니다. </para>
<variablelist>

<varlistentry>
 <term
>표준 서버</term>
 <listitem
><para
>작은 서버 프로파일입니다. 쉘 사용자들이 쓰는 여러가지 프로그램들이 없는, 용량을 줄인 서버에 씁니다. FTP 서버, 웹 서버, DNS, NIS, POP 서버가 들어 있습니다. 100MB의 디스크 공간이면 충분하고, 추가로 서비스하려는 데이터에 필요한 공간이 더 필요합니다. </para
></listitem>
</varlistentry>

<varlistentry arch="not-s390">
 <term
>데스크탑</term>
 <listitem
><para
>표준 데스크탑 컴퓨터로, X 윈도우 시스템, 완전한 데스크탑 환경, 사운드, 문서 편집기 등이 들어 있습니다. 표준 데스크탑 태스크를 설치하면 약 2GB가 필요하지만, 그보다 적은 용량으로도 가능합니다. </para
></listitem>
</varlistentry>

<varlistentry arch="not-s390">
 <term
>작업용 콘솔</term>
 <listitem
><para
>크기를 더 줄인 사용자 컴퓨터로, X 윈도우 시스템이나 X 프로그램이 없습니다. 노트북이나 휴대용 컴퓨터에도 적합합니다. 크기는 약 140MB입니다. </para
></listitem>
</varlistentry>

<varlistentry>
 <term
>개발자</term>
 <listitem
><para
>Perl, C, C++ 등과 같은 모든 개발용 꾸러미들이 들어 있는 데스크탑. 크기는 약 475MB입니다. X11과 그 외에 추가 꾸러미를 더 설치한다고 하면, 이런 컴퓨터에는 약 800MB를 확보해 놓아야 합니다. </para
></listitem>
</varlistentry>

</variablelist
><para
>이 점을 기억해 두십시오. 위의 용량은 사용자의 파일, 메일, 데이터 따위의 기타 자료들을 포함한 게 아닙니다. 자기만의 파일과 데이터에 필요한 공간을 생각할 때는 항상 넉넉하게 하는 게 좋습니다. 특히, <filename
>/var</filename
> 파티션에는 여러 가지 데비안의 상태 정보와 로그 파일같은 일반적인 데이터들이 들어 있습니다. <command
>dpkg</command
> 파일들은 (설치 꾸러미에 대한 정보를 합쳐서) 간단히 20MB를 차지합니다. 또, <command
>apt-get</command
>은 설치하기 전에 내려 받은 꾸러미를 여기에 저장합니다. 보통 <filename
>/var</filename
>에 최소 100MB를 확보해 놓아야 합니다. </para>

 </sect1>

<!--   End of file preparing/minimum-hardware-reqts.xml -->

<!-- Start of file preparing/non-debian-partitioning.xml -->

 <sect1 id="non-debian-partitioning">
 <title
>멀티 부팅 시스템에서 미리 파티션하기</title>
<para
>디스크를 파티션은 디스크를 여러 개의 조각으로 나누는 작업을 말합니다. 각 조각들은 다른 조각과 독립적입니다. 비유 하자면 집에 벽을 놓는 것과 비슷합니다. 어떤 방에 가구를 놓는다고 해서 다른 방에 영향을 끼치지 않습니다. </para
><para arch="s390"
>여기서 <quote
>디스크</quote
>에 관해 이야기할 때에는, &arch-title;에 있는 DASD나 VM 미니디스크를 말한다고 해석해야 합니다. 또 이 경우 기계라고 할 때는 LPAR이나 VM guest를 말합니다. </para
><para
>시스템에 이미 다른 운영 체제가 들어 있고 <phrase arch="i386"
> (Windows 9x, Windows NT/2000/XP, OS/2, MacOS, Solaris, FreeBSD, &hellip;) </phrase
> <phrase arch="alpha"
> (Tru64 (Digital UNIX), OpenVMS, Windows NT, FreeBSD, &hellip;) </phrase
> <phrase arch="s390"
> (VM, z/OS, OS/390, &hellip;) </phrase
> <phrase arch="m68k"
> (Amiga OS, Atari TOS, Mac OS, &hellip;) </phrase
> 같은 디스크에 리눅스도 설치하려는 경우에는 디스크를 다시 파티션해야 합니다. 데비안은 데비안만의 디스크 파티션이 따로 있어야 합니다. 데비안은 Windwos나 MacOS 파티션에 설치할 수 없습니다. 다른 리눅스 시스템과는 일부 파티션을 공유할 수도 있지만, 여기서는 그 방법에 대해 다루지 않습니다. 최소한 데비안 루트에 사용할 전용 파티션이 하나 있어야 합니다. </para
><para
>현재 파티션 상태는 <phrase arch="i386"
>fdisk나 PartitionMagic같은</phrase
><phrase arch="powerpc"
>Drive Setup이나 HD Toolkit이나 MacTools같은</phrase
><phrase arch="m68k"
>HD SC Setup이나 HDToolBox나 SCSITool같은</phrase
><phrase arch="s390"
> VM diskmap같은</phrase
> 현재 운영 체제에 들어 있는 파티션 도구를 이용해 알아볼 수 있습니다. 모든 파티션 도구는 파티션을 바꾸지 않고도 현재 파티션을 보기만 할 수 있습니다. </para
><para
>이미 파일 시스템이 들어 있는 파티션을 바꾸면 보통 거기에 들어 있는 정보가 모두 망가집니다. 그러므로 파티션 작업을 하기 하기 전에 항상 백업을 만들어야 합니다. 집의 경우에 비유하자면, 벽을 옮기기 전에 모든 가구를 다른 곳에 옮겨 놓아야 가구가 망가지지 않을 겁니다. </para
><para arch="hppa" condition="FIXME">

<emphasis
>FIXME: write about HP-UX disks?</emphasis>

</para
><para
>컴퓨터에 하드 디스크가 여러 개 있으면, 어떤 한 하드 디스크 전체에 데비안을 설치할 경우가 있습니다. 그러한 경우에는 설치 시스템을 부팅하기 전에 디스크를 미리 파티션할 필요가 없습니다. 설치 프로그램에 포함된 파티션 프로그램이 파티션 작업을 훌륭하게 처리합니다. </para
><para
>컴퓨터에 하드 디스크가 1개 있고, 지금 운영 체제를 &debian;으로 완전히 덮어 쓰려고 한다면, 설치 시스템을 부팅한 다음에 설치하는 과정에서 파티션을 할 수도 있습니다 (<xref linkend="partman"/>). 하지만 설치 시스템을 테이프에서 부팅하거나 CD-ROM에서 부팅하거나 연결되어 있는 다른 기계에 dlTsms 파일에서 부팅할 경우에만 이렇게 할 수 있습니다. 생각해 보면 하드 디스크에 부팅 파일을 넣고 같은 그 하드 디스크를 파티션해 버린다면, 기존에 있던 부팅 파일들이 지워질 수밖에 없고, 반드시 한 번에 설치를 성공적으로 해야 좋을 것입니다. 최소한 이러한 경우, 원래 운영체제의 설치 테이프나 CD같은 걸로 컴퓨터를 복구할 방법을 가지고 있는 게 좋습니다. </para
><para
>컴퓨터에 파티션이 여러 개 있다면, 그리고 파티션을 지워서 충분한 공간이 나온다면 기다렸다가 데비안 설치 프로그램의 파티션 프로그램을 사용할 수 있습니다. 이 경우에도 아래의 내용을 읽어야 특별한 상황에 대처할 수 있습니다. 예를 들어 파티션에서 기존 파티션의 순서때문에 설치 전에 파티션해야 할 수도 있습니다. </para
><para arch="i386"
>컴퓨터에 DOS나 Windows에서 사용하는 FAT나 NTFS 파일 시스템이 있으면, 데비안 설치 프로그램의 파티션 프로그램을 이용해서 파일시스템 크기를 조정할 수 있습니다. </para
><para
>위의 경우 중 아무것도 아니라면, 데비안에 파티션 가능한 공간을 만들기 위해 설치 전에 파티션을 해야 합니다. 다른 운영체제가 들어 있는 파티션이 들어 있으면, 원래 운영 체제 프로그램의 파티션 프로그램을 이용해 파티션해야 합니다. 다른 운영 체제의 도구로 &debian;의 파티션을 만들지 <emphasis
>않기를</emphasis
> 권장합니다. 그 대신 계속 유지하려는 원래 운영 체제의 파티션만 만들어야 합니다. </para
><para
>같은 기계에 여러 개의 운영 체제를 설치하려는 경우, 리눅스를 설치하기 전에 다른 운영체제를 먼저 설치해야 합니다. Windows 및 다른 운영 체제를 설치하면 리눅스를 시작하지 못하게 될 수도 있고, 설치 과정에서 그 운영체제의 전용 파티션이 아닌 파티션을 다시 포맷하라고 할 수도 있습니다. </para
><para
>이런 동작들은 복구할 수도 있고, 피할 수 있습니다. 하지만 원래 운영체제를 먼저 설치하면 이런 문제가 없습니다. </para
><para arch="powerpc"
>OpenFirmware에서 &debian;을 자동으로 부팅하도록 하려면, 리눅스 파티션이 해당 디스크의 다른 파티션보다, 특히 MacOS 부팅 파티션보다 앞에 있어야 합니다. 미리 파티션할 때 다음을 염두에 둬야 합니다. 디스크의 다른 부팅 가능 파티션보다 앞 쪽 위치에 리눅스 파티션이 들어갈 파티션을 만드십시오. (Apple 디스크 드라이버 전용 작은 파티션은 부팅 가능하지 않습니다.) 실제 설치할 때 리눅스 파티션 도구를 이용해 그 위치에 리눅스 파티션을 만들 수 있습니다. </para
><para
>파티션이 1개인 하드 디스크가 1개 있고 (일반적인 데스크탑 컴퓨터), 원래 운영 체제와 데비안을 멀티 부팅하는 경우, 다음과 같이 해야 합니다: <orderedlist>
<listitem
><para
>컴퓨터에 들어 있는 것을 전부 백업하십시오. </para
></listitem>
<listitem
><para
>CD-ROM이나 테이프같은 원래 운영 체제의 설치 미디어에서 부팅하십시오. <phrase arch="powerpc"
>MacOS CD에서 부팅할 때, CD에서 MacOS 시스템을 시작하려면 부팅하는 동안 <keycap
>c</keycap
> 키를 누르고 있으십시오.</phrase
> </para
></listitem>
<listitem
><para
>원래 운영체제에 들어 있는 파티션 도구로 그 운영체제용 시스템 파티션을 만드십시오. &debian;으로 사용할 위치에 파티션을 만들거나 빈 공간을 만들어 놓으십시오. </para
></listitem>
<listitem
><para
>새 파티션에 원래 운영 체제를 설치하십시오. </para
></listitem>
<listitem
><para
>원래 운영체제로 돌아가서 제대로 되었는지 확인하고, 데비안 설치 프로그램의 부팅 파일들을 내려 받으십시오. </para
></listitem>
<listitem
><para
>데비안 설치 프로그램으로 부팅해 데비안 설치를 계속하십시오. </para
></listitem>
</orderedlist>

</para>


<!-- Start of file preparing/nondeb-part/alpha.xml -->


  <sect2 arch="alpha"
><title
>Tru64 UNIX에서 파티션하기</title>
<para
>Tru64 UNIX는 (예전 이름은 Digital UNIX이고, 그 다음에는 OSF/1이었습니다) BSD `디스크 레이블'과 비슷한 파티션 방식을 사용하는데, 이 방식은 각 디스크 드라이브마다 8개까지의 파티션을 만들 수 있습니다. 이 파티션은 리눅스에서는 <quote
>1</quote
>부터 <quote
>8</quote
>까지 번호를 붙이고 UNIX에서는 <quote
>a</quote
>에서 <quote
>h</quote
>까지 글자를 붙입니다. 리눅스 커널 2.2 이상의 버전에서는 <quote
>1</quote
>이 <quote
>a</quote
>에 해당하고, <quote
>2</quote
>가 <quote
>b</quote
>에 해당하는 식입니다. 예를 들어 Tru64 UNIX에서 <filename
>rz0e</filename
>는 리눅스에서는 <filename
>sda5</filename
>라고 합니다. </para
><para
>Tru64 디스크 레이블에서 파티션이 겹칠 수도 있습니다. 게다가 디스크를 Tru64에서 사용하는 경우, 전체 디스크에 걸쳐 있는 <quote
>c</quote
> 파티션이 필요합니다. (즉 비어 있지 않은 다른 모든 파티션과 겹칩니다.) 그것 때문에 리눅스에서는 <filename
>sda3</filename
>가 <filename
>sda</filename
>와 동일합니다. (<filename
>sdb3</filename
>은 <filename
>sdb</filename
>와 같고 기타 등등) 하지만 &d-i;에서 사용하는 partman 파티션 도구는 현재로선 겹치는 파티션을 처리하지 못합니다. 그래서 Tru64와 데비안 사이에 디스크를 같이 쓰지 않기를 권장합니다. Tru64의 파티션은 설치가 끝난 다음에 데비안에서 마운트할 수 있습니다. </para
><para
>전통적으로 필요한 또 한 가지는, <quote
>a</quote
> 파티션이 디스크의 맨 처음에서 시작한다는 것입니다. 그래서 이 파티션은 디스크 레이블에서 부팅 블럭을 포함합니다. 그 디스크에서 데비안을 부팅하려고 한다면, 이 파티션의 크기를 최소 2MB로 늘려야 aboot와 (아마도) 커널이 들어갈 수 있습니다. 이 파티션은 호환성을 위해서만 필요합니다. 여기에는 파일 시스템을 넣으면 안 됩니다. 여기에 파일 시스템을 넣으면 데이터가 망가집니다. </para
><para
>UNIX와 리눅스 사이에 스왑 파티션을 공유하는 게 가능하고, 공유하는 게 좋습니다. 이 경우 UNIX에서 리눅스로 부팅할 때마다 <command
>mkswap</command
> 명령을 실행해야합니다. UNIX에서 리눅스 스왑 시그너처를 망가뜨리기 때문입니다. <command
>swapon -a</command
> 명령으로 스왑 공간을 추가하기 전에 시작 스크립트에서 <command
>mkswap</command
>을 실행해야 합니다. </para
><para
>리눅스에서 UNIX 파티션을 마운트하려면, Digital UNIX는 UFS와 AdvFS 두 종류의 파일 시스템을 사용할 수 있다는 점을 알아 두십시오. 이 중에서 리눅스는 UFS 파일시스템만 이해합니다. </para>
  </sect2>

  <sect2 arch="alpha"
><title
>Windows NT에서 파티션하기</title>

<para
>Windows NT는 PC 방식 파티션 테이블을 사용합니다. 기존 FAT 혹은 NTFS 파티션을 변경하는 경우에는, Windows NT에 들어 있는 프로그램을 이용하길 권장합니다. (아니면 더 편하게 AlphaBIOS 설정 메뉴에서 디스크 파티션)  아니면, 꼭 Windows에서 디스크를 파티션할 필요는 없습니다. 보통 리눅스의 파티션 프로그램들이 더 잘 동작합니다. NT를 쓰는 경우, Disk Administrator에서는 Windows가 아닌 디스크가 있을 때 <quote
>harmless signature</quote
>를 쓰라고 할 수 있습니다. <emphasis
>절대 하지 마십시오.</emphasis
> 이 시그너처때문에 파티션 정보가 망가질 수 있습니다. </para
><para
>ARC/AlphaBIOS/ARCSBIOS 콘솔에서 리눅스를 부팅하려면, MILO에 필요한 (작은) FAT 파티션이 필요합니다. 5MB면 충분합니다. Windows NT를 설치한 경우, 6MB의 부트스트랩 파티션을 이 목적으로 쓸 수 있습니다. 데비안 &releasename; 릴리스는 MILO 설치를 지원하지 않습니다. 시스템에 MILO가 이미 설치되어 있거나, 다른 미디어에서 MILO를 설치하는 경우에도, ARC에서 데비안을 부팅할 수 있습니다. </para>
  </sect2>
<!--   End of file preparing/nondeb-part/alpha.xml -->

<!-- Start of file preparing/nondeb-part/i386.xml -->


  <sect2 arch="i386"
><title
>DOS나 Windows에서 파티션하기</title>
<para
>기존 FAT나 NTFS 파티션을 변경하는 경우에는, 아래의 방법을 사용하거나 Windows나 DOS에 들어 있는 도구를 이용하십시오. 그 외의 경우에는 DOS나 Windows에서 파티션할 필요는 없습니다. 보통 리눅스 파티션 도구가 더 좋습니다. </para
><para
>큰 IDE 디스크에서, LBA 주소나 오버레이 드라이버나 (하드 디스크 제조사에서 제공하기도 함) 큰 디스크 접근 확장 기능을 지원하는 새로운 (1998년 후) BIOS를 사용하지 않는 경우에는 데비안 부팅 파티션 위치를 잘 잡아야 합니다. 이런 경우 부팅 파티션을 하드 드라이브의 첫 번째 1024실린더 안에 놓아야 합니다 (보통 BIOS에서 변환하지 않은 용량으로 약 524 메가바이트입니다). 이렇게 하려면 기존 FAT나 NTFS 파티션을 옮겨야 할 수도 있습니다. </para>

   <sect3 id="lossless">
   <title
>DOS나 Win-32나 OS/2에서 시작할 때 데이터 손실없이 다시 파티션하기 </title>

<para
>설치할 때 가장 많은 경우는 이미 DOS (Windows 3.1 포함), Win32 (Windows 95, 98, Me, NT, 2000, XP), 혹은 OS/2와 같은 시스템이 들어 있고, 이전의 시스템을 망가뜨리지 않고 같은 디스크에 데비안을 설치하려는 경우입니다. DOS나 Windows에서 사용하는 FAT와 NTFS 파일시스템의 크기를 조정하는 기능이 설치 프로그램에 들어 있습니다. 설치 프로그램에서 <menuchoice
> <guimenuitem
>수동으로 파티션 테이블 편집</guimenuitem
> </menuchoice
> 옵션을 선택하고 크기를 조정하려는 파티션을 선택하고 새로운 크기를 지정하십시오. 이렇게 하면 대부분 아래에 설명한 방법을 쓰지 않아도 됩니다. </para
><para
>계속 진행하기 전에, 디스크를 어떻게 나눌 지 결정해야 합니다. 여기에 쓰여 있는 방법은 파티션을 두 개로 나누는 것 뿐입니다. 한 파티션에는 원래 OS가 들어 있고, 다른 파티션에 데비안이 들어 있습니다. 데비안을 설치할 때 데비안이 사용하는 디스크 부분을 어떻게 사용할 지 (스왑이나 파일 시스템) 결정하는 부분이 있습니다. </para
><para
>지금 하려는 일은 파티션 정보를 바꾸기 전에 그 안의 모든 데이터를 앞쪽으로 옮기는 것입니다. 그래야 아무것도 잃지 않습니다. 가능하면 데이터 이동과 파티션을 조금 하는 게 중요합니다. 그래야 파일이 파티션 끝 부분에 들어 있지 않게 됩니다. 끝 부분에 파일이 들어가면 그 파티션에서 뽑아낼 수 있는 공간이 줄어듭니다. </para
><para
>먼저 필요한 건 데비안 미러 사이트에서 <filename
>tools/</filename
> 디렉토리에 있는 <command
>fips</command
> 프로그램입니다. 압축 파일을 풀고 <filename
>RESTORRB.EXE</filename
>, <filename
>FIPS.EXE</filename
>, <filename
>ERRORS.TXT</filename
> 파일을 부팅 가능 플로피에 넣으십시오. 부팅 가능 플로피는 DOS에서 <filename
>sys a:</filename
> 명령으로 만듭니다. <command
>fips</command
>에는 아주 좋은 문서가 들어 있으니 읽어 보십시오. 디스크 압축 드라이버나 디스크 관리자를 사용하고 있는 경우라면 반드시 문서를 읽어 봐야 합니다. 디스크 단편화를 없애기 <emphasis
>전에</emphasis
> 디스크를 만들고 문서를 읽어 보십시오. </para
><para
>그 다음에 필요한 건 모든 데이터를 파티션의 처음으로 옮기는 일입니다. DOS 6.0 이후에 포함되어 있는 <command
>defrag</command
>가 이 작업을 합니다. 이런 일을 하는 다른 소프트웨어 목록을 보려면 <command
>fips</command
> 문서를 보십시오. Windows 9x를 사용한다면 Windows 9x에서 <command
>defrag</command
>를 실행해야 합니다. DOS는 Windows 95 이상에서 (긴 파일이름을 지원하기 위해) 사용하는 VFAT를 인식하지 못합니다. </para
><para
>단편화를 없애는 프로그램을 실행한 다음에 (디스크가 크면 꽤 오래 걸립니다), 플로피 드라이브에 새로 만든 <command
>fips</command
> 디스크를 넣고 다시 부팅하십시오. <filename
>a:\fips</filename
>를 실행해 안내에 따르십시오. </para
><para
><command
>fips</command
>에서 파티션 크기 조정을 하지 못하는 경우에도, 다른 파티션 관리자들이 많이 있습니다. </para>
   </sect3>

   <sect3 id="partitioning-for-dos"
><title
>DOS용 파티션하기</title>

<para
>리눅스 도구를 이용해 DOS 드라이브를 파티션하는 경우나, DOS 파티션의 크기를 바꾸는 경우, 만들어 낸 FAT 파티션에서 많은 문제가 발생했습니다. 예를 들면, 어떤 사람은 속도가 느려지기도 했고, <command
>scandisk</command
>를 사용했을 때 계속 문제가 발생하기도 했고, 그 외에 DOS나 Windows에서 괴상한 오류들이 발생했습니다. </para
><para
>DOS에 사용할 파티션을 만들거나 파티션 크기를 변경하는 경우, 처음 섹터 몇 개를 0으로 채워 넣는 게 좋습니다. DOS에서 <command
>format</command
> 명령어를 실행하기 전에 하십시오. 리눅스에서: <informalexample
><screen
># dd if=/dev/zero of=/dev/hdXX bs=512 count=4
</screen
></informalexample>

</para>
   </sect3>
  </sect2>
<!--   End of file preparing/nondeb-part/i386.xml -->

<!-- Start of file preparing/nondeb-part/m68k.xml -->


  <sect2 arch="m68k"
><title
>AmigaOS에서 파티션하기</title>
<para
>AmigaOS를 사용한다면, 설치하기 전에 <command
>HDToolBox</command
> 프로그램으로 파티션을 조정할 수 있습니다. </para>
  </sect2>

  <sect2 arch="m68k"
><title
>Atari TOS에서 파티션하기</title>
<para
>Atari 파티션 ID는 세 개의 ASCII 문자로 되어 있습니다. 데이터는 <quote
>LNX</quote
>를 사용하고 스왑은 <quote
>SWP</quote
>를 사용하십시오. 메모리가 적은 설치 방법을 이용한다면, 작은 Minix 파티션도 필요합니다 (약 2MB). 이 파티션의 ID는 <quote
>MNX</quote
>입니다. 올바른 파티션 ID를 설정해 놓지 않으면 데비안을 설치할 때 파티션을 인식하지 못할 뿐만 아니라, TOS에서 리눅스 파티션을 사용하게 되서, 하드 디스크 드라이버에 혼란을 일으키고 전체 디스크를 사용할 수 없게 됩니다. </para
><para
>아주 많은 써드파티 파티션 도구가 있습니다. (Atari <command
>harddisk</command
> 유틸리티에서는 파티션 ID를 바꿀 수 없습니다) 이 매뉴얼에서는 그 도구들을 모두 설명하지 않습니다. 다음 설명은 (Hard+Soft GmBH에서 만든) <command
>SCSITool</command
>에 관해서 다룹니다. <orderedlist>
<listitem
><para
><command
>SCSITool</command
>을 시작해서 파티션하려는 디스크를 선택하십시오. (<guimenu
>Disk</guimenu
> 메뉴, <guimenuitem
>select</guimenuitem
> 항목) </para
></listitem>
<listitem
><para
><guimenu
>Partition</guimenu
> 메뉴에서, <guimenuitem
>New</guimenuitem
>로 새 파티션을 추가하거나 현재 파티션 크기를 바꾸고, 아니면 <guimenuitem
>Change</guimenuitem
>로 한 개 특정 파티션을 바꾸십시오. 이미 적당한 크기로 파티션을 만든 상태에서 파티션 ID만 바꾸려는 경우가 아니라면, <guimenuitem
>New</guimenuitem
>를 이용하는 게 올바릅니다. </para
></listitem>
<listitem
><para
><guimenuitem
>New</guimenuitem
>에서는, 최초 설정을 표시하는 대화 상자에서 <guilabel
>existing</guilabel
>을 선택하십시오. 다음 창에서는 기존 파티션의 목록이 나오고, 스크롤 단추나 막대 그래프를 클릭해서 크기를 조정할 수 있습니다. 파티션 목록의 첫 번째 열에는 파티션 종류가 있고, 클릭해서 편집할 수 있습니다. 파티션 설정을 다 바꿨으면, <guibutton
>OK</guibutton
> 단추를 눌러서 창을 닫으면 저장합니다. </para
></listitem>
<listitem
><para
><guimenuitem
>Change</guimenuitem
>에서는, 선택할 목록에서 바꿀 파티션을 선택하고, 대화 상자에서 <guilabel
>other systems</guilabel
>을 선택하십시오. 다음 창에서는 이 파티션의 위치에 대한 정보가 나옵니다. 거기서 파티션 ID를 바꿉니다. <guibutton
>OK</guibutton
> 버튼을 눌러 창을 닫으면 저장합니다. </para
></listitem>
<listitem
><para
>리눅스용으로 새로 만들거나 바꾼 파티션의 리눅스 이름을 적어 놓으십시오 &mdash; <xref linkend="device-names"/> 부분을 참고하십시오. </para
></listitem>
<listitem
><para
><guimenu
>File</guimenu
> 메뉴에서 <guimenuitem
>Quit</guimenuitem
> 항목을 선택해 <command
>SCSITool</command
>을 마치십시오. 컴퓨터가 다시 부팅하게 되고 바꾼 파티션 테이블을 TOS가 제대로 사용하는 지 확인하십시오. TOS/GEM 파티션을 바꿨다면, 그 파티션은 사용할 수 없게 되므로 다시 초기화해야 합니다. (앞에서 디스크를 백업해야 한다고 말했지요?) </para
></listitem>
</orderedlist>

</para
><para
>Linux/m68k에는 설치 시스템 안에 <command
>atari-fdisk</command
>라는 파티션 도구가 있습니다. 하지만 현재로서는 TOS 파티션 편집 프로그램이나 다른 디스크 도구를 이용해 디스크를 파티션하기를 권장합니다. 파티션 편집 프로그램에 파티션 종류를 편집하는 옵션이 없다면, 나중에 이 작업을 할 수 있습니다 (설치할 때 임시로 만든 램디스크에서). <command
>SCSITool</command
>이 임의의 파티션 종류를 선택할 수 있는 (우리가 알고 있는 유일한) 파티션 편집 프로그램입니다. 다른 프로그램이 있을 지도 모르니, 필요에 따라 적합한 도구를 이용하십시오. </para>
</sect2>

  <sect2 arch="m68k"
><title
>MacOS에서 파티션하기</title>
<para
>테스트한 Macintosh의 파티션 도구는 <command
>pdisk</command
>, <command
>HD SC Setup</command
> 7.3.5 (Apple), <command
>HDT</command
> 1.8 (FWB), <command
>SilverLining</command
> (LaCie), 그리고 <command
>DiskTool</command
>이 (Tim Endres, GPL) 있습니다. <command
>HDT</command
>와 <command
>SilverLining</command
>의 경우 완전한 버전이 필요합니다. Apple의 도구는 써드파티 디스크를 인식하려면 패치가 필요합니다. (<command
>HD SC Setup</command
>을 <command
>ResEdit</command
>로 패치하는 방법은 <ulink url="http://www.euronet.nl/users/ernstoud/patch.html"
></ulink
>에 있습니다.) </para
><para
>IDE 기반 Mac의 경우, <command
>Apple Drive Setup</command
>을 이용해 리눅스 파티션을 위한 빈 공간을 만들어야 합니다. 그리고 리눅스에서 나머지 파티션을 하거나, MkLinux FTP 서버에 있는 pdisk의 MacOS 버전을 사용합니다. </para>
</sect2>

<!--   End of file preparing/nondeb-part/m68k.xml -->

<!-- Start of file preparing/nondeb-part/sparc.xml -->


  <sect2 arch="sparc"
><title
>SunOS에서 파티션하기</title>

<para
>SunOS에서 파티션하는 건 문제가 없습니다. 실제로 SunOS와 데비안을 같은 기계에서 돌리려면, 데비안을 설치하기 전에 SunOS에서 파티션하는 게 좋습니다. 리눅스 커널은 Sun 디스크 레이블을 인식하기 때문에, 여기서는 아무런 문제가 없습니다. 단 부팅 디스크의 첫 번째 1GB 안에 데비안 루트 파티션을 위한 공간을 만들어 놓으십시오. UFS 파티션에 루트 파티션을 넣기가 더 편하다면 커널 이미지를 그 UFS 파티션에 놓으십시오. SILO는 EXT2 (리눅스), UFS (SunOS), romfs 및 iso9660 (CD-ROM) 파티션에서 리눅스와 SunOS 부팅을 지원합니다. </para>
  </sect2>

  <sect2 arch="sparc"
><title
>Linux 및 그 밖의 OS에서 파티션하기</title>

<para
>파티션할 때 어떤 시스템을 사용하든 간에, 부팅 디스크에 <quote
>Sun 디스크 레이블</quote
>을 만들도록 하십시오. OpenBoot PROM이 이해하는 유일한 파티션 방식이고, 그래서 부팅할 수 있는 유일한 방식입니다. <command
>fdisk</command
>에서, <keycap
>s</keycap
> 키를 누르면 Sun 디스크 레이블을 만들 수 있습니다. Sun 디스크 레이블이 없는 드라이브의 경우에만 레이블을 새로 만들 필요가 있습니다. PC에서 (아니면 다른 아키텍처에서) 포맷한 드라이브가 있다면 새로운 디스크 레이블을 만들어야 하고, 아니면 디스크 크기에 관련한 오류가 발생할 것입니다. </para
><para
>부트로더(운영 체제 커널을 실행하는 작은 프로그램)로 <command
>SILO</command
>를 사용합니다. <command
>SILO</command
>를 쓰려면 파티션 크기와 위치에 대해 엄격한 제한이 있습니다. <xref linkend="partitioning"/> 부분을 참고하십시오. </para>
  </sect2>
<!--   End of file preparing/nondeb-part/sparc.xml -->

<!-- Start of file preparing/nondeb-part/powerpc.xml -->


  <sect2 arch="powerpc"
><title
>MacOS/OSX 파티션하기</title>

<para
>MacOS CD의 <filename
>Utilities</filename
> 폴더에 <application
>Apple Drive Setup</application
> 애플리케이션이 있습니다. 이 프로그램은 기존 파티션을 조정하지 않고, 전체 디스크를 한 번에 파티션하는 데만 쓸 수 있습니다. 디스크 드라이버 파티션은 <application
>Drive Setup</application
>에 나타나지 않습니다. </para
><para
>GNU/리눅스가 들어갈 위치에 공간을 차지하는 파티션을 만들도록 하십시오. 가능하면 디스크에서 첫 번째에 놓으십시오. 파티션 종류는 중요하지 않습니다. &debian; 설치 프로그램에서 나중에 그 파티션을 지워서 다른 파티션으로 바꾸게 됩니다. </para
><para
>MacOS 9과 OS X를 모두 설치하려는 경우, OS 9과 OS X에 별도의 파티션을 만드는 게 가장 좋습니다. 같은 파티션에 설치하는 경우 <application
>Startup Disk</application
>를 이용해서 두 가지 중에서 하나를 선택해야 합니다 (그리고 다시 부팅). 부팅할 때는 두 시스템 사이에 선택할 수 없습니다. 별도의 파티션을 이용하면, <keycap
>option</keycap
> 키를 부팅할 때 누르고 있으면 OS 9과 OS X 중의 하나를 선택할 수 있습니다. 또 <application
>yaboot</application
> 부팅 메뉴에서도 별도 옵션을 만들 수 있습니다. 게다가 Startup Disk는 다른 마운트 가능 파티션을 없애 버리기 때문에, GNU/리눅스가 부팅하는 데 문제가 생깁니다. OS 9과 OS X 파티션은 OS 9과 OS X 모두에서 접근할 수 있습니다. </para
><para
>GNU/리눅스는 UFS 파티션에 있는 정보를 접근할 수 없습니다, 그러나 HFS+ (다른 말로 MacOS Extended)는 지원합니다.. OS X는 부팅 파티션에 이 두가지 중의 하나의 파일시스템을 써야 합니다. MacOS 9은 HFS에 (다른 말로 MacOS Standard) 설치할 수도 있고 HFS+에 설치할 수도 있습니다. MacOS와 GNU/리눅스 시스템 사이에 정보를 공유하려면, 데이터 교환용 파티션을 만드는 게 편리합니다. HFS,HFS+와 MS-DOS FAT 파티션은 MacOS와 리눅스 모두에서 지원합니다. </para>
  </sect2>
<!--   End of file preparing/nondeb-part/powerpc.xml -->

 </sect1>
<!--   End of file preparing/non-debian-partitioning.xml -->

<!-- Start of file preparing/pre-install-bios-setup.xml -->

 <sect1 id="pre-install-bios-setup">
 <title
>설치하기 전에 하드웨어 및 운영 체제 설정</title>
<para
>여기서는 데비안을 설치하기 전에 해야 할 하드웨어 설정에 대해 (설정이 따로 필요하다면) 다룹니다. 보통 시스템의 펌웨어 설정을 확인하고 필요하다면 설정을 바꾸는 일들입니다. <quote
>펌웨어</quote
>는 하드웨어가 사용하는 주요 소프트웨어로, 전원을 켠 다음에 부트스트랩 과정에서 반드시 동작합니다. 여러분 시스템에서의 &debian; 안정성과 관련된 하드웨어 문제들도 다룹니다. </para>


<!-- Start of file preparing/bios-setup/i386.xml -->


  <sect2 arch="i386" id="bios-setup"
><title
>BIOS 설정 메뉴 들어가기</title>

<para
>BIOS는 컴퓨터를 부팅시키고 운영 체제에서 하드웨어를 접근하도록 하는 기본적인 기능들이 들어 있습니다. 시스템에서 BIOS 설정 메뉴가 있으면, 그 메뉴를 이용해 BIOS를 설정할 수 있습니다. 설치하기 전에, BIOS를 제대로 설정했는 지 확인해야 <emphasis
>합니다</emphasis
>. 그렇지 않으면 갑자기 멈출 수도 있고 데비안을 설치하지 못할 수도 있습니다. </para
><para
>이 절의 나머지 부분은 <ulink url="&url-pc-hw-faq;"
></ulink
>에서 가져온 <quote
>어떻게 CMOS 설정 메뉴로 들어가는가?</quote
>라는 질문에 대한 답입니다. BIOS (아니면 <quote
>CMOS</quote
>) 설정 메뉴에 들어가는 방법은 BIOS 소프트웨어를 만든 회사에 따라 다릅니다. </para>

<!-- From: burnesa@cat.com (Shaun Burnet) -->
<variablelist>

<varlistentry>
 <term
>AMI BIOS</term>
 <listitem
><para
>POST (power on self test, 최초 테스트) 도중에 <keycap
>Delete</keycap
> 키  </para
></listitem>
</varlistentry>

<varlistentry>
 <term
>Award BIOS</term>
 <listitem
><para
>POST 도중에 <keycombo
> <keycap
>Ctrl</keycap
><keycap
>Alt</keycap
><keycap
>Esc</keycap
> </keycombo
>, 아니면 <keycap
>Delete</keycap
> 키 </para
></listitem>
</varlistentry>

<varlistentry
><term
>DTK BIOS</term>
 <listitem
><para
>POST 도중에 <keycap
>Esc</keycap
> 키 </para
></listitem>
</varlistentry>

<varlistentry
><term
>IBM PS/2 BIOS</term>
 <listitem
><para
><keycombo
> <keycap
>Ctrl</keycap
><keycap
>Alt</keycap
><keycap
>Delete</keycap
> </keycombo
> 다음에 <keycombo
> <keycap
>Ctrl</keycap
><keycap
>Alt</keycap
><keycap
>Insert</keycap
> </keycombo
> </para
></listitem>
</varlistentry>

<varlistentry>
 <term
>Phoenix BIOS</term>
 <listitem
><para
><keycombo
> <keycap
>Ctrl</keycap
><keycap
>Alt</keycap
><keycap
>Esc</keycap
> </keycombo
> 아니면 <keycombo
> <keycap
>Ctrl</keycap
><keycap
>Alt</keycap
><keycap
>S</keycap
> </keycombo
> 아니면 <keycap
>F1</keycap
> </para
></listitem>
</varlistentry>
</variablelist>

<para
>다른 BIOS를 실행하는 방법에 대한 정보는 <ulink url="&url-invoking-bios-info;"
></ulink
>에 있습니다. </para
><para
>일부 &arch-title; 기계에는 BIOS에 CMOS 설정 메뉴가 없습니다. 소프트웨어 CMOS 설정 프로그램이 필요합니다. 해당 기계의 설치 및/혹은 진단 디스켓이 없다면, 셰어웨어/프리웨어 프로그램을 사용해 볼 수 있습니다. <ulink url="&url-simtel;"
></ulink
> 사이트를 살펴 보십시오. </para>
  </sect2>

  <sect2 arch="i386" id="boot-dev-select"
><title
>부팅 장치 선택</title>

<para
>많은 BIOS의 설정 메뉴에서는 시스템을 부팅하는 데 쓸 장치를 선택할 수 있습니다. 여기에서 <filename
>A:</filename
>에서 운영 체제를 부팅하도록 설정하고, 그 다음에 첫 번째 CD-ROM 장치로 (아마도 <filename
>D:</filename
>나 <filename
>E:</filename
>) 하고, 그 다음에 <filename
>C:</filename
>로 (첫 번째 하드 디스크) 설정하십시오. 이렇게 설정하면 플로피 디스크나 CD-ROM에서 부팅합니다. 대부분 데비안을 부팅할 때 이 둘 중의 하나에서 부팅합니다. </para
><para
>최신의 SCSI 컨트롤러가 있고 SCSI에 CD-ROM 장치가 붙어 있다면 보통 CD-ROM에서 부팅할 수 있을 것입니다. 해야 되는 일은 컨트롤러의 SCSI BIOS에서 CD-ROM 부팅을 켜는 일 뿐입니다. </para
><para
>그 밖에 많이 쓰는 옵션으로, USB 저장 장치에서 (USB 메모리나 USB 키라고도 함) 부팅하는 옵션입니다. 어떤 BIOS에서는 USB 저장 장치에서 직접 부팅할 수 있고, 그렇지 않은 BIOS도 있습니다.  BIOS를 설정해서 <quote
>Removable drive</quote
> 혹은 <quote
>USB-ZIP</quote
>에서 부팅하도록 하면 USB 장치에서 부팅합니다. </para
><para
>여기서는 부팅 순서를 설정하는 법을 자세히 설명합니다. 리눅스를 설치한 다음에 부팅 순서를 원래대로 돌려 놓는 걸 잊지 마십시오. 그래야 하드 디스크에서 부팅할 수 있습니다. </para>

   <sect3 id="ctbooi">
   <title
>IDE 컴퓨터의 부팅 순서 바꾸기</title>

<orderedlist>
<listitem
><para
>컴퓨터가 시작할 때, BIOS 유틸리티에 들어가는 키를 누르십시오. 보통 그 키는 <keycap
>Delete</keycap
> 키입니다. 하지만 정확히 어떤 키를 눌러야 할 지는 하드웨어 문서를 참고하십시오. </para
></listitem>
<listitem
><para
>설정 유틸리티에서 부팅 순서를 찾으십시오. 이 설정의 위치는 BIOS에 따라 다르지만, 드라이브 여러 개를 늘어 놓은 필드를 찾으면 됩니다. </para
><para
>IDE 기계에서는 보통 C, A, cdrom이거나 A, C, cdrom입니다. </para
><para
>C는 하드 드라이브이고, A는 플로피 드라이브입니다. </para
></listitem>
<listitem
><para
>부팅 순서 설정을 바꿔서 CD-ROM이나 플로피가 첫 번째가 되도록 하십시오. 보통 <keycap
>Page Up</keycap
>이나 <keycap
>Page Down</keycap
> 키로 여러가지 중의 하나를 선택합니다. </para
></listitem>
<listitem
><para
>바꾼 내용을 저장하십시오. 설정 화면의 안내에 따라 저장하십시오. </para
></listitem>
</orderedlist>
   </sect3>

   <sect3 id="ctboos">
   <title
>SCSI 컴퓨터에서 부팅 순서 바꾸기</title>
<para>

<orderedlist>
<listitem
><para
>컴퓨터가 시작하면, SCSI 설정 유틸리티로 들어가는 키를 누르십시오. </para
><para
>컴퓨터를 시작하면 메모리 검사를 하고, BIOS 유틸리티를 시작하는 방법을 표시한 다음, SCSI 설정 유틸리티로 들어갈 수 있습니다. </para
><para
>어떤 키를 눌러야 하는 지는 유틸리티에 따라 다릅니다. 보통 <keycombo
><keycap
>Ctrl</keycap
><keycap
>F2</keycap
></keycombo
>입니다. 정확한 키 조합은 하드웨어 문서를 보십시오. </para
></listitem>
<listitem
><para
>부팅 순서를 바꾸는 유틸리티 찾기. </para
></listitem>
<listitem
><para
>CD 드라이브의 SCSI ID가 목록의 첫 번째가 되도록 유틸리티를 설정하십시오. </para
></listitem>
<listitem
><para
>바뀐 부분을 저장하십시오. 화면의 안내에 따라 바뀐 부분을 컴퓨터에 저장하십시오. 보통 <keycap
>F10</keycap
>을 눌러야 합니다. </para
></listitem>
</orderedlist>

</para>
   </sect3>
  </sect2>

  <sect2 arch="i386">
  <title
>기타 BIOS 설정</title>

   <sect3 id="cd-settings"
><title
>CD-ROM 설정</title>
<para
>어떤 BIOS 시스템은 (예: Award BIOS) CD 속도를 설정할 수 있습니다. 속도를 설정하지 말고, 그냥 최저 속도로 놔둬야 합니다. <userinput
>seek failed</userinput
> 오류 메세지가 나오게 된다면 이 문제 때문일 수도 있습니다. </para>
   </sect3>

   <sect3
><title
>Extended와 Expanded Memory</title>
<para
>시스템에서 ex<emphasis
>ten</emphasis
>ded와 ex<emphasis
>pan</emphasis
>ded memory가 모두 있다면, extended memory를 최대한으로 해 놓고 expanded memory를 최소한으로 맞춰 놓으십시오. 리눅스에는 extended memory가 필요하지만 expanded memory를 사용할 수 없습니다. </para>
   </sect3>

   <sect3
><title
>Virus Protection</title>
<para
>BIOS에서 제공하는 바이러스 경고 기능이 있다면 끄십시오. 바이러스 방지 보드나 기타 특수 하드웨어가 달려 있다면, GNU/리눅스를 돌리는 동안은 그 기능을 끄거나 물리적으로 제거하십시오. 이러한 기능이나 하드웨어는 GNU/리눅스와 호환되지 않습니다. 또 파일 시스템의 권한 및 리눅스의 보호 메모리때문에 리눅스에서 바이러스는 거의 없습니다.<footnote
><para
>설치가 끝난 뒤에 원하신다면 부트섹터 보호를 켤수 있습니다.이는 리눅스에 추가적인 보호를 제공하지 않습니다. 그러나 윈도를 같이 사용한다면 재난을 방지할 지 모릅니다. 부트 관리자가 설정된 후에는 마스터 부트 레코드(MBR)에 영향을 주지 않습니다.</para
></footnote
> </para>
   </sect3>

   <sect3
><title
>Shadow RAM</title>
<para
>마더보드에서 <emphasis
>shadow RAM</emphasis
>이나 BIOS 캐싱을 제공할 수도 있습니다. <quote
>Video BIOS Shadow</quote
>나 <quote
>C800-CBFF Shadow</quote
>와 같은 설정을 볼 수 있을 것입니다. 모든 shadow RAM을 <emphasis
>끄십시오</emphasis
>. shadow RAM은 마더보드와 일부 컨트롤러 카드에 있는 ROM의 접근 속도를 높이는 데 쓰입니다. 리눅스는 일단 부팅하면 이러한 ROM을 사용하지 않습니다. ROM에 들어 있는 16비트 프로그램 대신에 직접 32비트 소프트웨어가 들어 있기 때문입니다. 어떤 경우 shadow RAM을 꺼야 이 shadow RAM을 다른 프로그램에서 일반 메모리로 사용할 수 있습니다. shadow RAM을 켜 놓으면 리눅스가 하드웨어에 접근할 때 문제가 발생할 수 있습니다. </para>
   </sect3>

   <sect3
><title
>Memory Hole</title>
<para
>BIOS에 <quote
>15&ndash;16 MB Memory Hole</quote
>과 같은 게 있다면, 그 기능을 끄십시오. 그 만큼의 메모리가 있으면 리눅스에서는 이 구간의 메모리도 이용합니다. </para
><para
>Intel이 만든 어떤 마더보드에서 <quote
>LFB</quote
> 혹은 <quote
>Linear Frame Buffer</quote
>라고 하는 옵션이 있다는 보고를 받았습니다. 두 가지 설정을 할 수 있습니다: <quote
>Disabled</quote
> 및 <quote
>1 Megabyte</quote
>입니다. <quote
>1 Megabyte</quote
>로 설정하십시오. Disabled인 경우에는, 설치 플로피를 제대로 읽지 못하고, 시스템이 결국 멈추었습니다. 현재로서는 이 특정 마더보드에서 무슨 일이 벌어지고 있는 건지 알아내지 못했습니다. (<quote
>1 Megabyte</quote
>로 설정하면 동작하고 아니면 동작하지 않는 것 밖에 알지 못합니다.) </para>
   </sect3>

<!-- no other platforms other than x86 provide this sort of thing, AFAIK -->

   <sect3
><title
>Advanced Power Management</title>
<para
>마더보드에서 Advanced Power Management (APM) 기능이 들어 있으면, APM에서 전원 관리 기능을 컨트롤하도록 설정하십시오. doze, standby, suspend, nap, sleep 모드를 끄시고, hard disk's power-down timer 기능을 끄십시오. 리눅스에서 이 모드에 대한 컨트롤을 할 수 있고, BIOS보다 더 전원 관리를 잘 합니다. </para>
   </sect3>
  </sect2>
<!--   End of file preparing/bios-setup/i386.xml -->

<!-- Start of file preparing/bios-setup/m68k.xml -->


  <sect2 arch="m68k" id="firmware-revs">
  <title
>펌웨어 버전 및 기존 운영 체제 설정</title>

<para
>&arch-title; 기계는 일반적으로 알아서 설정이 되고, 별도의 펌웨어 설정이 필요하지 않습니다. 하지만 올바른 ROM과 시스템 패치는 있어야 합니다. Macintosh에서는 버전 7.1 이상의 MacOS 버전을 추천합니다. MacOS 7.0.1에는 버그때문에 부트 로더가 비디오 인터럽트를 끌 수 없어서, 부팅할 때 멈춥니다. BVM VMEbus 시스템에서는 BVMBug 버전 G나 그보다 높은 boot ROM을 사용해야 합니다. BVMBug boog ROM은 BVM 시스템에 기본으로 들어있지 않지만, BVM에 요청하면 무료로 구할 수 있습니다. </para>

  </sect2>

<!--   End of file preparing/bios-setup/m68k.xml -->

<!-- Start of file preparing/bios-setup/powerpc.xml -->


  <sect2 arch="powerpc" id="invoking-openfirmware">
  <title
>OpenFirmware 실행</title>
<para
>&arch-title; 시스템에서는 BIOS를 (OpenFirmware) 설정할 필요가 없습니다. PReP 및 CHRP는 OpenFirmware가 들어 있지만, 아쉽게도 그 때문에 각 제조사마다 OpenFirmware가 실행 방법이 다릅니다. 기계에 들어 있는 하드웨어 문서를 참고하셔야 합니다. </para
><para
>&arch-title; Macintosh에서는, 부팅할 때 <keycombo
><keycap
>Command</keycap
> <keycap
>option</keycap
> <keycap
>O</keycap
> <keycap
>F</keycap
></keycombo
> 키를 눌러 OpenFirmware를 시작합니다. 보통 삐 소리가 난 다음에 이 키가 눌렸는 지 검사하지만, 정확한 타이밍은 여러 모델마다 다릅니다. 더 많은 힌트는 <ulink url="&url-netbsd-powerpc-faq;"
></ulink
>의 내용을 참고하십시오. </para
><para
>OpenFirmware 프롬프트는 다음과 같습니다: <informalexample
><screen>
ok
0 &gt;
</screen
></informalexample
> 오래된 모델의 &arch-title; Mac에서는, OpenFirmware의 사용자 입출력은 기본값이 (혹은 고정된 값이) 시리얼 (모뎀) 포트입니다. 이러한 기계에서 OpenFirmware를 실행한 경우, 검은 화면만 보게 될 것입니다. 이 경우, 다른 컴퓨터에서 터미널 프로그램을 실행해 모뎀 포트에 연결해야 OpenFirmware를 쓸 수 있습니다. </para
><para
>OldWorld Beige G3 기계의 OpenFirmware, OF 2.0f1 및 2.4 버전은 심각한 문제가 있습니다. 이 기계에서는 펌웨어를 패치해야 하드 드라이브에서 부팅할 수 있습니다. 펌웨어 패치는 <application
>System Disk 2.3.1</application
> 유틸리티에 들어 있고, Apple의 <ulink url="ftp://ftp.apple.com/developer/macosxserver/utilities/SystemDisk2.3.1.smi.bin"
></ulink
>에서 구할 수 있습니다. MacOS에서 이 유틸리티의 압축을 풀고, 실행한 다음, Save 단추를 눌러 펌웨어 패치를 nvram에 설치하십시오. </para>
  </sect2>
<!--   End of file preparing/bios-setup/powerpc.xml -->

<!-- Start of file preparing/bios-setup/sparc.xml -->


  <sect2 arch="sparc" id="invoking-openboot"
><title
>OpenBoot 실행</title>

<para
>OpenBoot에는 &arch-title; 아키텍처 부팅에 필요한 기능이 들어 있습니다. 이 기능은 x86 아키텍처의 BIOS와 비슷하지만, 훨씬 더 훌륭합니다. Sun boot PROM에는 fourth 인터프리터가 들어 있어서, 진단 기능이나 간단한 스크립트와 같은 여러 가지 일을 할 수 있습니다. </para
><para
>부팅 프롬프트로 들어가려면 <keycap
>Stop</keycap
> 키를 누르고 있다가 (옛날 type 4 키보드에서는 <keycap
>L1</keycap
> 키를 사용하고, PC 키보드 어댑터를 쓰면 <keycap
>Break</keycap
> 키 사용), <keycap
>A</keycap
> 키를 누릅니다. boot PROM에서 <userinput
>ok</userinput
> 혹은 <userinput
>&gt;</userinput
>라는 프롬프트가 나옵니다. <userinput
>ok</userinput
> 프롬프트가 좋습니다. 옛날 방식의 프롬프트가 나타난다면, <keycap
>n</keycap
>키를 누르면 새로운 방식의 프롬프트가 나옵니다. </para
><para
>시리얼 콘솔을 사용한다면, break 신호를 보내십시오. minicom에서는 <keycap
>Ctrl-A F</keycap
>을 누르고, cu에서는 <keycap
>Enter</keycap
> 다음에 <userinput
>%~break</userinput
>을 입력합니다. 다른 프로그램을 사용한다면 그 터미널 에뮬레이터의 문서를 참고하십시오. </para>
  </sect2>

  <sect2 arch="sparc" id="boot-dev-select-sun">
  <title
>부팅 장치 선택</title>

<para
>OpenBoot를 사용해 특정 장치에서 부팅할 수 있고, 기본 부팅 장치를 바꿀 수도 있습니다. 하지만 OpenBoot의 장치 명명법에 대해 좀 자세히 알아야 합니다. 리눅스 장치 명명법과는 많이 다른데 <xref linkend="device-names"/>에 보면 설명되어 있습니다. 또, 명령어도 어떤 OpenBoot 버전을 쓰느냐에 따라 많이 다릅니다. OpenBoot에 대한 더 많은 정보는 <ulink url="&url-openboot;"
>Sun OpenBoot Reference</ulink
>에서 볼 수 있습니다. </para
><para
>최근 버전에서는, OpenBoot 장치를 <quote
>floppy</quote
>, <quote
>cdrom</quote
>, <quote
>net</quote
>, <quote
>disk</quote
> 혹은 <quote
>disk2</quote
>와 같이 쓸 수 있습니다. 각각은 분명한 의미가 있습니다. <quote
>net</quote
>은 네트워크에서 부팅합니다. 또 장치 이름에서 디스크의 특정 파티션을 지정할 수도 있습니다. <quote
>disk2:a</quote
>와 같이 하면 disk2의 첫번째 파티션에서 부팅하는 것입니다. 완전한 OpenBoot 장치 이름의 형식은 다음과 같습니다: <informalexample
> <screen>
<replaceable
>드라이버-이름</replaceable
>@
<replaceable
>유닛-주소</replaceable
>:
<replaceable
>드라이버-인수</replaceable>
</screen
></informalexample
> 과거 버전의 OpenBoot에서는 장치 명명법이 약간 다릅니다: 플로피 장치는 <quote
>/fd</quote
>라고 하고, SCSI 디스크는 <quote
>sd(<replaceable
>컨트롤러</replaceable
>, <replaceable
>디스크-타겟-ID</replaceable
>, <replaceable
>디스크-LUN</replaceable
>)</quote
> 형식입니다. 최근 OpenBoot 버전에서는 <userinput
>show-devs</userinput
> 명령으로 현재 설정되어 있는 장치의 목록을 볼 수 있습니다. 버전에 대한 더 자세한 정보는 <ulink url="&url-openboot;"
>Sun OpenBoot Reference</ulink
>를 참고하십시오. </para
><para
>특정 장치에서 부팅하려면, <userinput
>boot <replaceable
>장치</replaceable
></userinput
> 명령을 사용합니다. <userinput
>setenv</userinput
> 명령을 사용하면 이걸 기본값으로 만들 수 있습니다. 하지만 변수의 이름은 OpenBoot 버전마다 다릅니다. OpenBoot 1.x에서는 <userinput
>setenv boot-from <replaceable
>장치</replaceable
></userinput
> 명령을 사용하십시오. 그 후의 OpenBoot 버전에서는, <userinput
>setenv boot-device <replaceable
>장치</replaceable
></userinput
> 명령을 사용하십시오. Solaris에서 <command
>eeprom</command
> 명령을 이용하거나, <filename
>/proc/openprom/options/</filename
>의 파일을 고쳐서 설정할 수 있습니다. 예를 들어 리눅스에서는: <informalexample
><screen>
# echo disk1:1 &gt; /proc/openprom/options/boot-device
</screen
></informalexample
> 그리고 Solaris에서는: <informalexample
><screen
>eeprom boot-device=disk1:1
</screen
></informalexample>

</para>
  </sect2>
<!--   End of file preparing/bios-setup/sparc.xml -->

<!-- Start of file preparing/bios-setup/s390.xml -->


  <sect2 arch="s390"
><title
>BIOS 설정</title>
<para
>&debian;을 &arch-title; 혹은 zSeries 기계에 설치하려면 먼저 커널을 부팅합니다. 이 플랫폼의 부팅 방법은 다른 플랫폼과는 (특히 PC 시스템과는) 완전히 다릅니다. 플로피 장치가 아예 없습니다. 이 플랫폼으로 작업할 때 다른 큰 차이점도 하나 있는데, (항상 그렇지는 않더라도) 대부분 원격에서 telnet이나 브라우저같은 클라이언트 소프트웨어를 이용해 작업합니다. 특별한 아키텍처때문인데 여기서 3215/3270 콘솔은 문자 단위가 아니라 라인 단위입니다. </para
><para
>이 플랫폼의 리눅스는 LPAR(Logical Partition)이라고 하는 원래의 기계에서 돌아갈 수도 있고, VM 시스템의 가상 기계에서 동작할 수도 있습니다. 두 경우 모두 부팅 테이프를 사용할 수 있습니다. 다른 부팅 미디어를 사용할 수도 있지만 보통은 사용할 수 없습니다. 예를 들어서, 가상 기계의 경우 가상 카드 리더를 사용할 수도 있고, LPAR에서는 HMC에서 부팅할 수도 있습니다. (HMC가 있고 부팅 옵션이 있는 경우.) </para
><para
>실제 설치를 하기 전에, 약간의 설계와 준비 단계를 거쳐야 합니다. IBM에서 나온 문서에서 전체 과정에 대해 다룹니다. 예를 들어 설치 미디어를 준비하고 그 미디어에 대해서 부팅하는 방법이 들어 있습니다. 여기서 거기 들어 있는 정보를 다시 반복하는 건 그렇게 할 수도 없고 그럴 필요도 없습니다. 하지만 여기서는 데비안에 특히 필요한 데이터가 어떤 것인지, 그리고 그 데이터를 어디서 찾을 수 있는 지에 대해서 설명합니다. IBM의 문서와 이 문서를 참고해서 기계와 설치 미디어를 준비하고 부팅해야 합니다. 클라이언트 세션에서 welcome 메세지를 보면 이 문서로 돌아와서 데비안에 관련된 설치 단계를 밟으십시오. </para>
  </sect2>

  <sect2 arch="s390">
  <title
>네이티브 및 LPAR 설치</title>
<para
>리눅스를 위해 LPAR을 설정하는 방법은 <ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg244987.pdf"
> Linux for &arch-title;</ulink
> Redbook의 chapter 5와 <ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg246264.pdf"
> Linux for IBM eServer zSeries and &arch-title;: Distributions</ulink
> Redbook의 chapter 3.2를 참고하십시오. </para>
  </sect2>

  <sect2 arch="s390">
  <title
>VM guest로 설치</title>

<para
>VM guest를 설정해 리눅스를 실행하는 방법은 <ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg244987.pdf"
> Linux for &arch-title;</ulink
> Redbook의 chapter 6과 <ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg246264.pdf"
> Linux for IBM eServer zSeries and &arch-title;: Distributions</ulink
> Redbook의 chapter 3.1을 참고하십시오. </para
><para
><filename
>generic</filename
> 서브 디렉토리에서 CMS 디스크로 모든 파일을 복사해 놓아야 합니다. <filename
>kernel.debian</filename
> 및 <filename
>initrd.debian</filename
> 파일은 반드시 80 character의 고정 레코드 길이로 바이너리 모드로 가져오십시오. </para>
  </sect2>

  <sect2 arch="s390">
  <title
>설치 서버 설정하기</title>

<para
>(직접 혹은 웹 프록시를 통해) 인터넷에 연결하지 않는다면 S/390에서 접근할 수 있는 로컬 설치 서버를 만들어야 합니다. 이 서버에는 설치하려는 모든 꾸러미가 들어 있고 그 꾸러미를 NFS나 HTTP나 FTP로 외부에서 접근할 수 있게 합니다. </para
><para
>설치 서버에는 &debian; 미러에서 디렉토리 구조를 정확히 복사해 놓아야 합니다. s390 아키텍처용 파일 및 아키텍처 공용 파일만 필요합니다. 그러한 디렉토리에서 설치 CD의 내용만 복사해 올 수도 있습니다. </para
><para condition="FIXME">

<emphasis
>FIXME: more information needed &mdash; from a Redbook?</emphasis>

</para>
  </sect2>
<!--   End of file preparing/bios-setup/s390.xml -->

  <sect2
><title
>주의해야 할 하드웨어 이슈</title>
<para arch="not-s390"
>많은 사람들이 CPU를 90 MHz를 100 MHz와 같이 오버클록킹해서 돌리고 있습니다. 이렇게 해도 동작하기도 하지만, 온도 및 그 밖의 요인에 민감하고 시스템이 망가질 수도 있습니다. 이 문서의 저자중의 한 명은 1년동안 시스템을 오버클록킹해서 써 왔는데 <command
>gcc</command
> 프로그램으로 운영 체제 커널을 컴파일할 때마다 <command
>gcc</command
>가 예상치 못한 시그널로 이상 종료하곤 했습니다. CPU 속도를 원래대로 돌려 놓으니까 문제가 해결되었습니다. </para
><para arch="not-s390"
>메모리 모듈에 문제가 있을 때 (아니면 데이터를 교환할 때 하드웨어 문제가 있을 때) 처음으로 죽는 프로그램은 보통 <command
>gcc</command
> 컴파일러입니다. <command
>gcc</command
>는 커다란 데이터 구조를 만들고 그 사이를 계속해서 왔다갔다 하기 때문입니다. 이 데이터 구조에 문제가 생기면 존재하지 않는 주소에 접근해서 잘못된 인스트럭션이 되어 버립니다. 증상은 <command
>gcc</command
>가 예상치 못한 시그널로 죽는 것입니다. </para
><para arch="m68k"
>Atari TT RAM 보드는 리눅스에서 문제 많기로 유명합니다. 어떤 문제가 발생하면 ST-RAM에 있는 커널을 실행해 보십시오. Amiga 사용자는 booter memfile로 RAM을 제외해야 할 수도 있습니다. <phrase condition="FIXME"
><emphasis
> FIXME: more description of this needed. </emphasis
></phrase
> </para
><para arch="i386"
>아주 좋은 마더보드는 패리티 RAM을 지원하고 RAM에 한 비트 오류가 발생했을 때 알려줍니다. 아쉽게도, 그 오류를 고칠 수 있는 방법은 없기 때문에, 그 RAM이 있다는 사실을 알자 마자 죽어 버립니다. 그래도 데이터에 오류를 집어 넣는 것보다는 메모리가 잘못되었다고 알려주는 편이 낫습니다. 아주 좋은 시스템에는 마더보드가 패리티를 지원하고 진짜 패리티 메모리 모듈이 들어 있습니다. <xref linkend="Parity-RAM"/> 부분을 참고하십시오. </para
><para arch="i386"
>진짜 패리티 RAM이 있고 마더보드에서 패리티 RAM을 지원한다면, BIOS 설정에서 그 기능을 켜서 메모리 패리티 오류가 발생했을 때 인터럽트를 내도록 하십시오. </para>

   <sect3 arch="i386"
><title
>Turbo 스위치</title>
<para
>많은 시스템에서는 <emphasis
>turbo</emphasis
> 스위치가 있어서 CPU의 속도를 조절합니다. 고속의 설정을 선택하십시오. BIOS에서 소프트웨어적으로 turbo 스위치를 조정할 수 있다면 (아니면 CPU 속도를 소프트웨어로 조정한다면), 시스템을 고속 모드로 고정해 놓으십시오. 어떤 시스템에서는 리눅스가 하드웨어 장치를 검색하는 동안 turbo 스위치의 소프트웨어 컨트롤 기능을 건드렸다는 보고가 있었습니다. </para>
   </sect3>

   <sect3 arch="i386"
><title
>Cyrix CPU 및 플로피 디스크 오류</title>
<para
>많은 Cyrix CPU 사용자들은 설치하는 동안 캐시 기능을 꺼야 했습니다. 끄지 않으면 플로피 디스크에서 오류가 발생했습니다. 캐시 기능을 꺼야 하는 경우, 설치를 마치면 캐시를 다시 켜십시오. 캐시를 끈 상태에서는 시스템이 <emphasis
>훨씬</emphasis
> 더 느리게 동작합니다. </para
><para
>이 현상이 Cyrix CPU의 문제라고 생각하지는 않습니다. 아마도 리눅스에서 이 문제를 피해갈 수 있을 것입니다. 이 문제의 원인은 계속 찾아볼 것입니다. 기술적인 문제가 궁금하신 분들을 위해 말씀드리면, 16비트에서 32비트 코드로 넘어갈 때 캐시가 무효화되면서 발생하는 문제라고 추정됩니다. </para>
   </sect3>

   <sect3 arch="i386"
><title
>주변 장치 하드웨어 설정</title>
<para
>컴퓨터의 주변 장치 카드의 설정을 바꾸거나 점퍼를 바꿔야 할 수도 있습니다. 일부 카드는 설정 메뉴가 있고, 어떤 카드는 점퍼를 바꿔야 합니다. 이 문서에서는 각각의 모든 하드웨어 장치에 대한 정보가 들어 있지는 않습니다. 그저 유용한 팁들을 전달하길 바랄 뿐입니다. </para
><para
>카드에서 <quote
>mapped memory</quote
>를 지원한다면, 메모리는 0xA0000과 0xFFFFF 사이에 (640K 위에서 1메가바이트 아래) 들어 있거나, 시스템의 전체 RAM보다 최소 1메가바이트 큰 위치에 들어 있어야 합니다. </para>
   </sect3>

   <sect3 arch="i386" id="usb-keyboard-config">
   <title
>USB BIOS 지원 및 키보드</title>
<para
>AT 방식 키보드가 없고 USB 키보드만 있는 경우에는, BIOS 설정에서 legacy AT keyboard emulation을 켜야 할 수도 있습니다. 설치 시스템에서 USB 모드로 키보드를 사용할 수 없는 경우에만 사용하십시오. 반대로 어떤 시스템에서는 (특히 노트북 컴퓨터의 경우) 키보드가 동작하지 않을 때 legacy USB 지원을 꺼야 할 수도 있습니다. 메인보드 매뉴얼을 살펴 보시고 BIOS에서 <quote
>Legacy keyboard emulation</quote
>이나 <quote
>USB keyboard support</quote
> 옵션을 찾으십시오. </para>
   </sect3>

   <sect3
><title
>64 MB RAM 이상</title>
<para
>리눅스 커널에서 RAM의 용량을 항상 정확히 알아내는 건 아닙니다. 그런 경우, <xref linkend="boot-parms"/>에 있는 내용을 참고하십시오. </para>
   </sect3>
  </sect2>
 </sect1>
<!--   End of file preparing/pre-install-bios-setup.xml -->

</chapter>
<!--   End of file preparing/preparing.xml -->
