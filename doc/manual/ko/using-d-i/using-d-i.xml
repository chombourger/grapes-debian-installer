<!-- Start of file using-d-i/using-d-i.xml -->


 <chapter id="d-i-intro"
><title
>데비안 설치 프로그램 사용하기</title>

 <sect1
><title
>설치 프로그램이 동작하는 방식</title>
<para
>데비안 설치 프로그램은 여러 가지 용도의 여러 구성 요소로 구성되어 있고, 각 구성 요소마다 설치 작업을 수행합니다. 각 구성 요소는 해당 작업을 수행하면서 그 작업에 필요한 정보를 사용자에게 물어봅니다. 이 질문들에는 우선순위가 부여되어 있고, 설치 프로그램이 맨 처음 시작할 때 물어볼 질문의 우선순위를 먼저 물어봅니다. </para
><para
>기본 설치를 하면, 꼭 필요한 (우선순위가 높은) 질문만 물어봅니다. 그래서 사용자가 거의 관여하지 않고 아주 자동화된 설치 과정이 가능합니다. 구성 요소는 순서대로 자동 실행합니다. 어떤 설치 방법을 사용하는 지 및 하드웨어가 무엇인지에 따라 어떤 구성 요소를 실행하는 지가 다릅니다. 설치 프로그램에서 물어보지 않는 질문은 기본 값을 사용합니다. </para
><para
>어떤 문제가 발생하면 오류 화면이 나타납니다. 그리고 경우에 따라 설치 메뉴가 나타날 수도 있고, 메뉴에서 그 문제를 피해 다른 작업을 선택할 수도 있습니다. 아무런 문제가 없으면 설치 메뉴를 볼 수 없고, 각 구성 요소에 해당하는 질문에 차례대로 답을 하기만 하면 됩니다. 심각한 오류를 알리는 우선 순위는 '중요'이기 때문에 심각한 오류가 발생하면 반드시 오류 화면이 나타납니다. </para
><para
>설치 프로그램에서 사용하는 기본값 중에 몇 개는 &d-i;가 시작할 때 넘기는 부팅 파라미터에 따라 달라집니다. 예를 들어 강제로 고정 네트워크 설정을 하려면 (기본적으로 DHCP를 사용할 수 있으면 DHCP를 사용합니다) <userinput
>netcfg/disable_dhcp=true</userinput
> 부팅 파라미터를 추가하면 됩니다. 사용할 수 있는 옵션에 대해서는 <xref linkend="installer-args"/> 부분을 참고하십시오. </para
><para
>파워유저라면 메뉴 방식 인터페이스가 더 편할 수도 있습니다. 메뉴 방식에서는 각 단계를 자동으로 진행하지 않고 사용자 입력에 따라 단계를 조정합니다. 설치 프로그램을 수동 메뉴 방식으로 사용하려면, <userinput
>debconf/priority=medium</userinput
> 파라미터를 사용하십시오. </para
><para
>커널 모듈을 설치하면서 파라미터를 넘겨야 하는 하드웨어에서는, <quote
>전문가</quote
> 모드로 설치 프로그램을 시작합니다. 설치 프로그램이 시작할 때 <command
>expert</command
> 명령을 사용하거나, <userinput
>debconf/priority=low</userinput
> 부팅 파라미터를 사용하면 됩니다. 전문가 모드는 &d-i;의 모든 부분을 마음대로 조정할 수 있습니다. </para
><para
>설치 프로그램의 화면은 문자 단위 화면입니다. (더 널리 쓰이는 그래픽 인터페이스가 아닙니다.) 이 환경에서는 마우스가 동작하지 않습니다. 여러가지 대화 상자에서 왔다갔다할 때 쓰는 키를 설명합니다. <keycap
>Tab</keycap
> 혹은 <keycap
>오른쪽</keycap
> 화살표 키를 누르면 화면에 나오는 단추들과 선택사항들 중에서 <quote
>앞으로</quote
> 움직이고, <keycombo
> <keycap
>Shift</keycap
> <keycap
>Tab</keycap
> </keycombo
> 혹은 <keycap
>왼쪽</keycap
> 화살표 키는 <quote
>뒤로</quote
> 움직입니다. <keycap
>위쪽</keycap
> 및 <keycap
>아래쪽</keycap
> 화살표 키를 누르면 스크롤 목록에서 선택할 항목을 움직이고, 스크롤 목록을 스크롤합니다. 또 긴 목록에서는, 글자를 하나 누르면 그 글자로 시작하는 항목이 있는 부분으로 직접 이동합니다. 또 <keycap
>Pg-Up</keycap
> 및 <keycap
>Pg-Down</keycap
>키로 목록을 스크롤합니다. <keycap
>스페이스바</keycap
>를 누르면 확인란 따위의 항목을 토글합니다. 선택한 항목으로 들어가려면 &enterkey;를 누릅니다. </para
><para arch="s390"
>S/390은 가상 콘솔을 지원하지 않습니다. 아래에서 설명하는 로그를 보려면 SSH 세션을 여러 개 열어야 할 수도 있습니다. </para
><para
>오류 메세지는 세 번째 콘솔에서 나옵니다. 세 번째 콘솔은 <keycombo
><keycap
>왼쪽 Alt</keycap
><keycap
>F3</keycap
></keycombo
>을 누르면 (왼쪽 <keycap
>Alt</keycap
>를 누른 상태에서 <keycap
>F3</keycap
> 펑션 키) 볼 수 있습니다. 설치 메인 화면으로 돌아오려면 <keycombo
><keycap
>왼쪽 Alt</keycap
><keycap
>F1</keycap
></keycombo
>을 누릅니다. </para
><para
>이 메세지는 <filename
>/var/log/messages</filename
> 파일에도 들어 있습니다. 설치한 후에는 이 로그는 새로 설치한 시스템의 <filename
>/var/log/debian-installer/messages</filename
> 파일로 복사됩니다. 그 밖의 설치할 때 나오는 메세지는 <filename
>/var/log/</filename
> 안에 들어 있고, 컴퓨터가 새로 설치한 시스템으로 부팅하면 <filename
>/var/log/debian-installer/</filename
> 안에 들어갑니다. </para>
 </sect1>


  <sect1 id="modules-list"
><title
>구성 요소 소개</title>
<para
>다음은 설치 프로그램의 구성 요소와 각 구성 요소가 하는 일에 대한 간단한 설명입니다. 특정 구성 요소를 사용하는 방법에 대해 더 자세한 정보는 <xref linkend="module-details"/>에 있습니다. </para>

<variablelist>
<varlistentry>

<term
>main-menu</term
><listitem
><para
>설치 프로그램이 동작하는 중에 구성 요소의 목록을 표시하고, 구성 요소를 선택하면 그 구성 요소를 시작합니다. 메인 메뉴의 질문은 우선순위가 중간이기 때문에, 우선 순위를 높음이나 중요로 해 놓으면 (기본값은 높음) 이 메뉴를 볼 수 없습니다. 하지만 오류가 발생해서 사용자가 뭔가 작업을 해야 한다면, 사용자가 이 문제를 해결할 수 있도록 우선순위가 일시적으로 낮아지고, 이 경우 메뉴가 나타날 수도 있습니다. </para
><para
><quote
>뒤로</quote
> 단추를 계속해서 눌러 현재 실행중인 구성 요소를 나가게 되면 메인 메뉴로 갑니다. </para
></listitem>
</varlistentry>
<varlistentry condition="sarge">

<term
>languagechooser</term
><listitem
><para
>언어 목록을 표시합니다. 언어를 하나 선택하면 설치 프로그램에서는 그 언어로 메세지를 표시합니다. 단 그 언어로 번역이 되지 않았다면, 영어 메세지를 표시합니다. </para
></listitem>
</varlistentry>
<varlistentry condition="sarge">

<term
>countrychooser</term
><listitem
><para
>국가 목록을 표시합니다. 자기가 살고 있는 국가를 선택합니다. </para
></listitem>
</varlistentry>
<varlistentry condition="etch">

<term
>localechooser</term
><listitem
><para
>사용자가 설치 및 설치할 시스템에 사용할 지역화 옵션을 (언어, 국가, 로케일) 선택합니다. 설치 프로그램에서는 선택한 언어로 메세지를 표시합니다. 단 그 언어로 번역이 다 되지 않았다면, 일부 영어 메세지를 표시할 수도 있습니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>kbd-chooser</term
><listitem
><para
>키보드 목록을 표시합니다. 여기에서 자기 키보드에 해당하는 모델을 선택합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>hw-detect</term
><listitem
><para
>시스템의 하드웨어 대부분을 자동으로 검색합니다. 네트워크 카드, 디스크 드라이브, PCMCIA 등입니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>cdrom-detect</term
><listitem
><para
>데비안 설치 CD를 찾아서 마운트합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>netcfg</term
><listitem
><para
>인터넷을 통해 통신할 수 있도록 컴퓨터 네트워크 연결을 설정합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>iso-scan</term
><listitem
><para
>ISO 파일 시스템을 찾습니다. CD-ROM일 수도 있고, 하드 드라이브에 들어 있을 수도 있습니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>choose-mirror</term
><listitem
><para
>데비안 아카이브 미러 목록을 표시합니다. 설치할 꾸러미가 들어 있는 위치를 선택합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>cdrom-checker</term
><listitem
><para
>CD-ROM이 올바른지 확인합니다. 설치 CD-ROM이 망가졌는지 여부를 확인합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>lowmem</term
><listitem
><para
>lowmem은 메모리가 작은 시스템을 검사하고, 여러가지 방법으로 &d-i;에서 필요없는 부분을 메모리에서 없앱니다. (그 대신 일부 기능이 없어집니다.) </para
></listitem>
</varlistentry>
<varlistentry>

<term
>anna</term
><listitem
><para
>Anna's Not Nearly APT. 선택한 미러 사이트 혹은 CD에서 가져온 꾸러미를 설치합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>partman</term
><listitem
><para
>시스템에 달린 디스크를 파티션하고, 파티션에 파일 시스템을 만들고, 파일 시스템을 마운트 위치에 마운트합니다. 완전 자동 모드 혹은 LVM 지원 기능과 같은 재미있는 기능도 들어 있습니다. 데비안에서 기본 파티션 도구입니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>autopartkit</term
><listitem
><para
>사용자가 정하는 방식에 따라 디스크를 자동으로 파티션합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>partitioner</term
><listitem
><para
>여기서 시스템에 달린 디스크를 파티션합니다. 해당 컴퓨터 아키텍처에 적합한 파티션 프로그램을 이용합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>partconf</term
><listitem
><para
>파티션 목록을 표시하고, 사용자 명령에 따라 선택한 파티션에 파일 시스템을 만듭니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>lvmcfg</term
><listitem
><para
>여기서 <firstterm
>LVM</firstterm
>(Logical Volume Manager)을 설정합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>mdcfg</term
><listitem
><para
>여기서 소프트웨어 <firstterm
>RAID</firstterm
>(Redundant Array of Inexpensive Disks)를 설정합니다. 이 소프트웨어 RAID는 최근 마더보드에 들어 있는 싸구려 IDE RAID (가짜 하드웨어 RAID) 컨트롤러보다는 대체로 우수합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>base-installer</term
><listitem
><para
>다시 시작했을 때 리눅스가 동작하는 데 필요한 가장 기본적인 꾸러미를 설치합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>os-prober</term
><listitem
><para
>컴퓨터에 지금 설치되어 있는 운영 체제를 찾아서 그 정보를 bootloader-installer에 넘깁니다. 그러면 bootloader-installer에서는 이 운영 체제를 부트 로더 시작 메뉴에 추가할 수 있습니다. 이렇게 하면 부팅할 때 어떤 운영 체제를 시작할 지 쉽게 선택할 수 있습니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>bootloader-installer</term
><listitem
><para
>하드 디스크에 부트 로더 프로그램을 설치합니다. 그래야 플로피나 CD-ROM을 따로 사용하지 않고 컴퓨터에서 리눅스를 시작할 수 있습니다. 컴퓨터가 부팅할 때 많은 부트 로더에서는 여러가지 운영체제중에서 하나를 선택해서 시작할 수 있도록 되어 있습니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>base-config</term
><listitem
><para
>사용자 선택에 따라 베이스 시스템을 설정하는 대화 상자를 표시합니다. 컴퓨터를 다시 시작한 다음에 이 대화 상자가 나타납니다. base-config는 새로 설치한 데비안 시스템에서 돌아가는 '제1호 프로그램'입니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>shell</term
><listitem
><para
>사용자가 메뉴에서 쉘을 실행하거나, 두번째 콘솔에서 쉘을 실행합니다. </para
></listitem>
</varlistentry>
<varlistentry>

<term condition="sarge"
>bugreporter</term
><term condition="etch"
>save-logs</term
><listitem
><para
>문제가 발생했을 때 관련 정보를 플로피 디스크<phrase condition="etch"
>, 네트워크, 하드디스크, 그 외의 미디어</phrase
>에 기록합니다. 나중에 설치 프로그램의 소프트웨어 문제를 데비안 개발자에게 정확하게 알리는 데 이 기록을 이용합니다. </para
></listitem>
</varlistentry>

</variablelist>

 </sect1>


<!-- Start of file using-d-i/components.xml -->

 <sect1 id="module-details">
 <title
>각 구성 요소 사용하기</title>
<para
>여기서는 설치 프로그램의 각 구성 요소를 자세히 설명합니다. 이 구성 요소는 사용자 입장에서 몇 단계로 분류할 수 있습니다. 여기서 설명하는 순서는 설치할 때 나타나는 순서입니다. 설치할 때 여기 있는 모듈을 모두 사용하는 건 아닙니다. 이 중에서 실제로 어떤 모듈을 사용하는 지는 설치 방법과 하드웨어에 따라 달라집니다. </para>

  <sect2 id="di-setup">
  <title
>데비안 설치 프로그램 및 하드웨어 설정 준비하기</title>
<para
>데비안 설치 프로그램이 부팅하고 첫번째 화면이 나왔다고 가정합니다. 이 시점에서는 아직 &d-i;의 기능은 매우 제한적입니다. 하드웨어도 모르고, 선호하는 언어도 모르고, 어떤 작업을 해야 할 지도 모릅니다. 걱정하지 마십시오. &d-i;는 아주 똑똑하기 때문에, 하드웨어를 자동으로 검색해서, 필요한 구성 요소를 찾아낸 다음에, 다양한 기능을 갖춘 설치 시스템으로 다시 태어납니다. 하지만 자동으로 알아낼 수 없는 일부 정보의 경우는 (선호하는 언어 선택, 키보드 배치, 사용할 네트워크 미러 따위) 여러분이 직접 &d-i;에 관련 정보를 입력해야 합니다. </para
><para
>이 단계에서 &d-i;는 여러 번의 <firstterm
>하드웨어 검색</firstterm
>을 합니다. 첫번째는 설치 프로그램의 구성 요소를 읽어들이는 데 필요한 하드웨어를 (예를 들어 CD-ROM이나 네트워크 카드) 검색합니다. 첫번째로 실행할 때는 아직 사용할 수 없는 드라이버가 있기 때문에, 나중 단계에서 하드웨어 검색을 다시 합니다. </para>


<!-- Start of file using-d-i/modules/lowmem.xml -->

  <sect3 id="lowmem">
  <title
>사용 가능 메모리 검사</title>

<para
>&d-i; 가 맨 처음에 하는 일 중의 하나는, 메모리를 검사하는 것입니다. 메모리가 부족할 경우, 이 구성 요소에서는 설치 과정에 약간 수정을 가해서 시스템에서 &debian;을 설치할 수 있게 합니다. </para
><para
>적은 메모리에서 설치할 때는, 모든 구성 요소를 사용할 수 없습니다. 그 부족한 점 중의 하나는 설치에 사용할 언어를 마음대로 선택할 수 없다는 점입니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/lowmem.xml -->

<!-- Start of file using-d-i/modules/languagechooser.xml -->


   <sect3 id="lang-chooser" condition="sarge">
   <title
>언어 선택</title>

<para
>설치 첫 단계로, 어떤 언어로 설치를 진행할 지 선택하십시오. 언어 이름은 목록에서 (왼쪽의) 영어와 (오른쪽의) 해당 언어로 (해당 언어의 문자로) 쓰여 있습니다. 이 목록은 영어 이름 순서로 되어 있습니다. </para
><para
>여기서 선택하는 언어를 사용해 나머지 설치 과정을 진행합니다. 단 그 언어로 해당 대화 상자들의 번역이 있어야 됩니다. 그 언어로 된 번역문이 없으면 기본값인 영어를 사용합니다. 여기서 선택한 언어는 적당한 키보드 배치를 선택하는 데도 이용됩니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/languagechooser.xml -->

<!-- Start of file using-d-i/modules/countrychooser.xml -->


   <sect3 id="country-chooser" condition="sarge">
   <title
>국가 선택</title>

<para
>만약 <xref linkend="lang-chooser"/>에서 선택한 언어를 사용하는 국가가 여러 개 있는 경우 (영어, 중국어, 프랑스어 등), 여기에서 국가를 지정할 수 있습니다. 목록의 맨 아래에 있는 <guimenuitem
>기타</guimenuitem
>를 선택하면, 모든 국가의 목록이 대륙별로 구분되어 나타납니다. </para
><para
>여기서 선택한 사항은 나중에 기본 시간대 및 해당 위치에 적합한 데비안 미러를 고르는 데 이용됩니다. 물론 설치 프로그램의 기본값이 마음에 들지 않으면 다른 선택을 할 수도 있습니다. 선택한 국가와 언어는 새 데비안 시스템의 로케일 설정에도 영향을 미칩니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/countrychooser.xml -->

<!-- Start of file using-d-i/modules/localechooser.xml -->


   <sect3 id="localechooser" condition="etch">
   <title
>지역화 옵션 선택</title>

<para
>대부분의 경우 처음 물어보는 질문은 설치할 때 및 설치한 시스템에 대한 지역화에 모두 적용됩니다. 지역화 옵션은 언어, 국가, 로케일로 이루어져 있습니다. </para
><para
>여기서 선택하는 언어를 사용해 나머지 설치 과정을 진행합니다. 단 그 언어로 해당 대화 상자들의 번역이 있어야 됩니다. 그 언어로 된 번역문이 없으면 기본값인 영어를 사용합니다. </para
><para
>여기서 선택한 지역은 나중에 기본 시간대 및 지리적으로 가까운 데비안 미러를 고르는 데 이용됩니다. 물론 설치 프로그램의 기본값이 마음에 들지 않으면 다른 선택을 할 수도 있습니다. 선택한 국가와 언어는 새 데비안 시스템의 로케일 설정과 키보드를 선택하는데 사용됩니다. </para
><para
>먼저 사용할 언어를 선택하게 됩니다. 각 언어의 이름은 (왼쪽에) 영어 및 (오른쪽에) 해당 언어로 쓰여 있습니다. 오른쪽에 있는 이름은 해당 언어의 문자를 이용해서 표시됩니다. 이 언어 목록은 영어 이름 순서로 나열되어 있습니다. 목록의 맨 위에는 <quote
>C</quote
> 로케일을 선택하는 옵션입니다. <quote
>C</quote
> 로케일을 선택하면 설치는 영어로 진행되고, 설치한 시스템은 <classname
>locales</classname
> 꾸러미를 설치하지 않고 지역화 기능이 없게 됩니다. </para
><para
>여러 국가들에서 공식 언어로 사용하는 언어를 선택하는 경우<footnote
> <para
> 기술적인 용어로: 해당 언어에 대해 여러 개 국가 코드가 붙어 있는 로케일이 존재하는 경우. </para
> </footnote
>, 해당 국가를 선택하게 됩니다. 목록의 맨 아래에 있는 <guimenuitem
>기타</guimenuitem
>를 선택하면, 모든 언어의 목록이 대륙별로 구분 지어서 표시됩니다. 해당 언어를 사용하는 국가가 하나뿐이라면, 자동으로 그 국가를 선택합니다. </para
><para
>기본 로케일은 선택한 언어 및 국가에 따라 자동으로 결정됩니다. 중간 혹은 낮음 우선순위로 설치하는 경우, 다른 기본 로케일 값을 다르게 선택하거나 로케일을 여러 개 추가로 만들어 놓도록 할 수 있습니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/localechooser.xml -->

<!-- Start of file using-d-i/modules/kbd-chooser.xml -->

   <sect3 id="kbd-chooser">
   <title
>키보드 선택하기</title>

<para
>어떤 키보드는 특정 언어에서 사용하는 문자에 맞게 만들어져 있습니다. 사용하고 있는 키보드에 맞는 키보드 배치를 고르시고, 해당 키보드 배치가 여기 없으면 어느정도 비슷한 키보드 배치를 고르십시오. 시스템 설치를 모두 마치면 더 많은 종류의 키보드 배치 중에서 하나를 고를 수 있게 됩니다. (<command
>kbdconfig</command
>를 실행하십시오.) </para
><para
>반전 표시를 해당 키보드로 옮기고 &enterkey;를 누르십시오. 화살표 키로 반전 표시를 움직입니다. 화살표 키는 모든 언어의 키보드에 대해 동일하므로, 키보드 설정과는 상관이 없습니다. 목록에서 '확장' 키보드는 <keycap
>F1</keycap
>에서 <keycap
>F10</keycap
> 키가 위에 붙어 있는 키보드를 말합니다. </para
><para arch="mipsel"
>DECstation에서는 따로 읽어들일 수 있는 키맵이 없으므로, 키보드 선택 부분을 건너 뛰고 기본 커널 키맵을 (LK201 US) 유지합니다. 향후 Linux/MIPS 커널 개발에 따라 이 부분은 앞으로 달라질 수 있습니다. </para
><para arch="powerpc"
>미국 키보드는 두 개의 키보드 배치가 있습니다. qwerty/mac-usb-us (Apple USB) 배치에서는 Alt 기능을 <keycap
>Command/Apple</keycap
>키가 (PC 키보드의 <keycap
>Alt</keycap
>와 비슷하게 <keycap
>스페이스</keycap
> 키 다음 위치) 대신합니다. 한편 qwerty/us (Standard) 배치에서는 Alt 기능을 <keycap
>Option</keycap
>키가 (대부분의 Mac 키보드에서는 'alt'라고 쓰여 있습니다) 대신합니다. 이 두 키보드 배치에서 그 외의 부분은 비슷합니다. </para>

<note arch="sparc"
><para
>Sun USB 키보드가 있는 시스템에 설치하는 경우, 기본 2.4 커널로 설치 프로그램을 부팅하면 설치 시스템에서는 그 키보드를 인식하지 못합니다. 설치 프로그램에서는 Sun용 키맵 목록이 표시되지만 그 키보드를 선택하면 동작하지 않습니다. 2.6 커널로 설치하면 문제가 없습니다. </para
><para
>키보드가 동작하게 하려면, <userinput
>debconf/priority=medium</userinput
> 파라미터로 설치 프로그램을 부팅해야 합니다. 키보드를 선택할 때<footnote
> <para
> 기본 우선순위로 설치하신다면, Sun용 키맵 목록이 나올 때 <userinput
>뒤로 가기</userinput
> 버튼을 사용해 설치 메뉴로 돌아가야 합니다. </para
> </footnote
>, 미국식 (US) 키배치라면 <quote
>설정할 키보드 없음</quote
>을 고르시고, 지역화된 키보드라면 <quote
>USB 키보드</quote
>를 고르십시오. <quote
>설정할 키보드 없음</quote
>은 커널 키맵을 그대로 놔두는 것이고, 이게 미국식 키보드에 맞습니다. </para
></note>
   </sect3>
<!--   End of file using-d-i/modules/kbd-chooser.xml -->

<!-- Start of file using-d-i/modules/s390/netdevice.xml -->
<!--   End of file using-d-i/modules/s390/netdevice.xml -->

<!-- Start of file using-d-i/modules/ddetect.xml -->
<!--   End of file using-d-i/modules/ddetect.xml -->

<!-- Start of file using-d-i/modules/cdrom-detect.xml -->
<!--   End of file using-d-i/modules/cdrom-detect.xml -->

<!-- Start of file using-d-i/modules/iso-scan.xml -->

   <sect3 id="iso-scan">
   <title
>데비안 설치 프로그램 ISO 이미지 찾기</title>
<para
><emphasis
>hd-media</emphasis
> 방법으로 설치하면, 데비안 설치 프로그램 ISO 이미지를 찾아서 마운트해야 하는 시점이 있습니다. 이 ISO 이미지에서 나머지 설치 파일을 가져옵니다. <command
>iso-scan</command
> 구성 요소가 정확히 이 일을 합니다. </para
><para
>먼저, <command
>iso-scan</command
>은 알려진 파일 시스템을 사용하는 블록 장치(파티션 등)를 마운트하고, 차례대로 <filename
>.iso</filename
>로 (혹은 <filename
>.ISO</filename
>로) 끝나는 파일이름을 찾습니다. 단 첫번째에서는 맨 위 디렉토리와 바로 아래 서브 디렉토리에 있는 파일만 찾습니다. (즉 <filename
>/<replaceable
>아무개</replaceable
>.iso</filename
>, <filename
>/data/<replaceable
>아무개</replaceable
>.iso</filename
> 파일은 찾지만, <filename
>/data/tmp/<replaceable
>아무개</replaceable
>.iso</filename
>는 찾지 않습니다.) ISO 이미지를 찾으면, <command
>iso-scan</command
>에서 이미지 내용을 검사해서 이미지가 올바른 데비안 ISO 이미지인지 아닌지 판단합니다. 올바른 이미지가 맞으면 끝나고, 아니면 다른 이미지를 찾습니다. </para
><para
>앞에서 설치 ISO 이미지를 찾는 데 실패하면, <command
>iso-scan</command
>에서는 계속해서 이미지를 찾을 지 여부를 물어봅니다. 그러면 맨 위의 디렉토리만 찾는 게 아니라, 모든 파일 시스템을 뒤져봅니다. </para
><para
><command
>iso-scan</command
>에서 설치 프로그램 ISO 이미지를 발견하지 못했다면, 원래 운영 체제로 다시 시작해서 이미지 이름이 올바른 지 (<filename
>.iso</filename
>로 끝나는 지), &d-i;가 인식할 수 있는 파일 시스템에 들어 있는지, 파일이 손상되지 않았는지 (체크섬 확인) 확인하십시오. 경험 많은 유닉스 사용자라면 다시 시작하지 않고 두 번째 콘솔에서 할 수도 있습니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/iso-scan.xml -->

<!-- Start of file using-d-i/modules/anna.xml -->
<!--   End of file using-d-i/modules/anna.xml -->

<!-- Start of file using-d-i/modules/netcfg.xml -->

   <sect3 id="netcfg">
   <title
>네트워크 설정하기</title>

<para
>이 단계에 들어왔을 때 시스템에서 네트워크 장치를 두 개 이상 찾으면, 어떤 장치를 <emphasis
>주요</emphasis
> 네트워크 인터페이스로 사용할 지 질문을 받게 됩니다. 주요 네트워크 인터페이스란 설치할 때 사용할 인터페이스를 말합니다. 이 인터페이스 외의 인터페이스는 이 시점에서는 설정하지 않습니다. 설치가 다 끝난 다음에 장치들을 추가로 설정할 수 있습니다. <citerefentry
> <refentrytitle
>interfaces</refentrytitle
> <manvolnum
>5</manvolnum
> </citerefentry
> 맨 페이지를 참고하십시오. </para
><para
>기본값으로 &d-i;에서는 먼저 DHCP를 통해 컴퓨터 네트워크를 설정하려고 시도합니다. DHCP 검색이 성공하면 네트워크 설정이 모두 끝납니다. 검색이 실패하면 네트워크 케이블을 꽂지 않았거나 DHCP가 잘못되었거나 따위의 여러가지 원인 때문일 수 있습니다. 아니면 LAN에 DHCP 서버가 아예 없을 수도 있습니다. 원인이 무엇이든, 다시 시도할 지 수동으로 설정할 지 여부를 물어봅니다. DHCP 서버는 가끔 응답이 아주 느리기도 하기 때문에, 다른 문제가 없는 게 분명하면 다시 시도해 보십시오. </para
><para
>수동 네트워크 설정에서는 네트워크에 관한 여러가지 정보들을 차례대로 물어봅니다. <computeroutput
>IP 주소</computeroutput
>, <computeroutput
>네트마스크</computeroutput
>, <computeroutput
>게이트웨이</computeroutput
>, <computeroutput
>네임 서버 주소</computeroutput
> 및 <computeroutput
>호스트이름</computeroutput
>을 물어봅니다. 또 무선 네트워크 인터페이스가 있다면, <computeroutput
>무선 ESSID</computeroutput
> 및 <computeroutput
>WEP 키</computeroutput
>를 물어봅니다. <xref linkend="needed-info"/>의 답을 채워 넣으십시오. </para
><note
><para
>알아두면 편리할 수도 있고 아닐 수도 있는 기술적인 정보: 이 프로그램에서는 네트워크 IP 주소가 시스템의 IP 주소와 네트마스크를 비트 AND한 값이라고 가정합니다. 브로드캐스트 주소는 시스템의 IP 주소와 네트마스크의 비트 NOT한 값을 OR한 값이라고 가정합니다. 또 게이트웨이도 임의로 추정합니다. 수동 설정에서 무슨 값을 써야 할지 잘 모르겠다면, 시스템의 추정값을 사용해 보십시오. 일단 시스템을 설치한 다음에 필요하다면 <filename
>/etc/network/interfaces</filename
> 파일을 편집해서 이 설정을 바꿀 수 있습니다. 다른 방법으로, <classname
>etherconf</classname
>를 설치해서, 여기에 나오는 단계에 따라 네트워크 설정을 할 수 있습니다. </para
></note>
   </sect3>
<!--   End of file using-d-i/modules/netcfg.xml -->

<!-- Start of file using-d-i/modules/choose-mirror.xml -->

<!--
- Component is only selected and executed if the installer needs to load
  installer components or the base system from the network
  (either local or the internet).
- This means you first have to configure a network interface.
- A list of countries is displayed with the default based on the country you
  selected earlier.
- Note that not all mirrors are equal (see http://www.nl.debian.org/mirror/list)
- Selection of a local mirror (at top of the list: manual selection).
- After selecting a country, a list of mirrors in the country will be shown.

- The selected mirror will be tested.
- How to handle problems with mirrors.
-->
<!--   End of file using-d-i/modules/choose-mirror.xml -->

  </sect2>

  <sect2 id="di-partition">
  <title
>파티션하기 및 마운트 위치 선택</title>
<para
>여기에서는 마지막으로 하드웨어 검색을 한 다음에, &d-i;는 필요한 기능을 모든 갖추고, 사용자의 필요에 맞게 진짜 설치 작업을 할 준비를 갖추게 됩니다. 제목이 말하듯, 다음 몇 개의 구성 요소는 디스크를 파티션하고, 파일시스템을 만들고, 마운트 위치를 지정하고, 또 필요하다면 LVM이나 RAID 장치와 같은 관련 설정을 합니다. </para>


<!-- Start of file using-d-i/modules/s390/dasd.xml -->
<!--   End of file using-d-i/modules/s390/dasd.xml -->

<!-- Start of file using-d-i/modules/partman.xml -->

   <sect3 id="partman">
   <title
>디스크 파티션하기</title>

<para
>디스크를 파티션할 차례입니다. 파티션하는 게 불안하거나 자세히 알고 싶으시면, <xref linkend="partitioning"/> 부분을 참고하십시오. </para
><para
>먼저 선택에 따라, 전체 드라이브나 드라이브의 빈 공간을 자동으로 파티션할 수 있습니다. 이 방법을 <quote
>단계에 따른</quote
> 파티션이라고 합니다. 자동 파티션을 하지 않으려면, 메뉴에서 <guimenuitem
>수동으로 파티션 테이블 편집</guimenuitem
>을 선택하십시오. </para
><para
>단계에 따라 파티션을 선택한 경우, 아래의 표의 방식중에서 한 가지 방식을 선택합니다. 모든 방식들은 각자 장단점이 있고, <xref linkend="partitioning"/>에서 설명합니다. 잘 모르겠으면 첫번째를 선택하십시오. 명심해 둬야 할 것은, 단계에 따라 파티션할 때는 어느정도 최소한의 빈 공간이 필요하다는 점입니다. 최소 1GB의 공간이 없으면 (방식에 따라 이 최소 용량은 다릅니다) 단계에 따른 파티션은 실패합니다. </para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
  <entry
>파티션 방식</entry>
  <entry
>최소 공간</entry>
  <entry
>만들 파티션</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>한 파티션에 파일 모두</entry>
  <entry
>600MB</entry>
  <entry
><filename
>/</filename
>, 스왑</entry>
</row
><row>
  <entry
>데스크탑 컴퓨터</entry>
  <entry
>500MB</entry>
  <entry
><filename
>/</filename
>, <filename
>/home</filename
>, 스왑 </entry>
</row
><row>
  <entry
>다중 사용자 워크스테이션</entry>
  <entry
>1GB</entry>
  <entry
><filename
>/</filename
>, <filename
>/home</filename
>, <filename
>/usr</filename
>, <filename
>/var</filename
>, <filename
>/tmp</filename
>, 스왑 </entry>
</row>

</tbody
></tgroup
></informaltable>

<para arch="ia64"
>IA64 시스템에서 자동 파티션을 선택하면 EFI 부트 로더가 사용하는, FAT16으로 포맷한 부팅 가능 파티션이 하나 더 생깁니다. 포맷 메뉴에서도 수동으로 EFI 부팅 파티션으로 만드는 항목이 하나 더 생깁니다. </para
><para arch="alpha"
>Alpha 시스템에서 자동 파티션을 선택하면 aboot 부트 로더가 사용하는, 포맷하지 않은 파티션이 디스크 맨 앞 부분에 하나 더 생깁니다. </para
><para
>파티션 방법을 선택하면, 그 다음 화면에서 새로 만든 파티션 테이블이 나타납니다. 여기에는 파티션을 포맷할 형식과 마운트할 위치에 대한 정보도 들어 있습니다. </para
><para
>파티션 목록은 다음과 같이 나타납니다: <informalexample
><screen>
  IDE1 master (hda) - 6.4 GB WDC AC36400L
        #1 primary   16.4 MB     ext2       /boot
        #2 primary  551.0 MB     swap       swap
        #3 primary    5.8 GB     ntfs
           pri/log    8.2 MB     FREE SPACE

  IDE1 slave (hdb) - 80.0 GB ST380021A
        #1 primary   15.9 MB     ext3
        #2 primary  996.0 MB     fat16
        #3 primary    3.9 GB     xfs        /home
        #5 logical    6.0 GB     ext3       /
        #6 logical    1.0 GB     ext3       /var
        #7 logical  498.8 MB     ext3
        #8 logical  551.5 MB     swap       swap
        #9 logical   65.8 GB     ext2
</screen
></informalexample
> 위의 예에서는 IDE 하드드라이브가 2개이고 여러 개 파티션으로 나눠져 있습니다. 첫 번째 디스크에는 빈 공간이 있습니다. 각 파티션 줄에는 파티션 번호, 종류, 크기, 플래그, 파일시스템, 그리고 마운트 위치를 (마운트 위치가 따로 있는 경우) 표시합니다. </para
><para
>여기까지가 단계에 따른 파티션입니다. 자동으로 만든 파티션 테이블이 마음에 들면, 메뉴에서 <guimenuitem
>파티션 나누기를 마치고 바뀐 사항을 디스크에 쓰기</guimenuitem
>를 선택해서 새 파티션 테이블을 실제로 적용합니다 (이 절의 맨 뒤 부분에서 설명합니다). 마음에 들지 않으면, <guimenuitem
>파티션에 바뀐 사항을 취소</guimenuitem
>를 선택해서 단계에 따른 파티션을 다시 실행하거나, 자동으로 만들어 준 파티션을 아래에서 설명하는 것처럼 수동으로 고칠 수도 있습니다. </para
><para
>수동 파티션을 선택하면 위와 비슷한 화면을 표시합니다. 다른 점은 기존 파티션 테이블을 마운트 위치 없이 표시한다는 점입니다. 이 절의 나머지 부분에서는 파티션 테이블을 수동으로 만드는 방법과, 이 파티션을 새 데비안 시스템에서 어떻게 사용할 지에 대해 다룹니다. </para
><para
>파티션도 없고 빈 공간도 없는 새 디스크라면, 새로운 파티션 테이블을 만들게 됩니다. (그래야 새 파티션을 만들 수 있습니다.) 그 다음에 <quote
>빈 공간</quote
>이라는 줄이 해당 디스크 이름 아래에 나타납니다. </para
><para
>빈 공간을 선택하면, 새 파티션을 만들 지 물어봅니다. 크기, 종류 (주 파티션 아니면 논리 파티션), 위치에 (빈 공간에서 처음 아니면 끝) 대해 답해야 합니다. 그러면 새 파티션에 대한 자세한 정보가 나타납니다. 마운트 위치, 마운트 옵션, 부팅 가능 플래그, 용도 따위의 옵션이 있습니다. 기본값이 마음에 들지 않는다면, 원하는 대로 바꾸십시오. 예를 들어 <guimenuitem
>용도:</guimenuitem
> 옵션을 선택해서 이 파티션의 파일시스템을 선택할 수 있습니다. (파일시스템에는 스왑 파티션, 소프트웨어 RAID, LVM, 아니면 아예 사용하지 않는 것까지도 포함됩니다.) 또 다른 멋진 기능은 기존 파티션의 데이터를 이 파티션으로 복사하는 기능입니다. 새 파티션이 마음에 들면 <guimenuitem
>파티션 준비를 마쳤습니다</guimenuitem
>를 선택하고 <command
>partman</command
>의 주 화면으로 돌아갑니다. </para
><para
>파티션에서 뭔가 바꾸려고 한다면, 해당 파티션을 선택하십시오. 그러면 파티션 설정 메뉴가 나타납니다. 새 파티션을 만들 때와 같은 화면이기 때문에, 여기서도 마찬가지의 옵션을 바꿉니다. 첫 눈에 잘 이해가 되지 않을 만한 부분은, 파티션의 크기 항목을 이용해서 파티션의 크기를 바꿀 수 있다는 점입니다. 이 기능이 동작하는 파티션은 fat16, fat32, ext2, ext3, 및 스왑입니다. 이 메뉴에서 파티션을 지워 버릴 수도 있습니다. </para
><para
>최소한 파티션을 두 개 만들도록 하십시오. 한 개는 <emphasis
>루트</emphasis
> 파일시스템이고 (<filename
>/</filename
>에 마운트합니다), 다른 하나는 <emphasis
>스왑</emphasis
>입니다. 루트 파일 시스템을 마운트하지 않으면, 그 문제를 바로잡기 전에는 다음으로 진행하지 없습니다. </para
><para arch="ia64"
>EFI 부팅 파티션을 만들고 포맷하지 않았다면, <command
>partman</command
>에서 그 사실을 알아내기 때문에 EFI 부팅 파티션을 만들기 전까지는 다음으로 진행하지 않습니다. </para
><para
><command
>partman</command
>의 기능은 설치 프로그램 모듈에 따라 확장되지만, 시스템의 아키텍처에 따라 다릅니다. 모든 기능들을 볼 수 없다면, 필요한 모듈을 모두 읽어들였는지 확인하십시오. (예를 들어, <filename
>partman-ext3</filename
>, <filename
>partman-xfs</filename
>, 아니면 <filename
>partman-lvm</filename
>) </para
><para
>파티션이 마음이 들면, 파티션 메뉴에서 <guimenuitem
>파티션 나누기를 마치고 바뀐 사항을 디스크에 쓰기</guimenuitem
>를 선택하십시오. 디스크에 바뀐 점에 대한 요약이 나타나고 이대로 파일 시스템을 만들지 확인합니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/partman.xml -->

<!-- Start of file using-d-i/modules/autopartkit.xml -->
<!--   End of file using-d-i/modules/autopartkit.xml -->

<!-- Start of file using-d-i/modules/partitioner.xml -->

<!--   End of file using-d-i/modules/partitioner.xml -->

<!-- Start of file using-d-i/modules/partconf.xml -->
<!--   End of file using-d-i/modules/partconf.xml -->

<!-- Start of file using-d-i/modules/lvmcfg.xml -->

   <sect3 id="lvmcfg">
   <title
>논리 볼륨 관리자 (LVM) 설정하기</title>
<para
>시스템 관리자나 <quote
>고급</quote
> 사용자 입장에서 컴퓨터를 사용한다면, 어떤 디스크 파티션이 (보통 가장 중요한 파티션) 공간이 부족하고 다른 파티션은 공간이 남아서 데이터를 옮기고 심볼릭 링크를 걸고 하는 등의 작업으로 상황을 해결해야 했던 경험이 있을 것입니다. </para
><para
>이러한 상황을 피하려면, 논리 볼륨 관리자(LVM, Logical Volume Manager)를 사용할 수 있습니다. 간단히 말해 LVM을 사용하면 여러 파티션들을 (<firstterm
>물리 볼륨</firstterm
>) 하나의 가상 디스크로 (<firstterm
>볼륨 그룹</firstterm
>) 합칠 수 있고, 그걸 다시 가상 파티션으로 (<firstterm
>논리 볼륨</firstterm
>) 나눌 수 있습니다. 중요한 점은 논리 볼륨이 (그리고 그 밑에 있는 볼륨 그룹이) 여러 개의 물리 파티션에 걸쳐 있을 수 있다는 점입니다. </para
><para
>기존의 160GB <filename
>/home</filename
> 파티션에 용량이 더 필요하다면, 300GB 디스크를 컴퓨터에 붙이고, 이 디스크를 현재 볼륨 그룹에 포함시키고, <filename
>/home</filename
>이 들어 있는 논리 볼륨 크기를 늘리면 됩니다. 그러면 파티션은 460GB가 되어 남는 공간이 더 생깁니다. 물론 이 예는 너무 간단하게 설명한 것입니다. 아직 읽지 않으셨다면 <ulink url="&url-lvm-howto;"
>LVM HOWTO</ulink
>를 참고하십시오. </para
><para
>&d-i;의 LVM 설정은 아주 간단합니다. 먼저 LVM의 물리 볼륨으로 사용할 파티션을 표시합니다. (<guimenu
>파티션 설정</guimenu
>의 <command
>partman</command
>에서 합니다. 거기서 <menuchoice
> <guimenu
>용도:</guimenu
> <guimenuitem
>LVM의 물리 볼륨</guimenuitem
> </menuchoice
>를 선택합니다.) 그리고 <command
>lvmcfg</command
> 모듈을 시작하고 (<command
>partman</command
>에서 직접 하던가, &d-i;의 메인메뉴에서 합니다) <guimenuitem
>볼륨 그룹 (VG) 고치기</guimenuitem
> 메뉴에서 물리 볼륨을 볼륨 그룹에 합칩니다. 그 다음에 <guimenuitem
>논리 볼륨 (LV) 고치기</guimenuitem
> 메뉴에서 볼륨 그룹 위에 논리 볼륨을 만들어야 합니다. <note arch="powerpc" condition="sarge"
><para
>Apple Power Macintosh 하드웨어에서 LVM 데이터가 들어 있는 파티션을 인식하는 방법은 널리 인정된 표준이 없습니다. 이 특정 하드웨어에서는, 위에서 설명한 방법대로 물리 볼륨과 볼륨 그룹을 만들어도 동작하지 않습니다. LVM 도구에 익숙하다면, 이 한계를 피해가는 방법이 있습니다. </para
><para
>Power Macintosh 하드웨어에서 논리 볼륨을 사용하려면 마찬가지로 논리 볼륨에 사용할 디스크 파티션을 전부 만들어야 합니다. <guimenu
>파티션 설정</guimenu
> 메뉴에서 이 파티션들에 대해 <menuchoice
><guimenu
>용도:</guimenu
> <guimenuitem
>사용하지 않음</guimenuitem
></menuchoice
>를 선택합니다. (그러면 파티션을 물리 볼륨으로 사용할지에 대한 옵션이 없습니다.) 파티션을 다 만들면, 마찬가지로 논리 볼륨 관리자를 실행합니다. 하지만 물리 볼륨을 만들지 않았으므로 두 번째 가상 터미널에서 쉘을 이용해 (<xref linkend="shell"/> 참고) 수동으로 물리 볼륨을 만들어야 합니다. </para
><para
>쉘의 명령어 프롬프트에서 <command
>pvcreate</command
> 명령을 사용해 각 파티션에 물리 볼륨을 만듭니다. 그리고 <command
>vgcreate</command
> 명령으로 각 볼륨 그룹을 만듭니다. 이 명령을 실행할 때 나오는 잘못된 메타데이터 헤더 체크섬이라든지 fsync 실패와 같은 오류들은 무시해도 문제가 없습니다. 볼륨 그룹을 다 만들면, 다시 첫번째 가상 터미널로 들어가서 <command
>lvmcfg</command
> 메뉴 항목으로 돌아가 논리 볼륨 관리로 들어갑니다. 이제 볼륨 그룹이 보이고 마찬가지로 논리 볼륨을 만들 수 있습니다. </para
></note>

</para
><para
><command
>lvmcfg</command
>에서 <command
>partman</command
>으로 돌아간 다음, 보통 파티션과 마찬가지로 방금 만든 논리 볼륨이 나타납니다. (또 보통 파티션과 마찬가지 방법으로 이용하면 됩니다.) </para>
   </sect3>
<!--   End of file using-d-i/modules/lvmcfg.xml -->

<!-- Start of file using-d-i/modules/mdcfg.xml -->

   <sect3 id="mdcfg">
   <title
>멀티디스크 장치 설정하기 (소프트웨어 RAID)</title>
<para
>컴퓨터에 하드 드라이브가 여러 개 있는 경우<footnote
><para
> 물론 물리적으로 한 개의 드라이브에 있는 여러개의 파티션에서 멀티디스크 장치를 만들 수도 있겠지만, 그렇게 해 봤자 좋은 점이 전혀 없습니다. </para
></footnote
>, <command
>mdcfg</command
> 명령으로 드라이브의 성능을 향상시키거나, 데이터 안정성을 높일 수 있습니다. 이렇게 하는 걸 <firstterm
>멀티디스크 장치</firstterm
>라고 합니다. (더 자주 쓰이는 다른 말로 <firstterm
>RAID</firstterm
>라고 합니다.) </para
><para
>기본적으로 멀티디스크는 여러 디스크에 있는 여러 개의 파티션으로 하나의 <emphasis
>논리</emphasis
> 장치를 만드는 걸 말합니다. 그러면 이 논리 장치는 일반 파티션처럼 사용할 수 있습니다. (예를 들어 <command
>partman</command
>에서 포맷하고 마운트 위치를 지정하고 따위를 할 수 있습니다.) </para
><para
>어떤 종류의 멀티디스크 장치를 만드냐에 따라 어떤 이점이 있는지 달라집니다. 현재 지원하는 종류는: <variablelist
> <varlistentry
> <term
>RAID0</term
><listitem
><para
> 주로 성능 향상이 목적입니다. RAID0는 들어오는 데이터를 <firstterm
>스트라이프(stripe)</firstterm
>로 나눠서 배열의 각 디스크에 똑같이 분산시킵니다. 이렇게 하면 읽기/쓰기 작업의 속도가 빨라집니다. 하지만 디스크중에 하나라도 망가지면, <emphasis
>모든</emphasis
> 데이터를 잃게 됩니다. (망가지지 않은 디스크에 일부 데이터가 남아 있겠지만, 또 다른 부분이 망가진 디스크에 <emphasis
>있었기</emphasis
> 때문입니다.) </para
><para
> RAID0은 비디오를 편집하는 파티션에 많이 사용합니다. </para
></listitem
> </varlistentry
> <varlistentry
> <term
>RAID1</term
><listitem
><para
> 안정성을 최우선으로 할 때 적합합니다. RAID1은 여러 개의 (보통 두개) 같은 크기의 파티션으로 구성되어 있고, 여기서 각 파티션은 정확히 같은 데이터를 담고 있습니다. 이게 근본적으로 3가지 의미가 있습니다. 첫째로, 하나의 디스크가 망가지더라도, 나머지 디스에 데이터가 미러되어 있습니다. 둘째로, 디스크의 전체 용량보다 작은 용량만 사용할 수 있습니다. (좀더 정확히 말해, RAID에서 가장 작은 파티션입니다.) 세번째로, 파일 읽기는 로드 밸런싱으로 서버의 성능을 향상시켜, 파일서버와 같이 디스크 읽기가 쓰기보다 많은 경우 부담이 줄어듭니다. </para
></listitem
></varlistentry
> <varlistentry
> <term
>RAID5</term
><listitem
><para
> 속도, 안정성, 데이터 중첩을 적당히 조화시킨 것입니다. RAID5는 들어오는 모든 데이터를 스트라이프로 나누고 각각을 하나의 디스크가 아니라 (즉 RAID0와는 달리) 모두에게 분배합니다. RAID0와는 다르게 RAID5는 디스크에 쓸 정보의 <firstterm
>패리티</firstterm
> 정보를 계산합니다. 패리티 디스크는 고정되어 있지 않고 (고정되어 있으면 RAID4라고 합니다) 정기적으로 바뀝니다. 디스크중에 하나가 망가지면, 없어진 부분을 나머지 데이터와 패리티를 이용해서 계산해 냅니다. RAID5는 최소한 3개의 파티션이 있어야 합니다. 배열에 디스크를 하나 더 사용해서 망가진 디스크를 대체하도록 만들 수도 있습니다. </para
><para
> 이렇게 RAID5는 RAID1과 비슷한 정도의 안정성을 가지면서, 데이터를 덜 중복합니다. 한편 패리티 계산때문에 RAID0보다는 쓰는 속도가 느립니다. </para
></listitem
> </varlistentry
> </variablelist
> 요약하면: <informaltable
> <tgroup cols="5">
<thead>
<row>
  <entry
>종류</entry>
  <entry
>장치 최소 개수</entry>
  <entry
>예비 장치</entry>
  <entry
>디스크가 망가져도 버티는지?</entry>
  <entry
>사용 가능 공간</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>RAID0</entry>
  <entry
>2</entry>
  <entry
>아니오</entry>
  <entry
>아니오</entry>
  <entry
>RAID에서 가장 작은 파티션의 크기 x 장치 개수</entry>
</row>

<row>
  <entry
>RAID1</entry>
  <entry
>2</entry>
  <entry
>옵션</entry>
  <entry
>예</entry>
  <entry
>RAID에서 가장 작은 파티션의 크기</entry>
</row>

<row>
  <entry
>RAID5</entry>
  <entry
>3</entry>
  <entry
>옵션</entry>
  <entry
>예</entry>
  <entry
>가장 작은 파티션의 크기 x (RAID의 장치 개수 빼기 1) </entry>
</row>

</tbody
></tgroup
></informaltable>

</para
><para
>소프트웨어 RAID의 모든 것을 알고 싶으시면, <ulink url="&url-software-raid-howto;"
>Software RAID HOWTO</ulink
>를 읽어 보십시오. <note arch="powerpc" condition="sarge"
><para
>Apple Power Macintosh 하드웨어에서 RAID 데이터가 들어 있는 파티션을 인식하는 방법은 널리 인정된 표준이 없습니다. 그것 때문에 현재 이 플랫폼에서는 &d-i;에서 RAID 설정을 지원하지 않습니다. </para
></note>

</para
><para
>멀티디스크 장치를 만드려면, 구성할 파티션을 RAID에 사용한다고 표시해야 합니다. (<guimenu
>파티션 설정</guimenu
> 메뉴의 <command
>partman</command
>에서 <menuchoice
> <guimenu
>용도:</guimenu
> <guimenuitem
>RAID의 물리적 볼륨</guimenuitem
> </menuchoice
>을 선택하십시오. </para
><warning
><para
>설치 프로그램에서 멀티디스크 지원은 비교적 최근에 추가되었습니다. 어떤 특정 RAID 레벨을 특정 부트로더와 함께 루트 (<filename
>/</filename
>) 파일 시스템으로 멀티디스크를 사용한 경우에 문제가 발생할 수도 있습니다. 경험 많은 사용자들의 경우, 쉘에서 수동으로 설정하거나 수동으로 설치하는 방법으로 이러한 문제를 피해갈 수 있습니다. </para
></warning
><para
>그 다음 <command
>partman</command
> 메뉴에서 <guimenuitem
>소프트웨어 RAID 설정</guimenuitem
>을 선택합니다. <command
>mdcfg</command
>의 첫 번째 화면에서 <guimenuitem
>멀티디스크 장치 만들기</guimenuitem
>를 선택하기만 하면 지원하는 멀티디스크 장치의 종류 목록이 나옵니다. 거기에서 하나를 (예를 들어 RAID1) 고르십시오. 그 다음은 여기서 어떤 종류의 멀티디스크를 선택했냐에 따라 달라집니다. </para>

<itemizedlist>
<listitem
><para
>RAID0는 간단합니다. RAID 파티션의 목록이 나타나고 거기에서 멀티디스크를 구성할 파티션을 선택하기만 하면 됩니다. </para
></listitem>
<listitem
><para
>RAID1은 약간 더 까다롭습니다. 먼저 멀티디스크를 구성할 활성 장치의 개수 및 예비 장치의 개수를 입력합니다. 그리고 RAID 파티션 목록에서 무엇을 활성 파티션과 예비 파티션으로 할 지 결정합니다. 여기서 선택한 파티션 개수는 맨 처음에 입력한 개수와 일치해야 합니다. 걱정할 필요는 없습니다. 실수로 파티션 개수가 틀렸다고 해도, 개수가 맞을 때까지는 &d-i;가 다음으로 진행하지 않습니다. </para
></listitem>
<listitem
><para
>RAID5는 RAID1과 비슷한 설정을 하지만, 최소한 <emphasis
>3개의</emphasis
> 활성 파티션을 사용해야 한다는 점이 다릅니다. </para
></listitem>
</itemizedlist>

<para
>여러가지 종류의 멀티디스크를 동시에 사용하는 것도 물론 가능합니다. 예를 들어 3개의 200 GB 하드 드라이브를 멀티디스크에 사용할 때, 각 디스크에 100 GB 파티션이 두개씩 있다고 할 때, 각 3개 디스크의 첫번째 파티션들을 RAID0로 묶고 (빠른 300GB 비디오 편집 파티션) 나머지 3개 파티션을 (2개 활성, 1개 예비) RAID1으로 (<filename
>/home</filename
>에 사용할 안정성 높은 100GB 파티션) 사용할 수 있습니다. </para
><para
>원하는 대로 멀티디스크 장치를 만든 다음에, <command
>mdcfg</command
>에서 <guimenuitem
>마치기</guimenuitem
>를 선택하고 <command
>partman</command
>으로 돌아가 새로 만든 멀티디스크 장치에 파티션을 만들고 마찬가지로 마운트 위치와 같은 속성을 부여할 수 있습니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/mdcfg.xml -->
  </sect2>

  <sect2 id="di-install-base">
  <title
>베이스 시스템 설치하기</title>
<para
>이 단계는 문제가 발생할 가능성이 가장 낮지만, 설치할 때 가장 많은 시간을 소모합니다. 여기서는 베이스 시스템 전체를 내려받고, 확인한 다음, 압축을 풉니다. 컴퓨터가 느리거나 네트워크 연결이 느리다면 시간이 좀 걸릴 수도 있습니다. </para>


<!-- Start of file using-d-i/modules/base-installer.xml -->

   <sect3 id="base-installer">
   <title
>베이스 시스템 설치</title>

<para
>베이스 설치 중에 패키지를 풀고 설정하면서 나오는 메세지는 <userinput
>tty3</userinput
>에서 표시합니다. 이 터미널은 <keycombo
><keycap
>왼쪽 Alt</keycap
><keycap
>F3</keycap
></keycombo
>을 누르면 이용할 수 있습니다. 설치 프로그램 화면으로 돌아가려면 <keycombo
><keycap
>왼쪽 Alt</keycap
><keycap
>F1</keycap
></keycombo
>을 누르십시오. </para
><para
>설치를 시리얼 콘솔을 통해서 하는 경우에는, 베이스 설치할 때 압축 풀기/설정 메세지는 <filename
>/var/log/messages</filename
> 파일에 저장합니다. </para
><para
>설치 과정의 하나로 리눅스 커널을 설치합니다. 기본 우선순위로에서는 하드웨어에 가장 맞는 커널을 하나 선택합니다. 우선순위가 낮은 모드에서는, 사용 가능한 여러가지 커널 중에서 하나를 선택할 수 있습니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/base-installer.xml -->
  </sect2>

  <sect2 id="di-make-bootable">
  <title
>시스템을 부팅 가능하게 만들기</title>

<para condition="supports-nfsroot"
>디스크 없는 워크스테이션에 설치하는 경우에는, 로컬 디스크에서 부팅하는 건 물론 전혀 가능한 방법이 아니므로 이 단계는 건너 뜁니다. <phrase arch="sparc"
>네트워크를 통해 부팅하도록 OpenBoot를 설정할 수도 있습니다. <xref linkend="boot-dev-select-sun"/> 부분을 참고하십시오.</phrase
> </para
><para
>한 컴퓨터에서 여러 개의 운영 체제를 부팅하는 건 아직까지도 매우 복잡한 기술입니다. 이 문서에서는 모든 부팅 관리자에 대해 다루려고 하지도 않습니다. 부팅 관리자는 아키텍처마다 다르고 서브 아키텍처마다도 다릅니다. 자세한 정보는 부팅 관리자의 문서를 참고하십시오. </para>


<!-- Start of file using-d-i/modules/os-prober.xml -->

   <sect3 id="os-prober">
   <title
>다른 운영 체제 찾기</title>

<para
>설치 프로그램은 부트로더를 설치하기 전에 컴퓨터에 설치되어 있는 다른 운영체제가 있는 지 찾아봅니다. 부트로더가 지원하는 운영 체제가 있으면 부트로더를 설치하는 단계에서 알려 주고, 데비안 부팅 외에 추가로 이 다른 운영체제를 부팅할 수 있도록 설정할 것입니다. </para
><para
>한 컴퓨터에서 여러 개의 운영 체제를 부팅하는 건 아직도 매우 복잡한 기술입니다. 다른 운영체제를 자동으로 찾아내고 부트로더를 설정하는 건 아키텍처마다 다르고, 서브 아키텍처마다도 다릅니다. 동작하지 않으면 부트로더의 문서에서 더 자세한 사항을 찾아보십시오. </para>

<note condition="sarge"
><para
>다른 운영체제를 찾을 때, 파티션이 마운트되어 있으면 그 안의 운영체제를 찾지 못할 수도 있습니다. 이 현상은 <command
>partman</command
>에서 다른 운영체제가 들어 있는 파티션에 마운트 위치를 지정했을 경우 (예를 들어 /win) 발생합니다. 아니면 콘솔에서 파티션을 수동으로 마운트했을 경우에도 발생합니다. </para
></note>

   </sect3>
<!--   End of file using-d-i/modules/os-prober.xml -->

<!-- Start of file using-d-i/modules/alpha/aboot-installer.xml -->

  <sect3 arch="alpha">
  <title
>하드 디스크에 <command
>aboot</command
> 설치</title>
<para
>SRM에서 부팅할 때 이 옵션을 선택하면, 데비안을 설치하는 디스크의 첫번째 섹터에 <command
>aboot</command
>를 써 넣습니다. <emphasis
>매우</emphasis
> 주의를 기울이십시오. <command
>aboot</command
>는 같은 디스크에 있는 여러 개의 운영 체제를 부팅하지 <emphasis
>못합니다</emphasis
>. (예를 들어 GNU/리눅스, Free/Open/NetBSD, OSF/1 다른 이름으로 Digital Unix/True64 Unix, 아니면 OpenVMS) 데비안을 설치하는 디스크에 다른 운영체제도 설치되어 있다면, <command
>aboot</command
>를 설치하지 말고 플로피로 GNU/리눅스를 부팅해야 할 것입니다. </para>
  </sect3>
<!--   End of file using-d-i/modules/alpha/aboot-installer.xml -->

<!-- Start of file using-d-i/modules/hppa/palo-installer.xml -->

  <sect3 arch="hppa">
  <title
><command
>palo</command
>-installer</title>
<para
>PA-RISC의 부트로더는 <quote
>palo</quote
>입니다. <command
>PALO</command
>는 설정과 사용면에서 몇가지만 제외하고 <command
>LILO</command
>와 비슷합니다. 그 중의 하나로, <command
>PALO</command
>는 부팅 파티션에 있는 어떤 커널 이미지라도 부팅할 수 있습니다. <command
>PALO</command
>는 리눅스 파티션을 읽을 수 있기 때문입니다. </para
><para condition="FIXME"
>hppa FIXME ( need more info ) </para>
  </sect3>
<!--   End of file using-d-i/modules/hppa/palo-installer.xml -->

<!-- Start of file using-d-i/modules/i386/grub-installer.xml -->

  <sect3 arch="i386">
  <title
>하드 디스크에 <command
>GRUB</command
> 부트로더 설치</title>
<para
>&architecture;의 주요 부트로더는 <quote
>GRUB</quote
>입니다. GRUB은 유연하고 안정적인 부트로더이고, 초보자와 오래된 사용자 모두에게 좋은 기본 부트로더입니다. </para
><para
>기본적으로 GRUB은 마스터 부트 레코드에 (MBR) 설치합니다. 그래야 부팅 과정을 완전히 조종할 수 있습니다. 원하신다면 다른 위치에 설치할 수도 있습니다. 완전한 정보를 보려면 GRUB 매뉴얼을 참고하십시오. </para
><para
>GRUB을 아예 설치하지 않으려면, "뒤로" 단추를 사용해서 메인 메뉴로 이동한 다음에, 쓰고 싶은 부트로더를 선택하십시오. </para>
  </sect3>
<!--   End of file using-d-i/modules/i386/grub-installer.xml -->

<!-- Start of file using-d-i/modules/i386/lilo-installer.xml -->

  <sect3 arch="i386">
  <title
>하드 디스크에 <command
>LILO</command
> 부트로더 설치</title>
<para
>두번째 &architecture; 부트로더는 <quote
>LILO</quote
>입니다. 오래되고 복잡한 프로그램으로 DOS, Windows, OS/2 부트 관리자 등 아주 많은 기능이 있습니다. 특별히 필요한 점이 있으면 <filename
>/usr/share/doc/lilo/</filename
> 디렉토리에 있는 안내 문서를 잘 읽어보십시오. 또 <ulink url="&url-lilo-howto;"
>LILO mini-HOWTO</ulink
>도 참고하십시오. </para>
<note
><para
>지금은 LILO를 설치해도 <firstterm
>체인로드(chainload)</firstterm
>가 가능한 운영체제의 메뉴 항목만 만듭니다. 즉 GNU/리눅스 및 GNU/허드와 같은 운영체제는 메뉴 항목을 수동으로 추가해야 할 수도 있습니다. </para
></note>
<para
>&d-i;에서는 <command
>LILO</command
>를 설치할 위치로 세 가지중의 하나를 선택합니다. <variablelist>
<varlistentry>
<term
>마스터 부트 레코드 (Master Boot Record, MBR)</term
><listitem
><para
>이 방법으로 <command
>LILO</command
>가 부팅 과정을 완전히 책임지게 됩니다. </para
></listitem
></varlistentry>
<varlistentry>
<term
>새 데비안 파티션</term
><listitem
><para
>다른 부팅 관리자를 사용하려면 이걸 선택하십시오. <command
>LILO</command
>는 새 데비안 파티션의 맨 앞쪽에 설치되어 보조 부트로더로서 동작합니다. </para
></listitem
></varlistentry>
<varlistentry>
<term
>기타</term
><listitem
><para
>MBR이 아닌 다른 위치에 <command
>LILO</command
>를 설치하려는 고급 사용자에게 유용한 정보입니다. 이 경우에 LILO를 설치하려는 위치를 물어봅니다. DEVFS 스타일의 이름을 사용할 수 있습니다. (예를 들어 전통적인 방식의 이름으로 <filename
>/dev/hda</filename
> 혹은 <filename
>/dev/sda</filename
>라고 쓸 수도 있고, DEVFS 방식으로 <filename
>/dev/ide</filename
>, <filename
>/dev/scsi</filename
> 및 <filename
>/dev/discs</filename
>라고 쓸 수도 있습니다.) </para
></listitem
></varlistentry>
</variablelist>

</para
><para
>이 단계를 거친 다음에 Windows 9x로 (아니면 DOS로) 부팅할 수 없게 된다면, Windows 9x (MS-DOS) 부팅 디스크를 이용해서 <userinput
>fdisk /mbr</userinput
> 명령을 실행해서 MS-DOS 마스터 부트 레코드를 다시 설치해야 부팅할 수 있을 것입니다. 하지만 이 명령을 실행한 다음에 데비안으로 들어가려면 뭔가 다른 방법이 필요합니다! 더 자세한 정보는 <xref linkend="reactivating-win"/> 부분을 참고하십시오. </para>
  </sect3>
<!--   End of file using-d-i/modules/i386/lilo-installer.xml -->

<!-- Start of file using-d-i/modules/ia64/elilo-installer.xml -->

  <sect3 arch="ia64">
  <title
>하드 디스크에 <command
>ELILO</command
> 부트로더 설치</title>
<para
>&architecture; 부트로더는 <quote
>elilo</quote
>라고 합니다. x86 아키텍처용 부트로더인 <quote
>LILO</quote
>를 모델로 만들어졌고 비슷한 설정 파일을 사용합니다. 하지만 디스크의 MBR이나 파티션의 부트 레코드에 쓰지 않고, 필요한 파일을 별도의 FAT 포맷된 디스크 파티션에 넣고 펌웨어의 <guimenuitem
>EFI Boot Manager</guimenuitem
> 메뉴를 고쳐서 EFI 파티션의 파일들을 가리키게 합니다. <command
>elilo</command
> 부트로더는 사실 두 부분입니다. <filename
>/usr/sbin/elilo</filename
> 명령은 파티션을 관리하고 파일을 이 파티션에 복사합니다. <filename
>elilo.efi</filename
> 프로그램은 EFI 파티션에 복사되고 <quote
>EFI Boot Manager</quote
>에 의해 실행되어 실제로 리눅스 커널을 읽어들이고 시작하는 일을 합니다. </para
><para
><quote
>elilo</quote
> 설정과 설치는 베이스 꾸러미 설치의 맨 마지막에 합니다. EFI 파티션으로 쓸 수 있다고 찾은 파티션 목록이 나타납니다. 이전에 준비했던 파티션을 선택합니다. 보통 <emphasis
>루트</emphasis
> 파일시스템이 들어 있는 같은 디스크의 파티션입니다. </para>

  <warning
><title
>올바른 파티션을 고르십시오!</title>

<para
>파티션을 고르는 기준은 <emphasis
>부팅</emphasis
> 플래그가 있는 FAT 포맷된 파일시스템이라는 것입니다. &d-i;에서는 시스템의 모든 디스크를 검사해서 무엇을 찾았느냐에 따라 (다른 운영체제용 EFI 파티션과 EFI 진단 파티션 포함) 여러 파티션 중의 하나를 선택해야 할 수도 있습니다. <command
>elilo</command
>는 설치하는 동안 해당 파티션을 포맷할 수도 있고, 그러면 이전의 내용이 모두 지워집니다! </para
></warning>

  </sect3>

  <sect3 arch="ia64">
  <title
>EFI 파티션 내용</title>

<para
>EFI 파티션은 시스템의 하드디스크 중 하나에 들어 있는 FAT 파일시스템 파티션입니다. 보통 <emphasis
>루트</emphasis
> 파일시스템이 들어 있는 디스크와 같은 디스크에 들어 있습니다. 이 파티션은 동작하고 있는 시스템에서 마운트하지 않습니다. <quote
>EFI Boot Manager</quote
>에서 시스템을 읽어들일 때만 사용하고, <command
>elilo</command
> 설치 도구는 마운트하지 않은 채로 파일 시스템에 직접 쓰기 작업을 합니다. <command
>/usr/sbin/elilo</command
> 유틸리티는 설치할 때 다음 파일을 EFI 파티션의 <filename
>efi/debian</filename
> 디렉토리에 써 넣습니다. 단 <quote
>EFI Boot Manager</quote
>는 이 파일을 찾을 때 <filename
>fs<replaceable
>n</replaceable
>:\efi\debian</filename
> 경로를 사용해서 찾습니다. 시간이 지남에 따라 시스템을 업데이트하거나 다시 설정할 때마다 이 파일 시스템에는 다른 파일이 들어갈 수 있습니다. </para>

<variablelist>

<varlistentry>
<term
><filename
>elilo.conf</filename
></term>
<listitem
><para
>부트로더가 시작할 때 읽는 설정 파일입니다. 이 파일은 <filename
>/etc/elilo.conf</filename
> 파일과 동일하지만, EFI 파티션에 있는 파일을 참조하도록 그 안의 파일이름을 바꾼 것입니다. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>elilo.efi</filename
></term>
<listitem
><para
><quote
>EFI Boot Manager</quote
>가 시스템을 부팅할 때 실행하는 부트로더 프로그램입니다. <quote
>EFI Boot Manager</quote
>의 명령어 메뉴에서 <guimenuitem
>Debian GNU/Linux</guimenuitem
> 항목을 선택하면 실행하는 프로그램입니다. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>initrd.img</filename
></term>
<listitem
><para
>커널을 부팅할 때 사용할 최초의 루트 파일시스템입니다. <filename
>/etc/elilo.conf</filename
>에서 참조하는 파일을 복사한 것입니다. 표준 데비안 설치에서는 이 파일이 <filename
>/boot</filename
> 안에 들어 있고 <filename
>/initrd.img</filename
> 심볼릭 링크가 그 파일을 가리킵니다. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>readme.txt</filename
></term>
<listitem
><para
>작은 텍스트 파일로, 이 디렉토리의 내용은 <command
>elilo</command
>가 관리하므로 로컬 변경 사항은 다음에 <filename
>/usr/sbin/elilo</filename
>를 실행하면 없어진다는 사실을 알리는 내용이 들어 있습니다. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>vmlinuz</filename
></term>
<listitem
><para
>압축한 커널입니다. 이 파일은 <filename
>/etc/elilo.conf</filename
>에서 가리키는 파일을 복사한 것입니다. 표준 데비안 설치에서는 이 파일은 <filename
>/boot</filename
> 안에 들어 있고 <filename
>/vmlinuz</filename
> 심볼릭 링크가 그 파일을 가리킵니다. </para
></listitem
></varlistentry>

</variablelist>

  </sect3>
<!--   End of file using-d-i/modules/ia64/elilo-installer.xml -->

<!-- Start of file using-d-i/modules/mips/arcboot-installer.xml -->

  <sect3 arch="mips">
  <title
><command
>arcboot</command
>-installer</title>
<para
>SGI Indy에서 부트로더는 <command
>arcboot</command
>입니다. <command
>arcboot</command
>는 커널과 같은 하드 디스크에 설치해야 합니다. (설치 프로그램에서 자동으로 그렇게 해 줍니다.) arcboot는 <filename
>/etc/arcboot.conf</filename
> 파일 안에 여러가지 설정을 할 수 있습니다. 각 설정 엔트리는 각각의 이름이 있고, 설치 프로그램이 만드는 설정의 이름은 <quote
>linux</quote
>입니다. arcboot를 설치한 다음, 펌웨어 프롬프트에서 다음 펌웨어 환경 변수를 입력합니다 <informalexample
><screen>
<userinput
> setenv SystemPartition scsi(<replaceable
>scsi</replaceable
>)disk(<replaceable
>disk</replaceable
>)rdisk(0)partition(0)</userinput>
<userinput
> setenv OSLoadPartition scsi(<replaceable
>scsi</replaceable
>)disk(<replaceable
>disk</replaceable
>)rdisk(0)partition(<replaceable
>partnr</replaceable
>)</userinput>
<userinput
> setenv OSLoader arcboot</userinput>
<userinput
> setenv OSLoadFilename <replaceable
>config</replaceable
></userinput>
<userinput
> setenv AutoLoad yes</userinput>
</screen
></informalexample
> 그리고 <command
>boot</command
> 명령을 실행하는 방법으로 시스템을 하드 디스크에서 부팅할 수 있습니다. </para>

<variablelist>
<varlistentry>
<term
> <replaceable
>scsi</replaceable
> </term>
<listitem
><para
>부팅하려는 SCSI 버스입니다. 온보드 컨트롤러의 경우 <userinput
>0</userinput
>입니다 </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>disk</replaceable
> </term>
<listitem
><para
><command
>arcboot</command
>를 설치한 하드디스크의 SCSI ID </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>partnr</replaceable
> </term>
<listitem
><para
><filename
>/etc/arcboot.conf</filename
> 파일이 들어 있는 파티션 번호 </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>config</replaceable
> </term>
<listitem
><para
><filename
>/etc/arcboot.conf</filename
> 안에 있는 설정 항목 이름입니다. 기본값은 <quote
>linux</quote
>입니다. </para
></listitem>
</varlistentry>
</variablelist>

  </sect3>
<!--   End of file using-d-i/modules/mips/arcboot-installer.xml -->

<!-- Start of file using-d-i/modules/mipsel/colo-installer.xml -->
<!--   End of file using-d-i/modules/mipsel/colo-installer.xml -->

<!-- Start of file using-d-i/modules/mipsel/delo-installer.xml -->

  <sect3 arch="mipsel">
  <title
><command
>delo</command
>-installer</title>
<para
>DECstation에서 부트로더는 <command
>DELO</command
>입니다. <command
>DELO</command
>는 커널과 같은 하드 디스크에 설치해야 합니다. (설치 프로그램에서 자동으로 그렇게 해 줍니다.) DELO는 <filename
>/etc/delo.conf</filename
> 파일 안에 여러가지 설정을 할 수 있습니다. 각 설정 엔트리는 각각의 이름이 있고, 설치 프로그램이 만드는 설정의 이름은 <quote
>linux</quote
>입니다. arcboot를 설치한 다음, 펌웨어 프롬프트에서 다음을 입력하면 하드 디스크에서 시스템을 부팅할 수 있습니다 <informalexample
><screen>
<userinput
>boot <replaceable
>#</replaceable
>/rz<replaceable
>id</replaceable
> <replaceable
>partnr</replaceable
>/<replaceable
>name</replaceable
></userinput>
</screen
></informalexample
> </para>

<variablelist>
<varlistentry>
<term
> <replaceable
>#</replaceable
> </term>
<listitem
><para
>부팅할 TurboChannel 장치. 대부분의 DECstation에서 온보드 컨트롤러들은 <userinput
>3</userinput
>입니다 </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>id</replaceable
> </term>
<listitem
><para
><command
>DELO</command
>를 설치한 하드 디스크의 SCSI ID </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>partnr</replaceable
> </term>
<listitem
><para
><filename
>/etc/delo.conf</filename
> 파일이 들어 있는 파티션 번호 </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>name</replaceable
> </term>
<listitem
><para
><filename
>/etc/delo.conf</filename
> 파일에 들어갈 설정 항목의 이름입니다. 기본값은 <quote
>linux</quote
>입니다. </para
></listitem>
</varlistentry>
</variablelist>

<para
><filename
>/etc/delo.conf</filename
>가 디스크의 첫번째 파티션에 들어 있고 기본 설정으로 부팅하는 경우, 다음을 사용하면 충분합니다: <informalexample
><screen
><userinput
>boot #/rz<replaceable
>id</replaceable
></userinput
>
</screen
></informalexample>

</para>
  </sect3>
<!--   End of file using-d-i/modules/mipsel/delo-installer.xml -->

<!-- Start of file using-d-i/modules/powerpc/yaboot-installer.xml -->

  <sect3 arch="powerpc">
  <title
>하드 디스크에 <command
>yaboot</command
> 설치</title>
<para
>최근의 (1998년 중반 이후) PowerMac에서는 부트로더로 <command
>yaboot</command
>를 사용합니다. 설치 프로그램은 자동으로 <command
>yaboot</command
>를 설정하기 때문에, 필요한 건 <emphasis
>Apple_Bootstrap</emphasis
> 타입의 <quote
>bootstrap</quote
>이라는 이름의 820k 크기의 작은 파티션뿐입니다. 이 파티션은 앞의 파티션 구성 요소에서 만듭니다. 이 단계에서 성공적으로 끝나면 디스크가 부팅 가능하게 되고 OpenFirmware에서 &debian; 부팅 준비가 끝납니다. </para>
  </sect3>
<!--   End of file using-d-i/modules/powerpc/yaboot-installer.xml -->

<!-- Start of file using-d-i/modules/powerpc/quik-installer.xml -->

  <sect3 arch="powerpc">
  <title
>하드 디스크에 <command
>Quik</command
> 설치</title>
<para
>OldWorld Power Macintosh에서 부트로더는 <command
>quik</command
>입니다. CHRP 위에서 사용할 수도 있습니다. 설치 프로그램은 자동으로 <command
>quik</command
>를 설정합니다. 이 설정은 7200, 7300, 7600 Powermac 및 일부 Power Computing 호환품에서 동작한다고 알려져 있습니다. </para>
  </sect3>
<!--   End of file using-d-i/modules/powerpc/quik-installer.xml -->

<!-- Start of file using-d-i/modules/s390/zipl-installer.xml -->

  <sect3 arch="s390">
  <title
><command
>zipl</command
>-installer</title>
<para
>&arch-title; 아키텍처에서 부트로더는 <quote
>ZIPL</quote
>입니다. <command
>ZIPL</command
>은 <command
>LILO</command
>와 설정이나 사용법이 몇 가지만 제외하고 비슷합니다. <command
>ZIPL</command
>은에 대해 더 알고 싶으시면 IBM의 developerWorks 웹사이트에서 <quote
>LINUX for &arch-title; Device Drivers and Installation Commands</quote
>를 보십시오. </para>
  </sect3>
<!--   End of file using-d-i/modules/s390/zipl-installer.xml -->

<!-- Start of file using-d-i/modules/sparc/silo-installer.xml -->

  <sect3 arch="sparc">
  <title
>하드 디스크에 <command
>SILO</command
> 부트로더 설치</title>
<para
>표준 &architecture; 부트로더는 <quote
>SILO</quote
>라고 합니다. <quote
>SILO</quote
>의 문서는 <filename
>/usr/share/doc/silo/</filename
> 안에 있습니다. <command
>SILO</command
>는 설정과 사용법이 몇 가지만 제외하고 <command
>LILO</command
>와 비슷합니다. 일단 <command
>SILO</command
>를 사용하면 드라이브에 있는 어떤 커널 이미지라도 부팅할 수 있습니다. (<filename
>/etc/silo.conf</filename
> 파일에 들어 있지 않은 커널이라도 가능합니다.) <command
>SILO</command
>는 리눅스 파티션을 읽을 수 있기 때문입니다. 또 <filename
>/etc/silo.conf</filename
> 파일은 부팅할 때 읽어들이므로, <command
>LILO</command
>와는 달리 새로운 커널을 설치한 다음에도 <command
>SILO</command
> 명령을 다시 실행할 필요가 없습니다. <command
>SILO</command
>는 UFS 파티션도 읽을 수 있어서, SunOS/Solaris 파티션도 부팅할 수 있습니다. 이 기능은 GNU/Linux를 기존 SunOS/Solaris와 같이 설치할 때 유용합니다. </para>
  </sect3>
<!--   End of file using-d-i/modules/sparc/silo-installer.xml -->

<!-- Start of file using-d-i/modules/nobootloader.xml -->

   <sect3 id="nobootloader">
   <title
>부트로더 없이 계속</title>

<para
>이 옵션은 부트로더를 설치하지 않았지만 설치를 마칠 때 사용할 수 있습니다. 이렇게 하는 경우는 아마도 해당 아키텍처나 서브 아키텍처에 부트로더가 없거나, 부트로더가 필요없는 경우일 (예를 들어 기존 부트로더를 사용) 것입니다. <phrase arch="m68k"
>이 옵션은 Macintosh, Atari, Amiga 시스템처럼 기존 운영체제를 유지하면서 기존 운영체제에서 GNU/리눅스를 부팅하는 경우에 사용합니다.</phrase
> </para
><para
>부트로더를 수동으로 설정하려면, <filename
>/target/boot</filename
>에 설치한 커널의 이름을 확인해야 합니다. 또 이 디렉토리에 <firstterm
>initrd</firstterm
>가 있는 지 확인하고, 있으면 아마도 부트로더가 그 <firstterm
>initrd</firstterm
>를 사용하도록 해야 할 것입니다. 그 외에 필요한 정보는 <filename
>/</filename
> 파일 시스템으로 사용하려는 디스크 및 파티션을 알아야 하고, <filename
>/boot</filename
>가 별도 파티션이면 <filename
>/boot</filename
> 파일시스템의 디스크 및 파티션도 알아야 합니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/nobootloader.xml -->
  </sect2>

  <sect2 id="di-finish">
  <title
>첫 단계 마치기</title>
<para
>다음은 새 데비안 시스템을 다시 시작하기 전에 할 마지막 작업입니다. 대부분은 &d-i;를 끝내고 정리하는 작업들입니다. </para>


<!-- Start of file using-d-i/modules/prebaseconfig.xml -->

   <sect3 id="prebaseconfig">
   <title
>설치 마치기 및 다시 시작하기</title>

<para
>데비안 설치 과정의 첫번째에서 제일 마지막 단계입니다. 설치 프로그램을 부팅할 때 사용했던 부팅 미디어를 (CD, 플로피 등) 빼라는 말이 나옵니다. 여기서 남은 작업을 다 마친 다음에, 새로 설치한 데비안 시스템으로 다시 시작합니다. </para
><para arch="s390"
><guimenuitem
>설치 마치기</guimenuitem
> 항목을 선택하면 시스템을 정지시킵니다. 이 경우에 &arch-title;에서는 컴퓨터 다시 시작을 지원하지 않기 때문입니다. 앞 단계에서 루트 파일시스템으로 선택했던 DASD에서, 다음에 GNU/리눅스를 부팅하면 (IPL) 됩니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/prebaseconfig.xml -->
  </sect2>

  <sect2 id="di-miscellaneous">
  <title
>기타</title>
<para
>여기에 목록이 나와 있는 구성 요소는 일반적인 설치 과정과는 상관이 없습니다. 하지만 백그라운드에서 기다리면서 잘못된 부분이 있을 때 도움이 됩니다. </para>


<!-- Start of file using-d-i/modules/save-logs.xml -->

   <sect3 id="save-logs">
   <title
>설치 로그 저장</title>

<para
>설치가 성공하면, 설치할 때 만든 로그 파일은 새 데비안 시스템의 <filename
>/var/log/debian-installer/</filename
> 파일에 자동으로 저장합니다. </para
><para
>메인 메뉴에서 <guimenuitem
>디버그 로그 저장</guimenuitem
>을 선택하면 로그 파일을 플로피 디스크<phrase condition="etch"
>네트워크, 하드디스크, 그 외의 미디어</phrase
>에 저장합니다. 설치할 때 심각한 문제가 발생할 경우에 다른 시스템에서 로그를 분석한 다음, 이 로그를 설치 보고서에 첨부할 수 있습니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/save-logs.xml -->

<!-- Start of file using-d-i/modules/cdrom-checker.xml -->
<!--   End of file using-d-i/modules/cdrom-checker.xml -->

<!-- Start of file using-d-i/modules/shell.xml -->

   <sect3 id="shell">
   <title
>쉘 사용하기 및 로그 보기</title>
   <!-- TODO: There is nothing about logs in this section! -->

<para
>메뉴에 <guimenuitem
>쉘 실행</guimenuitem
> 항목이 있습니다. 쉘을 사용해야 하는데 메뉴가 없으면, <keycombo
><keycap
>왼쪽 Alt</keycap
> <keycap
>F2</keycap
></keycombo
>를 눌러 (Mac 키보드에서는 <keycombo
><keycap
>Option</keycap
> <keycap
>F2</keycap
></keycombo
>) 두 번째 <emphasis
>가상 터미널</emphasis
>로 전환합니다. <keycap
>스페이스바</keycap
> 왼쪽에 있는 <keycap
>Alt</keycap
> 키와 <keycap
>F2</keycap
> 펑션 키를 동시에 누르는 걸 말합니다. 이 가상 터미널은 완전히 별도의 창으로 <command
>ash</command
>이라고 하는 본쉘 호환 쉘이 동작합니다. </para
><para
>이 시점에서는 램디스크에서 부팅했기때문에, 제한적인 유닉스 유틸리티만 사용할 수 있습니다. 어떤 프로그램이 있는지는 <command
>ls /bin /sbin /usr/bin /usr/sbin</command
> 명령 및 <command
>help</command
>를 입력해서 알 수 있습니다. 텍스트 에디터는 <command
>nano</command
>입니다. 이 쉘에는 자동완성이나 히스토리같은 훌륭한 기능도 좀 있습니다. </para
><para
>어떤 작업을 수행할 때 메뉴로 할 수 있으면 메뉴로 하십시오. 쉘과 명령어들은 무언가 잘못되었을 경우를 대비한 것 뿐입니다. 특히 스왑 파티션을 활성화할 때는 쉘이 아니라 꼭 메뉴를 사용해야 합니다. 쉘에서 스왑 파티션을 활성화해도 메뉴 소프트웨어에서는 알지 못하기 때문입니다. <keycombo
><keycap
>왼쪽 Alt</keycap
> <keycap
>F1</keycap
></keycombo
>을 누르면 메뉴로 돌아가고, 메뉴에서 쉘을 실행한 경우에는 <command
>exit</command
> 명령을 실행하면 메뉴로 돌아갑니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/shell.xml -->

<!-- Start of file using-d-i/modules/network-console.xml -->

   <sect3 id="network-console">
   <title
>네트워크를 통해 설치</title>

<para arch="not-s390"
>재미있는 구성 요소 중의 하나로 <firstterm
>network-console</firstterm
>이 있습니다. 설치 작업의 많은 부분을 네트워크 SSH을 통해 수행하게 되어 있습니다. 네트워크를 사용해야 하기 때문에 최소한 네트워크 설정하기까지의 맨 처음 설치 작업은 콘솔에서 해야 합니다. (이 부분은 <xref linkend="automatic-install"/>에 따라 자동화할 수 있습니다.) </para
><para arch="not-s390"
>이 구성 요소는 주 설치 메뉴에는 기본으로 읽어들이지 않기 때문에, 이 구성 요소를 읽어들이라고 지정해야 합니다. CD에서 설치하는 경우에는 중간 우선 순위로 설치하거나 주 설치 메뉴가 나타나면 <guimenuitem
>CD에서 설치 프로그램 구성 요소를 읽어들이기</guimenuitem
>을 선택하고 <guimenuitem
>network-console: SSH을 사용해 원격에서 설치하기</guimenuitem
> 추가 구성 요소를 선택합니다. 성공적으로 읽어들이면 <guimenuitem
>SSH을 사용해 원격에서 설치하기</guimenuitem
> 메뉴 항목이 새로 생깁니다. </para
><para arch="s390"
>&arch-title;에 설치할 경우, 네트워크를 설정한 다음에 사용하는 기본 설치 방법입니다. </para
><para
><phrase arch="not-s390"
>새로 생긴 이 항목을 선택한 다음에, </phrase
>설치 시스템에 연결하는데 사용할 새 열쇠글을 입력하게 됩니다. 여기까지 하면 <emphasis
>installer</emphasis
> 사용자로 방금 입력한 열쇠글을 이용해 원격에서 로그인할 수 있는 방법을 알려주는 화면을 표시합니다. 이 화면의 또 다른 중요한 정보는 시스템의 핑거프린트입니다. 이 핑거프린트를 <quote
>시스템을 원격에서 설치할 사람에게</quote
> 안전하게 전달해야 합니다. </para
><para
>로컬에서 설정을 계속하려고 마음을 바꾸었다면, 언제든지 &enterkey;를 눌러서 주 메뉴로 돌아갈 수 있습니다. 주 메뉴에서 다른 구성 요소를 선택하면 됩니다. </para
><para
>이제 네트워크의 다른 한 편으로 가서 할 일입니다. 먼저 필요한 일은, 터미널을 UTF-8 인코딩을 쓰도록 설정하는 일입니다. UTF-8 인코딩이 설치 시스템에서 사용하는 인코딩입니다. UTF-8으로 설정하지 않아도 원격 설치가 가능하지만 창의 테두리라던지, 읽을 수 없는 ASCII가 아닌 문자처럼 표시가 깨질 수도 있습니다. 설치 시스템에 연결하려면 간단히 다음과 같은 명령을 사용하면 됩니다: <informalexample
><screen>
<prompt
>$</prompt
> <userinput
>ssh -l installer <replaceable
>install_host</replaceable
></userinput>
</screen
></informalexample
> 여기서 <replaceable
>install_host</replaceable
>는 설치할 컴퓨터의 이름이나 IP 주소입니다. 실제로 로그인하기 전에 원격 시스템의 핑거프린트가 표시될 것이고, 이 핑거프린트가 올바른 지 확인해야 합니다. </para
><note
><para
>여러 컴퓨터를 모두 설치하는 경우에 IP 주소 혹은 호스트 이름이 같은 경우, 그런 호스트는 <command
>ssh</command
>에서 연결을 거부합니다. 그 이유는 핑거프린트가 다르기 때문이고, 핑거프린트가 다르다는 건 스푸핑 공격의 징조입니다. 스푸핑이 아니라고 확신하는 경우, <filename
>~/.ssh/known_hosts</filename
>에서 해당 줄을 지우고 다시 연결하면 됩니다. </para
></note
><para
>로그인한 다음에 최초 화면이 나오면 거기에서 <guimenuitem
>메뉴 시작</guimenuitem
>과 <guimenuitem
>쉘 시작</guimenuitem
> 중의 하나를 선택할 수 있습니다. 전자의 경우는 설치 프로그램의 주 메뉴로 가게 되고, 거기에서 로컬에서와 마찬가지로 설치 작업을 계속할 수 있습니다. 후자는 쉘을 실행해서 원격 시스템을 살펴보고 문제점을 수정할 수 있습니다. 설치 메뉴는 한 개의 SSH 세션만 열어야 합니다. 하지만 쉘의 경우에는 여러 개를 열어도 됩니다. </para
><warning
><para
>SSH을 통해 원격으로 설치를 시작하면, 다시 로컬 콘솔로 돌아가서 설치를 하면 안 됩니다. 그렇게 하면 새로 설치할 시스템에 있는 설정들을 망가뜨릴 수 있습니다. 설정들이 망가지면 설치가 실패하거나 새로 설치한 시스템에 여러가지 문제가 발생할 수 있습니다. </para
><para
>또 SSH 세션을 X 터미널에서 실행하는 경우 연결이 끊어질 수도 있으므로 창 크기를 바꾸지 말아야 합니다. </para
></warning>

   </sect3>
<!--   End of file using-d-i/modules/network-console.xml -->

<!-- Start of file using-d-i/modules/baseconfig.xml -->

   <sect3 id="baseconfig">
   <title
>&d-i; 안에서 <command
>base-config</command
> 실행하기</title>

<para
>베이스 시스템을 첫번째 단계의 설치 프로그램에서 (하드 드라이브에서 부팅하기 전에) 설정할 수 있습니다. <firstterm
>chroot</firstterm
> 환경에서 <command
>base-config</command
>를 실행하면 됩니다. 이 방법은 설치 프로그램을 테스트할 경우에나 쓸 만한 방법이므로 보통의 경우 이 방법은 사용하지 말아야 합니다. </para>
   </sect3>
<!--   End of file using-d-i/modules/baseconfig.xml -->
  </sect2>
 </sect1>
<!--   End of file using-d-i/components.xml -->

</chapter>

<!--   End of file using-d-i/using-d-i.xml -->
